//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

	// Baseline setup
	// --------------

	// Establish the root object, `window` in the browser, or `exports` on the server.
	var root = this;

	// Save the previous value of the `_` variable.
	var previousUnderscore = root._;

	// Establish the object that gets returned to break out of a loop iteration.
	var breaker = {};

	// Save bytes in the minified (but not gzipped) version:
	var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	// Create quick reference variables for speed access to core prototypes.
	var
		push             = ArrayProto.push,
		slice            = ArrayProto.slice,
		concat           = ArrayProto.concat,
		toString         = ObjProto.toString,
		hasOwnProperty   = ObjProto.hasOwnProperty;

	// All **ECMAScript 5** native function implementations that we hope to use
	// are declared here.
	var
		nativeForEach      = ArrayProto.forEach,
		nativeMap          = ArrayProto.map,
		nativeReduce       = ArrayProto.reduce,
		nativeReduceRight  = ArrayProto.reduceRight,
		nativeFilter       = ArrayProto.filter,
		nativeEvery        = ArrayProto.every,
		nativeSome         = ArrayProto.some,
		nativeIndexOf      = ArrayProto.indexOf,
		nativeLastIndexOf  = ArrayProto.lastIndexOf,
		nativeIsArray      = Array.isArray,
		nativeKeys         = Object.keys,
		nativeBind         = FuncProto.bind;

	// Create a safe reference to the Underscore object for use below.
	var _ = function(obj) {
		if (obj instanceof _) return obj;
		if (!(this instanceof _)) return new _(obj);
		this._wrapped = obj;
	};

	// Export the Underscore object for **Node.js**, with
	// backwards-compatibility for the old `require()` API. If we're in
	// the browser, add `_` as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if (typeof exports !== 'undefined') {
		if (typeof module !== 'undefined' && module.exports) {
			exports = module.exports = _;
		}
		exports._ = _;
	} else {
		root._ = _;
	}

	// Current version.
	_.VERSION = '1.5.2';

	// Collection Functions
	// --------------------

	// The cornerstone, an `each` implementation, aka `forEach`.
	// Handles objects with the built-in `forEach`, arrays, and raw objects.
	// Delegates to **ECMAScript 5**'s native `forEach` if available.
	var each = _.each = _.forEach = function(obj, iterator, context) {
		if (obj == null) return;
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			for (var i = 0, length = obj.length; i < length; i++) {
				if (iterator.call(context, obj[i], i, obj) === breaker) return;
			}
		} else {
			var keys = _.keys(obj);
			for (var i = 0, length = keys.length; i < length; i++) {
				if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
			}
		}
	};

	// Return the results of applying the iterator to each element.
	// Delegates to **ECMAScript 5**'s native `map` if available.
	_.map = _.collect = function(obj, iterator, context) {
		var results = [];
		if (obj == null) return results;
		if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
		each(obj, function(value, index, list) {
			results.push(iterator.call(context, value, index, list));
		});
		return results;
	};

	var reduceError = 'Reduce of empty array with no initial value';

	// **Reduce** builds up a single result from a list of values, aka `inject`,
	// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
	_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
		var initial = arguments.length > 2;
		if (obj == null) obj = [];
		if (nativeReduce && obj.reduce === nativeReduce) {
			if (context) iterator = _.bind(iterator, context);
			return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
		}
		each(obj, function(value, index, list) {
			if (!initial) {
				memo = value;
				initial = true;
			} else {
				memo = iterator.call(context, memo, value, index, list);
			}
		});
		if (!initial) throw new TypeError(reduceError);
		return memo;
	};

	// The right-associative version of reduce, also known as `foldr`.
	// Delegates to **ECMAScript 5**'s native `reduceRight` if available.
	_.reduceRight = _.foldr = function(obj, iterator, memo, context) {
		var initial = arguments.length > 2;
		if (obj == null) obj = [];
		if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
			if (context) iterator = _.bind(iterator, context);
			return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
		}
		var length = obj.length;
		if (length !== +length) {
			var keys = _.keys(obj);
			length = keys.length;
		}
		each(obj, function(value, index, list) {
			index = keys ? keys[--length] : --length;
			if (!initial) {
				memo = obj[index];
				initial = true;
			} else {
				memo = iterator.call(context, memo, obj[index], index, list);
			}
		});
		if (!initial) throw new TypeError(reduceError);
		return memo;
	};

	// Return the first value which passes a truth test. Aliased as `detect`.
	_.find = _.detect = function(obj, iterator, context) {
		var result;
		any(obj, function(value, index, list) {
			if (iterator.call(context, value, index, list)) {
				result = value;
				return true;
			}
		});
		return result;
	};

	// Return all the elements that pass a truth test.
	// Delegates to **ECMAScript 5**'s native `filter` if available.
	// Aliased as `select`.
	_.filter = _.select = function(obj, iterator, context) {
		var results = [];
		if (obj == null) return results;
		if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
		each(obj, function(value, index, list) {
			if (iterator.call(context, value, index, list)) results.push(value);
		});
		return results;
	};

	// Return all the elements for which a truth test fails.
	_.reject = function(obj, iterator, context) {
		return _.filter(obj, function(value, index, list) {
			return !iterator.call(context, value, index, list);
		}, context);
	};

	// Determine whether all of the elements match a truth test.
	// Delegates to **ECMAScript 5**'s native `every` if available.
	// Aliased as `all`.
	_.every = _.all = function(obj, iterator, context) {
		iterator || (iterator = _.identity);
		var result = true;
		if (obj == null) return result;
		if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
		each(obj, function(value, index, list) {
			if (!(result = result && iterator.call(context, value, index, list))) return breaker;
		});
		return !!result;
	};

	// Determine if at least one element in the object matches a truth test.
	// Delegates to **ECMAScript 5**'s native `some` if available.
	// Aliased as `any`.
	var any = _.some = _.any = function(obj, iterator, context) {
		iterator || (iterator = _.identity);
		var result = false;
		if (obj == null) return result;
		if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
		each(obj, function(value, index, list) {
			if (result || (result = iterator.call(context, value, index, list))) return breaker;
		});
		return !!result;
	};

	// Determine if the array or object contains a given value (using `===`).
	// Aliased as `include`.
	_.contains = _.include = function(obj, target) {
		if (obj == null) return false;
		if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
		return any(obj, function(value) {
			return value === target;
		});
	};

	// Invoke a method (with arguments) on every item in a collection.
	_.invoke = function(obj, method) {
		var args = slice.call(arguments, 2);
		var isFunc = _.isFunction(method);
		return _.map(obj, function(value) {
			return (isFunc ? method : value[method]).apply(value, args);
		});
	};

	// Convenience version of a common use case of `map`: fetching a property.
	_.pluck = function(obj, key) {
		return _.map(obj, function(value){ return value[key]; });
	};

	// Convenience version of a common use case of `filter`: selecting only objects
	// containing specific `key:value` pairs.
	_.where = function(obj, attrs, first) {
		if (_.isEmpty(attrs)) return first ? void 0 : [];
		return _[first ? 'find' : 'filter'](obj, function(value) {
			for (var key in attrs) {
				if (attrs[key] !== value[key]) return false;
			}
			return true;
		});
	};

	// Convenience version of a common use case of `find`: getting the first object
	// containing specific `key:value` pairs.
	_.findWhere = function(obj, attrs) {
		return _.where(obj, attrs, true);
	};

	// Return the maximum element or (element-based computation).
	// Can't optimize arrays of integers longer than 65,535 elements.
	// See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
	_.max = function(obj, iterator, context) {
		if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
			return Math.max.apply(Math, obj);
		}
		if (!iterator && _.isEmpty(obj)) return -Infinity;
		var result = {computed : -Infinity, value: -Infinity};
		each(obj, function(value, index, list) {
			var computed = iterator ? iterator.call(context, value, index, list) : value;
			computed > result.computed && (result = {value : value, computed : computed});
		});
		return result.value;
	};

	// Return the minimum element (or element-based computation).
	_.min = function(obj, iterator, context) {
		if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
			return Math.min.apply(Math, obj);
		}
		if (!iterator && _.isEmpty(obj)) return Infinity;
		var result = {computed : Infinity, value: Infinity};
		each(obj, function(value, index, list) {
			var computed = iterator ? iterator.call(context, value, index, list) : value;
			computed < result.computed && (result = {value : value, computed : computed});
		});
		return result.value;
	};

	// Shuffle an array, using the modern version of the 
	// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).
	_.shuffle = function(obj) {
		var rand;
		var index = 0;
		var shuffled = [];
		each(obj, function(value) {
			rand = _.random(index++);
			shuffled[index - 1] = shuffled[rand];
			shuffled[rand] = value;
		});
		return shuffled;
	};

	// Sample **n** random values from an array.
	// If **n** is not specified, returns a single random element from the array.
	// The internal `guard` argument allows it to work with `map`.
	_.sample = function(obj, n, guard) {
		if (arguments.length < 2 || guard) {
			return obj[_.random(obj.length - 1)];
		}
		return _.shuffle(obj).slice(0, Math.max(0, n));
	};

	// An internal function to generate lookup iterators.
	var lookupIterator = function(value) {
		return _.isFunction(value) ? value : function(obj){ return obj[value]; };
	};

	// Sort the object's values by a criterion produced by an iterator.
	_.sortBy = function(obj, value, context) {
		var iterator = lookupIterator(value);
		return _.pluck(_.map(obj, function(value, index, list) {
			return {
				value: value,
				index: index,
				criteria: iterator.call(context, value, index, list)
			};
		}).sort(function(left, right) {
			var a = left.criteria;
			var b = right.criteria;
			if (a !== b) {
				if (a > b || a === void 0) return 1;
				if (a < b || b === void 0) return -1;
			}
			return left.index - right.index;
		}), 'value');
	};

	// An internal function used for aggregate "group by" operations.
	var group = function(behavior) {
		return function(obj, value, context) {
			var result = {};
			var iterator = value == null ? _.identity : lookupIterator(value);
			each(obj, function(value, index) {
				var key = iterator.call(context, value, index, obj);
				behavior(result, key, value);
			});
			return result;
		};
	};

	// Groups the object's values by a criterion. Pass either a string attribute
	// to group by, or a function that returns the criterion.
	_.groupBy = group(function(result, key, value) {
		(_.has(result, key) ? result[key] : (result[key] = [])).push(value);
	});

	// Indexes the object's values by a criterion, similar to `groupBy`, but for
	// when you know that your index values will be unique.
	_.indexBy = group(function(result, key, value) {
		result[key] = value;
	});

	// Counts instances of an object that group by a certain criterion. Pass
	// either a string attribute to count by, or a function that returns the
	// criterion.
	_.countBy = group(function(result, key) {
		_.has(result, key) ? result[key]++ : result[key] = 1;
	});

	// Use a comparator function to figure out the smallest index at which
	// an object should be inserted so as to maintain order. Uses binary search.
	_.sortedIndex = function(array, obj, iterator, context) {
		iterator = iterator == null ? _.identity : lookupIterator(iterator);
		var value = iterator.call(context, obj);
		var low = 0, high = array.length;
		while (low < high) {
			var mid = (low + high) >>> 1;
			iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
		}
		return low;
	};

	// Safely create a real, live array from anything iterable.
	_.toArray = function(obj) {
		if (!obj) return [];
		if (_.isArray(obj)) return slice.call(obj);
		if (obj.length === +obj.length) return _.map(obj, _.identity);
		return _.values(obj);
	};

	// Return the number of elements in an object.
	_.size = function(obj) {
		if (obj == null) return 0;
		return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
	};

	// Array Functions
	// ---------------

	// Get the first element of an array. Passing **n** will return the first N
	// values in the array. Aliased as `head` and `take`. The **guard** check
	// allows it to work with `_.map`.
	_.first = _.head = _.take = function(array, n, guard) {
		if (array == null) return void 0;
		return (n == null) || guard ? array[0] : slice.call(array, 0, n);
	};

	// Returns everything but the last entry of the array. Especially useful on
	// the arguments object. Passing **n** will return all the values in
	// the array, excluding the last N. The **guard** check allows it to work with
	// `_.map`.
	_.initial = function(array, n, guard) {
		return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
	};

	// Get the last element of an array. Passing **n** will return the last N
	// values in the array. The **guard** check allows it to work with `_.map`.
	_.last = function(array, n, guard) {
		if (array == null) return void 0;
		if ((n == null) || guard) {
			return array[array.length - 1];
		} else {
			return slice.call(array, Math.max(array.length - n, 0));
		}
	};

	// Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	// Especially useful on the arguments object. Passing an **n** will return
	// the rest N values in the array. The **guard**
	// check allows it to work with `_.map`.
	_.rest = _.tail = _.drop = function(array, n, guard) {
		return slice.call(array, (n == null) || guard ? 1 : n);
	};

	// Trim out all falsy values from an array.
	_.compact = function(array) {
		return _.filter(array, _.identity);
	};

	// Internal implementation of a recursive `flatten` function.
	var flatten = function(input, shallow, output) {
		if (shallow && _.every(input, _.isArray)) {
			return concat.apply(output, input);
		}
		each(input, function(value) {
			if (_.isArray(value) || _.isArguments(value)) {
				shallow ? push.apply(output, value) : flatten(value, shallow, output);
			} else {
				output.push(value);
			}
		});
		return output;
	};

	// Flatten out an array, either recursively (by default), or just one level.
	_.flatten = function(array, shallow) {
		return flatten(array, shallow, []);
	};

	// Return a version of the array that does not contain the specified value(s).
	_.without = function(array) {
		return _.difference(array, slice.call(arguments, 1));
	};

	// Produce a duplicate-free version of the array. If the array has already
	// been sorted, you have the option of using a faster algorithm.
	// Aliased as `unique`.
	_.uniq = _.unique = function(array, isSorted, iterator, context) {
		if (_.isFunction(isSorted)) {
			context = iterator;
			iterator = isSorted;
			isSorted = false;
		}
		var initial = iterator ? _.map(array, iterator, context) : array;
		var results = [];
		var seen = [];
		each(initial, function(value, index) {
			if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
				seen.push(value);
				results.push(array[index]);
			}
		});
		return results;
	};

	// Produce an array that contains the union: each distinct element from all of
	// the passed-in arrays.
	_.union = function() {
		return _.uniq(_.flatten(arguments, true));
	};

	// Produce an array that contains every item shared between all the
	// passed-in arrays.
	_.intersection = function(array) {
		var rest = slice.call(arguments, 1);
		return _.filter(_.uniq(array), function(item) {
			return _.every(rest, function(other) {
				return _.indexOf(other, item) >= 0;
			});
		});
	};

	// Take the difference between one array and a number of other arrays.
	// Only the elements present in just the first array will remain.
	_.difference = function(array) {
		var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
		return _.filter(array, function(value){ return !_.contains(rest, value); });
	};

	// Zip together multiple lists into a single array -- elements that share
	// an index go together.
	_.zip = function() {
		var length = _.max(_.pluck(arguments, "length").concat(0));
		var results = new Array(length);
		for (var i = 0; i < length; i++) {
			results[i] = _.pluck(arguments, '' + i);
		}
		return results;
	};

	// Converts lists into objects. Pass either a single array of `[key, value]`
	// pairs, or two parallel arrays of the same length -- one of keys, and one of
	// the corresponding values.
	_.object = function(list, values) {
		if (list == null) return {};
		var result = {};
		for (var i = 0, length = list.length; i < length; i++) {
			if (values) {
				result[list[i]] = values[i];
			} else {
				result[list[i][0]] = list[i][1];
			}
		}
		return result;
	};

	// If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
	// we need this function. Return the position of the first occurrence of an
	// item in an array, or -1 if the item is not included in the array.
	// Delegates to **ECMAScript 5**'s native `indexOf` if available.
	// If the array is large and already in sort order, pass `true`
	// for **isSorted** to use binary search.
	_.indexOf = function(array, item, isSorted) {
		if (array == null) return -1;
		var i = 0, length = array.length;
		if (isSorted) {
			if (typeof isSorted == 'number') {
				i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
			} else {
				i = _.sortedIndex(array, item);
				return array[i] === item ? i : -1;
			}
		}
		if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
		for (; i < length; i++) if (array[i] === item) return i;
		return -1;
	};

	// Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
	_.lastIndexOf = function(array, item, from) {
		if (array == null) return -1;
		var hasIndex = from != null;
		if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
			return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
		}
		var i = (hasIndex ? from : array.length);
		while (i--) if (array[i] === item) return i;
		return -1;
	};

	// Generate an integer Array containing an arithmetic progression. A port of
	// the native Python `range()` function. See
	// [the Python documentation](http://docs.python.org/library/functions.html#range).
	_.range = function(start, stop, step) {
		if (arguments.length <= 1) {
			stop = start || 0;
			start = 0;
		}
		step = arguments[2] || 1;

		var length = Math.max(Math.ceil((stop - start) / step), 0);
		var idx = 0;
		var range = new Array(length);

		while(idx < length) {
			range[idx++] = start;
			start += step;
		}

		return range;
	};

	// Function (ahem) Functions
	// ------------------

	// Reusable constructor function for prototype setting.
	var ctor = function(){};

	// Create a function bound to a given object (assigning `this`, and arguments,
	// optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	// available.
	_.bind = function(func, context) {
		var args, bound;
		if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
		if (!_.isFunction(func)) throw new TypeError;
		args = slice.call(arguments, 2);
		return bound = function() {
			if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
			ctor.prototype = func.prototype;
			var self = new ctor;
			ctor.prototype = null;
			var result = func.apply(self, args.concat(slice.call(arguments)));
			if (Object(result) === result) return result;
			return self;
		};
	};

	// Partially apply a function by creating a version that has had some of its
	// arguments pre-filled, without changing its dynamic `this` context.
	_.partial = function(func) {
		var args = slice.call(arguments, 1);
		return function() {
			return func.apply(this, args.concat(slice.call(arguments)));
		};
	};

	// Bind all of an object's methods to that object. Useful for ensuring that
	// all callbacks defined on an object belong to it.
	_.bindAll = function(obj) {
		var funcs = slice.call(arguments, 1);
		if (funcs.length === 0) throw new Error("bindAll must be passed function names");
		each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
		return obj;
	};

	// Memoize an expensive function by storing its results.
	_.memoize = function(func, hasher) {
		var memo = {};
		hasher || (hasher = _.identity);
		return function() {
			var key = hasher.apply(this, arguments);
			return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
		};
	};

	// Delays a function for the given number of milliseconds, and then calls
	// it with the arguments supplied.
	_.delay = function(func, wait) {
		var args = slice.call(arguments, 2);
		return setTimeout(function(){ return func.apply(null, args); }, wait);
	};

	// Defers a function, scheduling it to run after the current call stack has
	// cleared.
	_.defer = function(func) {
		return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
	};

	// Returns a function, that, when invoked, will only be triggered at most once
	// during a given window of time. Normally, the throttled function will run
	// as much as it can, without ever going more than once per `wait` duration;
	// but if you'd like to disable the execution on the leading edge, pass
	// `{leading: false}`. To disable execution on the trailing edge, ditto.
	_.throttle = function(func, wait, options) {
		var context, args, result;
		var timeout = null;
		var previous = 0;
		options || (options = {});
		var later = function() {
			previous = options.leading === false ? 0 : new Date;
			timeout = null;
			result = func.apply(context, args);
		};
		return function() {
			var now = new Date;
			if (!previous && options.leading === false) previous = now;
			var remaining = wait - (now - previous);
			context = this;
			args = arguments;
			if (remaining <= 0) {
				clearTimeout(timeout);
				timeout = null;
				previous = now;
				result = func.apply(context, args);
			} else if (!timeout && options.trailing !== false) {
				timeout = setTimeout(later, remaining);
			}
			return result;
		};
	};

	// Returns a function, that, as long as it continues to be invoked, will not
	// be triggered. The function will be called after it stops being called for
	// N milliseconds. If `immediate` is passed, trigger the function on the
	// leading edge, instead of the trailing.
	_.debounce = function(func, wait, immediate) {
		var timeout, args, context, timestamp, result;
		return function() {
			context = this;
			args = arguments;
			timestamp = new Date();
			var later = function() {
				var last = (new Date()) - timestamp;
				if (last < wait) {
					timeout = setTimeout(later, wait - last);
				} else {
					timeout = null;
					if (!immediate) result = func.apply(context, args);
				}
			};
			var callNow = immediate && !timeout;
			if (!timeout) {
				timeout = setTimeout(later, wait);
			}
			if (callNow) result = func.apply(context, args);
			return result;
		};
	};

	// Returns a function that will be executed at most one time, no matter how
	// often you call it. Useful for lazy initialization.
	_.once = function(func) {
		var ran = false, memo;
		return function() {
			if (ran) return memo;
			ran = true;
			memo = func.apply(this, arguments);
			func = null;
			return memo;
		};
	};

	// Returns the first function passed as an argument to the second,
	// allowing you to adjust arguments, run code before and after, and
	// conditionally execute the original function.
	_.wrap = function(func, wrapper) {
		return function() {
			var args = [func];
			push.apply(args, arguments);
			return wrapper.apply(this, args);
		};
	};

	// Returns a function that is the composition of a list of functions, each
	// consuming the return value of the function that follows.
	_.compose = function() {
		var funcs = arguments;
		return function() {
			var args = arguments;
			for (var i = funcs.length - 1; i >= 0; i--) {
				args = [funcs[i].apply(this, args)];
			}
			return args[0];
		};
	};

	// Returns a function that will only be executed after being called N times.
	_.after = function(times, func) {
		return function() {
			if (--times < 1) {
				return func.apply(this, arguments);
			}
		};
	};

	// Object Functions
	// ----------------

	// Retrieve the names of an object's properties.
	// Delegates to **ECMAScript 5**'s native `Object.keys`
	_.keys = nativeKeys || function(obj) {
		if (obj !== Object(obj)) throw new TypeError('Invalid object');
		var keys = [];
		for (var key in obj) if (_.has(obj, key)) keys.push(key);
		return keys;
	};

	// Retrieve the values of an object's properties.
	_.values = function(obj) {
		var keys = _.keys(obj);
		var length = keys.length;
		var values = new Array(length);
		for (var i = 0; i < length; i++) {
			values[i] = obj[keys[i]];
		}
		return values;
	};

	// Convert an object into a list of `[key, value]` pairs.
	_.pairs = function(obj) {
		var keys = _.keys(obj);
		var length = keys.length;
		var pairs = new Array(length);
		for (var i = 0; i < length; i++) {
			pairs[i] = [keys[i], obj[keys[i]]];
		}
		return pairs;
	};

	// Invert the keys and values of an object. The values must be serializable.
	_.invert = function(obj) {
		var result = {};
		var keys = _.keys(obj);
		for (var i = 0, length = keys.length; i < length; i++) {
			result[obj[keys[i]]] = keys[i];
		}
		return result;
	};

	// Return a sorted list of the function names available on the object.
	// Aliased as `methods`
	_.functions = _.methods = function(obj) {
		var names = [];
		for (var key in obj) {
			if (_.isFunction(obj[key])) names.push(key);
		}
		return names.sort();
	};

	// Extend a given object with all the properties in passed-in object(s).
	_.extend = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for (var prop in source) {
					obj[prop] = source[prop];
				}
			}
		});
		return obj;
	};

	// Return a copy of the object only containing the whitelisted properties.
	_.pick = function(obj) {
		var copy = {};
		var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
		each(keys, function(key) {
			if (key in obj) copy[key] = obj[key];
		});
		return copy;
	};

	 // Return a copy of the object without the blacklisted properties.
	_.omit = function(obj) {
		var copy = {};
		var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
		for (var key in obj) {
			if (!_.contains(keys, key)) copy[key] = obj[key];
		}
		return copy;
	};

	// Fill in a given object with default properties.
	_.defaults = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for (var prop in source) {
					if (obj[prop] === void 0) obj[prop] = source[prop];
				}
			}
		});
		return obj;
	};

	// Create a (shallow-cloned) duplicate of an object.
	_.clone = function(obj) {
		if (!_.isObject(obj)) return obj;
		return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	};

	// Invokes interceptor with the obj, and then returns obj.
	// The primary purpose of this method is to "tap into" a method chain, in
	// order to perform operations on intermediate results within the chain.
	_.tap = function(obj, interceptor) {
		interceptor(obj);
		return obj;
	};

	// Internal recursive comparison function for `isEqual`.
	var eq = function(a, b, aStack, bStack) {
		// Identical objects are equal. `0 === -0`, but they aren't identical.
		// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
		if (a === b) return a !== 0 || 1 / a == 1 / b;
		// A strict comparison is necessary because `null == undefined`.
		if (a == null || b == null) return a === b;
		// Unwrap any wrapped objects.
		if (a instanceof _) a = a._wrapped;
		if (b instanceof _) b = b._wrapped;
		// Compare `[[Class]]` names.
		var className = toString.call(a);
		if (className != toString.call(b)) return false;
		switch (className) {
			// Strings, numbers, dates, and booleans are compared by value.
			case '[object String]':
				// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
				// equivalent to `new String("5")`.
				return a == String(b);
			case '[object Number]':
				// `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
				// other numeric values.
				return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
			case '[object Date]':
			case '[object Boolean]':
				// Coerce dates and booleans to numeric primitive values. Dates are compared by their
				// millisecond representations. Note that invalid dates with millisecond representations
				// of `NaN` are not equivalent.
				return +a == +b;
			// RegExps are compared by their source patterns and flags.
			case '[object RegExp]':
				return a.source == b.source &&
							 a.global == b.global &&
							 a.multiline == b.multiline &&
							 a.ignoreCase == b.ignoreCase;
		}
		if (typeof a != 'object' || typeof b != 'object') return false;
		// Assume equality for cyclic structures. The algorithm for detecting cyclic
		// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
		var length = aStack.length;
		while (length--) {
			// Linear search. Performance is inversely proportional to the number of
			// unique nested structures.
			if (aStack[length] == a) return bStack[length] == b;
		}
		// Objects with different constructors are not equivalent, but `Object`s
		// from different frames are.
		var aCtor = a.constructor, bCtor = b.constructor;
		if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
														 _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
			return false;
		}
		// Add the first object to the stack of traversed objects.
		aStack.push(a);
		bStack.push(b);
		var size = 0, result = true;
		// Recursively compare objects and arrays.
		if (className == '[object Array]') {
			// Compare array lengths to determine if a deep comparison is necessary.
			size = a.length;
			result = size == b.length;
			if (result) {
				// Deep compare the contents, ignoring non-numeric properties.
				while (size--) {
					if (!(result = eq(a[size], b[size], aStack, bStack))) break;
				}
			}
		} else {
			// Deep compare objects.
			for (var key in a) {
				if (_.has(a, key)) {
					// Count the expected number of properties.
					size++;
					// Deep compare each member.
					if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
				}
			}
			// Ensure that both objects contain the same number of properties.
			if (result) {
				for (key in b) {
					if (_.has(b, key) && !(size--)) break;
				}
				result = !size;
			}
		}
		// Remove the first object from the stack of traversed objects.
		aStack.pop();
		bStack.pop();
		return result;
	};

	// Perform a deep comparison to check if two objects are equal.
	_.isEqual = function(a, b) {
		return eq(a, b, [], []);
	};

	// Is a given array, string, or object empty?
	// An "empty" object has no enumerable own-properties.
	_.isEmpty = function(obj) {
		if (obj == null) return true;
		if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
		for (var key in obj) if (_.has(obj, key)) return false;
		return true;
	};

	// Is a given value a DOM element?
	_.isElement = function(obj) {
		return !!(obj && obj.nodeType === 1);
	};

	// Is a given value an array?
	// Delegates to ECMA5's native Array.isArray
	_.isArray = nativeIsArray || function(obj) {
		return toString.call(obj) == '[object Array]';
	};

	// Is a given variable an object?
	_.isObject = function(obj) {
		return obj === Object(obj);
	};

	// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
	each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
		_['is' + name] = function(obj) {
			return toString.call(obj) == '[object ' + name + ']';
		};
	});

	// Define a fallback version of the method in browsers (ahem, IE), where
	// there isn't any inspectable "Arguments" type.
	if (!_.isArguments(arguments)) {
		_.isArguments = function(obj) {
			return !!(obj && _.has(obj, 'callee'));
		};
	}

	// Optimize `isFunction` if appropriate.
	if (typeof (/./) !== 'function') {
		_.isFunction = function(obj) {
			return typeof obj === 'function';
		};
	}

	// Is a given object a finite number?
	_.isFinite = function(obj) {
		return isFinite(obj) && !isNaN(parseFloat(obj));
	};

	// Is the given value `NaN`? (NaN is the only number which does not equal itself).
	_.isNaN = function(obj) {
		return _.isNumber(obj) && obj != +obj;
	};

	// Is a given value a boolean?
	_.isBoolean = function(obj) {
		return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
	};

	// Is a given value equal to null?
	_.isNull = function(obj) {
		return obj === null;
	};

	// Is a given variable undefined?
	_.isUndefined = function(obj) {
		return obj === void 0;
	};

	// Shortcut function for checking if an object has a given property directly
	// on itself (in other words, not on a prototype).
	_.has = function(obj, key) {
		return hasOwnProperty.call(obj, key);
	};

	// Utility Functions
	// -----------------

	// Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	// previous owner. Returns a reference to the Underscore object.
	_.noConflict = function() {
		root._ = previousUnderscore;
		return this;
	};

	// Keep the identity function around for default iterators.
	_.identity = function(value) {
		return value;
	};

	// Run a function **n** times.
	_.times = function(n, iterator, context) {
		var accum = Array(Math.max(0, n));
		for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
		return accum;
	};

	// Return a random integer between min and max (inclusive).
	_.random = function(min, max) {
		if (max == null) {
			max = min;
			min = 0;
		}
		return min + Math.floor(Math.random() * (max - min + 1));
	};

	// List of HTML entities for escaping.
	var entityMap = {
		escape: {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#x27;'
		}
	};
	entityMap.unescape = _.invert(entityMap.escape);

	// Regexes containing the keys and values listed immediately above.
	var entityRegexes = {
		escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
		unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
	};

	// Functions for escaping and unescaping strings to/from HTML interpolation.
	_.each(['escape', 'unescape'], function(method) {
		_[method] = function(string) {
			if (string == null) return '';
			return ('' + string).replace(entityRegexes[method], function(match) {
				return entityMap[method][match];
			});
		};
	});

	// If the value of the named `property` is a function then invoke it with the
	// `object` as context; otherwise, return it.
	_.result = function(object, property) {
		if (object == null) return void 0;
		var value = object[property];
		return _.isFunction(value) ? value.call(object) : value;
	};

	// Add your own custom functions to the Underscore object.
	_.mixin = function(obj) {
		each(_.functions(obj), function(name) {
			var func = _[name] = obj[name];
			_.prototype[name] = function() {
				var args = [this._wrapped];
				push.apply(args, arguments);
				return result.call(this, func.apply(_, args));
			};
		});
	};

	// Generate a unique integer id (unique within the entire client session).
	// Useful for temporary DOM ids.
	var idCounter = 0;
	_.uniqueId = function(prefix) {
		var id = ++idCounter + '';
		return prefix ? prefix + id : id;
	};

	// By default, Underscore uses ERB-style template delimiters, change the
	// following template settings to use alternative delimiters.
	_.templateSettings = {
		evaluate    : /<%([\s\S]+?)%>/g,
		interpolate : /<%=([\s\S]+?)%>/g,
		escape      : /<%-([\s\S]+?)%>/g
	};

	// When customizing `templateSettings`, if you don't want to define an
	// interpolation, evaluation or escaping regex, we need one that is
	// guaranteed not to match.
	var noMatch = /(.)^/;

	// Certain characters need to be escaped so that they can be put into a
	// string literal.
	var escapes = {
		"'":      "'",
		'\\':     '\\',
		'\r':     'r',
		'\n':     'n',
		'\t':     't',
		'\u2028': 'u2028',
		'\u2029': 'u2029'
	};

	var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

	// JavaScript micro-templating, similar to John Resig's implementation.
	// Underscore templating handles arbitrary delimiters, preserves whitespace,
	// and correctly escapes quotes within interpolated code.
	_.template = function(text, data, settings) {
		var render;
		settings = _.defaults({}, settings, _.templateSettings);

		// Combine delimiters into one regular expression via alternation.
		var matcher = new RegExp([
			(settings.escape || noMatch).source,
			(settings.interpolate || noMatch).source,
			(settings.evaluate || noMatch).source
		].join('|') + '|$', 'g');

		// Compile the template source, escaping string literals appropriately.
		var index = 0;
		var source = "__p+='";
		text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
			source += text.slice(index, offset)
				.replace(escaper, function(match) { return '\\' + escapes[match]; });

			if (escape) {
				source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
			}
			if (interpolate) {
				source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
			}
			if (evaluate) {
				source += "';\n" + evaluate + "\n__p+='";
			}
			index = offset + match.length;
			return match;
		});
		source += "';\n";

		// If a variable is not specified, place data values in local scope.
		if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

		source = "var __t,__p='',__j=Array.prototype.join," +
			"print=function(){__p+=__j.call(arguments,'');};\n" +
			source + "return __p;\n";

		try {
			render = new Function(settings.variable || 'obj', '_', source);
		} catch (e) {
			e.source = source;
			throw e;
		}

		if (data) return render(data, _);
		var template = function(data) {
			return render.call(this, data, _);
		};

		// Provide the compiled function source as a convenience for precompilation.
		template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

		return template;
	};

	// Add a "chain" function, which will delegate to the wrapper.
	_.chain = function(obj) {
		return _(obj).chain();
	};

	// OOP
	// ---------------
	// If Underscore is called as a function, it returns a wrapped object that
	// can be used OO-style. This wrapper holds altered versions of all the
	// underscore functions. Wrapped objects may be chained.

	// Helper function to continue chaining intermediate results.
	var result = function(obj) {
		return this._chain ? _(obj).chain() : obj;
	};

	// Add all of the Underscore functions to the wrapper object.
	_.mixin(_);

	// Add all mutator Array functions to the wrapper.
	each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
		var method = ArrayProto[name];
		_.prototype[name] = function() {
			var obj = this._wrapped;
			method.apply(obj, arguments);
			if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
			return result.call(this, obj);
		};
	});

	// Add all accessor Array functions to the wrapper.
	each(['concat', 'join', 'slice'], function(name) {
		var method = ArrayProto[name];
		_.prototype[name] = function() {
			return result.call(this, method.apply(this._wrapped, arguments));
		};
	});

	_.extend(_.prototype, {

		// Start chaining a wrapped Underscore object.
		chain: function() {
			this._chain = true;
			return this;
		},

		// Extracts the result from a wrapped and chained object.
		value: function() {
			return this._wrapped;
		}

	});

}).call(this);
; /* ************************ new file ************************ */
//     Backbone.js 1.1.0

//     (c) 2010-2011 Jeremy Ashkenas, DocumentCloud Inc.
//     (c) 2011-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

	// Initial Setup
	// -------------

	// Save a reference to the global object (`window` in the browser, `exports`
	// on the server).
	var root = this;

	// Save the previous value of the `Backbone` variable, so that it can be
	// restored later on, if `noConflict` is used.
	var previousBackbone = root.Backbone;

	// Create local references to array methods we'll want to use later.
	var array = [];
	var push = array.push;
	var slice = array.slice;
	var splice = array.splice;

	// The top-level namespace. All public Backbone classes and modules will
	// be attached to this. Exported for both the browser and the server.
	var Backbone;
	if (typeof exports !== 'undefined') {
		Backbone = exports;
	} else {
		Backbone = root.Backbone = {};
	}

	// Current version of the library. Keep in sync with `package.json`.
	Backbone.VERSION = '1.1.0';

	// Require Underscore, if we're on the server, and it's not already present.
	var _ = root._;
	if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

	// For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
	// the `$` variable.
	Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

	// Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
	// to its previous owner. Returns a reference to this Backbone object.
	Backbone.noConflict = function() {
		root.Backbone = previousBackbone;
		return this;
	};

	// Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
	// will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
	// set a `X-Http-Method-Override` header.
	Backbone.emulateHTTP = false;

	// Turn on `emulateJSON` to support legacy servers that can't deal with direct
	// `application/json` requests ... will encode the body as
	// `application/x-www-form-urlencoded` instead and will send the model in a
	// form param named `model`.
	Backbone.emulateJSON = false;

	// Backbone.Events
	// ---------------

	// A module that can be mixed in to *any object* in order to provide it with
	// custom events. You may bind with `on` or remove with `off` callback
	// functions to an event; `trigger`-ing an event fires all callbacks in
	// succession.
	//
	//     var object = {};
	//     _.extend(object, Backbone.Events);
	//     object.on('expand', function(){ alert('expanded'); });
	//     object.trigger('expand');
	//
	var Events = Backbone.Events = {

		// Bind an event to a `callback` function. Passing `"all"` will bind
		// the callback to all events fired.
		on: function(name, callback, context) {
			if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
			this._events || (this._events = {});
			var events = this._events[name] || (this._events[name] = []);
			events.push({callback: callback, context: context, ctx: context || this});
			return this;
		},

		// Bind an event to only be triggered a single time. After the first time
		// the callback is invoked, it will be removed.
		once: function(name, callback, context) {
			if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
			var self = this;
			var once = _.once(function() {
				self.off(name, once);
				callback.apply(this, arguments);
			});
			once._callback = callback;
			return this.on(name, once, context);
		},

		// Remove one or many callbacks. If `context` is null, removes all
		// callbacks with that function. If `callback` is null, removes all
		// callbacks for the event. If `name` is null, removes all bound
		// callbacks for all events.
		off: function(name, callback, context) {
			var retain, ev, events, names, i, l, j, k;
			if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
			if (!name && !callback && !context) {
				this._events = {};
				return this;
			}
			names = name ? [name] : _.keys(this._events);
			for (i = 0, l = names.length; i < l; i++) {
				name = names[i];
				if (events = this._events[name]) {
					this._events[name] = retain = [];
					if (callback || context) {
						for (j = 0, k = events.length; j < k; j++) {
							ev = events[j];
							if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
									(context && context !== ev.context)) {
								retain.push(ev);
							}
						}
					}
					if (!retain.length) delete this._events[name];
				}
			}

			return this;
		},

		// Trigger one or many events, firing all bound callbacks. Callbacks are
		// passed the same arguments as `trigger` is, apart from the event name
		// (unless you're listening on `"all"`, which will cause your callback to
		// receive the true name of the event as the first argument).
		trigger: function(name) {
			if (!this._events) return this;
			var args = slice.call(arguments, 1);
			if (!eventsApi(this, 'trigger', name, args)) return this;
			var events = this._events[name];
			var allEvents = this._events.all;
			if (events) triggerEvents(events, args);
			if (allEvents) triggerEvents(allEvents, arguments);
			return this;
		},

		// Tell this object to stop listening to either specific events ... or
		// to every object it's currently listening to.
		stopListening: function(obj, name, callback) {
			var listeningTo = this._listeningTo;
			if (!listeningTo) return this;
			var remove = !name && !callback;
			if (!callback && typeof name === 'object') callback = this;
			if (obj) (listeningTo = {})[obj._listenId] = obj;
			for (var id in listeningTo) {
				obj = listeningTo[id];
				obj.off(name, callback, this);
				if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
			}
			return this;
		}

	};

	// Regular expression used to split event strings.
	var eventSplitter = /\s+/;

	// Implement fancy features of the Events API such as multiple event
	// names `"change blur"` and jQuery-style event maps `{change: action}`
	// in terms of the existing API.
	var eventsApi = function(obj, action, name, rest) {
		if (!name) return true;

		// Handle event maps.
		if (typeof name === 'object') {
			for (var key in name) {
				obj[action].apply(obj, [key, name[key]].concat(rest));
			}
			return false;
		}

		// Handle space separated event names.
		if (eventSplitter.test(name)) {
			var names = name.split(eventSplitter);
			for (var i = 0, l = names.length; i < l; i++) {
				obj[action].apply(obj, [names[i]].concat(rest));
			}
			return false;
		}

		return true;
	};

	// A difficult-to-believe, but optimized internal dispatch function for
	// triggering events. Tries to keep the usual cases speedy (most internal
	// Backbone events have 3 arguments).
	var triggerEvents = function(events, args) {
		var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
		switch (args.length) {
			case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
			case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
			case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
			case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
			default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
		}
	};

	var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

	// Inversion-of-control versions of `on` and `once`. Tell *this* object to
	// listen to an event in another object ... keeping track of what it's
	// listening to.
	_.each(listenMethods, function(implementation, method) {
		Events[method] = function(obj, name, callback) {
			var listeningTo = this._listeningTo || (this._listeningTo = {});
			var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
			listeningTo[id] = obj;
			if (!callback && typeof name === 'object') callback = this;
			obj[implementation](name, callback, this);
			return this;
		};
	});

	// Aliases for backwards compatibility.
	Events.bind   = Events.on;
	Events.unbind = Events.off;

	// Allow the `Backbone` object to serve as a global event bus, for folks who
	// want global "pubsub" in a convenient place.
	_.extend(Backbone, Events);

	// Backbone.Model
	// --------------

	// Backbone **Models** are the basic data object in the framework --
	// frequently representing a row in a table in a database on your server.
	// A discrete chunk of data and a bunch of useful, related methods for
	// performing computations and transformations on that data.

	// Create a new model with the specified attributes. A client id (`cid`)
	// is automatically generated and assigned for you.
	var Model = Backbone.Model = function(attributes, options) {
		var attrs = attributes || {};
		options || (options = {});
		this.cid = _.uniqueId('c');
		this.attributes = {};
		if (options.collection) this.collection = options.collection;
		if (options.parse) attrs = this.parse(attrs, options) || {};
		attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
		this.set(attrs, options);
		this.changed = {};
		this.initialize.apply(this, arguments);
	};

	// Attach all inheritable methods to the Model prototype.
	_.extend(Model.prototype, Events, {

		// A hash of attributes whose current and previous value differ.
		changed: null,

		// The value returned during the last failed validation.
		validationError: null,

		// The default name for the JSON `id` attribute is `"id"`. MongoDB and
		// CouchDB users may want to set this to `"_id"`.
		idAttribute: 'id',

		// Initialize is an empty function by default. Override it with your own
		// initialization logic.
		initialize: function(){},

		// Return a copy of the model's `attributes` object.
		toJSON: function(options) {
			return _.clone(this.attributes);
		},

		// Proxy `Backbone.sync` by default -- but override this if you need
		// custom syncing semantics for *this* particular model.
		sync: function() {
			return Backbone.sync.apply(this, arguments);
		},

		// Get the value of an attribute.
		get: function(attr) {
			return this.attributes[attr];
		},

		// Get the HTML-escaped value of an attribute.
		escape: function(attr) {
			return _.escape(this.get(attr));
		},

		// Returns `true` if the attribute contains a value that is not null
		// or undefined.
		has: function(attr) {
			return this.get(attr) != null;
		},

		// Set a hash of model attributes on the object, firing `"change"`. This is
		// the core primitive operation of a model, updating the data and notifying
		// anyone who needs to know about the change in state. The heart of the beast.
		set: function(key, val, options) {
			var attr, attrs, unset, changes, silent, changing, prev, current;
			if (key == null) return this;

			// Handle both `"key", value` and `{key: value}` -style arguments.
			if (typeof key === 'object') {
				attrs = key;
				options = val;
			} else {
				(attrs = {})[key] = val;
			}

			options || (options = {});

			// Run validation.
			if (!this._validate(attrs, options)) return false;

			// Extract attributes and options.
			unset           = options.unset;
			silent          = options.silent;
			changes         = [];
			changing        = this._changing;
			this._changing  = true;

			if (!changing) {
				this._previousAttributes = _.clone(this.attributes);
				this.changed = {};
			}
			current = this.attributes, prev = this._previousAttributes;

			// Check for changes of `id`.
			if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

			// For each `set` attribute, update or delete the current value.
			for (attr in attrs) {
				val = attrs[attr];
				if (!_.isEqual(current[attr], val)) changes.push(attr);
				if (!_.isEqual(prev[attr], val)) {
					this.changed[attr] = val;
				} else {
					delete this.changed[attr];
				}
				unset ? delete current[attr] : current[attr] = val;
			}

			// Trigger all relevant attribute changes.
			if (!silent) {
				if (changes.length) this._pending = true;
				for (var i = 0, l = changes.length; i < l; i++) {
					this.trigger('change:' + changes[i], this, current[changes[i]], options);
				}
			}

			// You might be wondering why there's a `while` loop here. Changes can
			// be recursively nested within `"change"` events.
			if (changing) return this;
			if (!silent) {
				while (this._pending) {
					this._pending = false;
					this.trigger('change', this, options);
				}
			}
			this._pending = false;
			this._changing = false;
			return this;
		},

		// Remove an attribute from the model, firing `"change"`. `unset` is a noop
		// if the attribute doesn't exist.
		unset: function(attr, options) {
			return this.set(attr, void 0, _.extend({}, options, {unset: true}));
		},

		// Clear all attributes on the model, firing `"change"`.
		clear: function(options) {
			var attrs = {};
			for (var key in this.attributes) attrs[key] = void 0;
			return this.set(attrs, _.extend({}, options, {unset: true}));
		},

		// Determine if the model has changed since the last `"change"` event.
		// If you specify an attribute name, determine if that attribute has changed.
		hasChanged: function(attr) {
			if (attr == null) return !_.isEmpty(this.changed);
			return _.has(this.changed, attr);
		},

		// Return an object containing all the attributes that have changed, or
		// false if there are no changed attributes. Useful for determining what
		// parts of a view need to be updated and/or what attributes need to be
		// persisted to the server. Unset attributes will be set to undefined.
		// You can also pass an attributes object to diff against the model,
		// determining if there *would be* a change.
		changedAttributes: function(diff) {
			if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
			var val, changed = false;
			var old = this._changing ? this._previousAttributes : this.attributes;
			for (var attr in diff) {
				if (_.isEqual(old[attr], (val = diff[attr]))) continue;
				(changed || (changed = {}))[attr] = val;
			}
			return changed;
		},

		// Get the previous value of an attribute, recorded at the time the last
		// `"change"` event was fired.
		previous: function(attr) {
			if (attr == null || !this._previousAttributes) return null;
			return this._previousAttributes[attr];
		},

		// Get all of the attributes of the model at the time of the previous
		// `"change"` event.
		previousAttributes: function() {
			return _.clone(this._previousAttributes);
		},

		// Fetch the model from the server. If the server's representation of the
		// model differs from its current attributes, they will be overridden,
		// triggering a `"change"` event.
		fetch: function(options) {
			options = options ? _.clone(options) : {};
			if (options.parse === void 0) options.parse = true;
			var model = this;
			var success = options.success;
			options.success = function(resp) {
				if (!model.set(model.parse(resp, options), options)) return false;
				if (success) success(model, resp, options);
				model.trigger('sync', model, resp, options);
			};
			wrapError(this, options);
			return this.sync('read', this, options);
		},

		// Set a hash of model attributes, and sync the model to the server.
		// If the server returns an attributes hash that differs, the model's
		// state will be `set` again.
		save: function(key, val, options) {
			var attrs, method, xhr, attributes = this.attributes;

			// Handle both `"key", value` and `{key: value}` -style arguments.
			if (key == null || typeof key === 'object') {
				attrs = key;
				options = val;
			} else {
				(attrs = {})[key] = val;
			}

			options = _.extend({validate: true}, options);

			// If we're not waiting and attributes exist, save acts as
			// `set(attr).save(null, opts)` with validation. Otherwise, check if
			// the model will be valid when the attributes, if any, are set.
			if (attrs && !options.wait) {
				if (!this.set(attrs, options)) return false;
			} else {
				if (!this._validate(attrs, options)) return false;
			}

			// Set temporary attributes if `{wait: true}`.
			if (attrs && options.wait) {
				this.attributes = _.extend({}, attributes, attrs);
			}

			// After a successful server-side save, the client is (optionally)
			// updated with the server-side state.
			if (options.parse === void 0) options.parse = true;
			var model = this;
			var success = options.success;
			options.success = function(resp) {
				// Ensure attributes are restored during synchronous saves.
				model.attributes = attributes;
				var serverAttrs = model.parse(resp, options);
				if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
				if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
					return false;
				}
				if (success) success(model, resp, options);
				model.trigger('sync', model, resp, options);
			};
			wrapError(this, options);

			method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
			if (method === 'patch') options.attrs = attrs;
			xhr = this.sync(method, this, options);

			// Restore attributes.
			if (attrs && options.wait) this.attributes = attributes;

			return xhr;
		},

		// Destroy this model on the server if it was already persisted.
		// Optimistically removes the model from its collection, if it has one.
		// If `wait: true` is passed, waits for the server to respond before removal.
		destroy: function(options) {
			options = options ? _.clone(options) : {};
			var model = this;
			var success = options.success;

			var destroy = function() {
				model.trigger('destroy', model, model.collection, options);
			};

			options.success = function(resp) {
				if (options.wait || model.isNew()) destroy();
				if (success) success(model, resp, options);
				if (!model.isNew()) model.trigger('sync', model, resp, options);
			};

			if (this.isNew()) {
				options.success();
				return false;
			}
			wrapError(this, options);

			var xhr = this.sync('delete', this, options);
			if (!options.wait) destroy();
			return xhr;
		},

		// Default URL for the model's representation on the server -- if you're
		// using Backbone's restful methods, override this to change the endpoint
		// that will be called.
		url: function() {
			var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
			if (this.isNew()) return base;
			return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
		},

		// **parse** converts a response into the hash of attributes to be `set` on
		// the model. The default implementation is just to pass the response along.
		parse: function(resp, options) {
			return resp;
		},

		// Create a new model with identical attributes to this one.
		clone: function() {
			return new this.constructor(this.attributes);
		},

		// A model is new if it has never been saved to the server, and lacks an id.
		isNew: function() {
			return this.id == null;
		},

		// Check if the model is currently in a valid state.
		isValid: function(options) {
			return this._validate({}, _.extend(options || {}, { validate: true }));
		},

		// Run validation against the next complete set of model attributes,
		// returning `true` if all is well. Otherwise, fire an `"invalid"` event.
		_validate: function(attrs, options) {
			if (!options.validate || !this.validate) return true;
			attrs = _.extend({}, this.attributes, attrs);
			var error = this.validationError = this.validate(attrs, options) || null;
			if (!error) return true;
			this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
			return false;
		}

	});

	// Underscore methods that we want to implement on the Model.
	var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

	// Mix in each Underscore method as a proxy to `Model#attributes`.
	_.each(modelMethods, function(method) {
		Model.prototype[method] = function() {
			var args = slice.call(arguments);
			args.unshift(this.attributes);
			return _[method].apply(_, args);
		};
	});

	// Backbone.Collection
	// -------------------

	// If models tend to represent a single row of data, a Backbone Collection is
	// more analagous to a table full of data ... or a small slice or page of that
	// table, or a collection of rows that belong together for a particular reason
	// -- all of the messages in this particular folder, all of the documents
	// belonging to this particular author, and so on. Collections maintain
	// indexes of their models, both in order, and for lookup by `id`.

	// Create a new **Collection**, perhaps to contain a specific type of `model`.
	// If a `comparator` is specified, the Collection will maintain
	// its models in sort order, as they're added and removed.
	var Collection = Backbone.Collection = function(models, options) {
		options || (options = {});
		if (options.model) this.model = options.model;
		if (options.comparator !== void 0) this.comparator = options.comparator;
		this._reset();
		this.initialize.apply(this, arguments);
		if (models) this.reset(models, _.extend({silent: true}, options));
	};

	// Default options for `Collection#set`.
	var setOptions = {add: true, remove: true, merge: true};
	var addOptions = {add: true, remove: false};

	// Define the Collection's inheritable methods.
	_.extend(Collection.prototype, Events, {

		// The default model for a collection is just a **Backbone.Model**.
		// This should be overridden in most cases.
		model: Model,

		// Initialize is an empty function by default. Override it with your own
		// initialization logic.
		initialize: function(){},

		// The JSON representation of a Collection is an array of the
		// models' attributes.
		toJSON: function(options) {
			return this.map(function(model){ return model.toJSON(options); });
		},

		// Proxy `Backbone.sync` by default.
		sync: function() {
			return Backbone.sync.apply(this, arguments);
		},

		// Add a model, or list of models to the set.
		add: function(models, options) {
			return this.set(models, _.extend({merge: false}, options, addOptions));
		},

		// Remove a model, or a list of models from the set.
		remove: function(models, options) {
			var singular = !_.isArray(models);
			models = singular ? [models] : _.clone(models);
			options || (options = {});
			var i, l, index, model;
			for (i = 0, l = models.length; i < l; i++) {
				model = models[i] = this.get(models[i]);
				if (!model) continue;
				delete this._byId[model.id];
				delete this._byId[model.cid];
				index = this.indexOf(model);
				this.models.splice(index, 1);
				this.length--;
				if (!options.silent) {
					options.index = index;
					model.trigger('remove', model, this, options);
				}
				this._removeReference(model);
			}
			return singular ? models[0] : models;
		},

		// Update a collection by `set`-ing a new list of models, adding new ones,
		// removing models that are no longer present, and merging models that
		// already exist in the collection, as necessary. Similar to **Model#set**,
		// the core operation for updating the data contained by the collection.
		set: function(models, options) {
			options = _.defaults({}, options, setOptions);
			if (options.parse) models = this.parse(models, options);
			var singular = !_.isArray(models);
			models = singular ? (models ? [models] : []) : _.clone(models);
			var i, l, id, model, attrs, existing, sort;
			var at = options.at;
			var targetModel = this.model;
			var sortable = this.comparator && (at == null) && options.sort !== false;
			var sortAttr = _.isString(this.comparator) ? this.comparator : null;
			var toAdd = [], toRemove = [], modelMap = {};
			var add = options.add, merge = options.merge, remove = options.remove;
			var order = !sortable && add && remove ? [] : false;

			// Turn bare objects into model references, and prevent invalid models
			// from being added.
			for (i = 0, l = models.length; i < l; i++) {
				attrs = models[i];
				if (attrs instanceof Model) {
					id = model = attrs;
				} else {
					id = attrs[targetModel.prototype.idAttribute];
				}

				// If a duplicate is found, prevent it from being added and
				// optionally merge it into the existing model.
				if (existing = this.get(id)) {
					if (remove) modelMap[existing.cid] = true;
					if (merge) {
						attrs = attrs === model ? model.attributes : attrs;
						if (options.parse) attrs = existing.parse(attrs, options);
						existing.set(attrs, options);
						if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
					}
					models[i] = existing;

				// If this is a new, valid model, push it to the `toAdd` list.
				} else if (add) {
					model = models[i] = this._prepareModel(attrs, options);
					if (!model) continue;
					toAdd.push(model);

					// Listen to added models' events, and index models for lookup by
					// `id` and by `cid`.
					model.on('all', this._onModelEvent, this);
					this._byId[model.cid] = model;
					if (model.id != null) this._byId[model.id] = model;
				}
				if (order) order.push(existing || model);
			}

			// Remove nonexistent models if appropriate.
			if (remove) {
				for (i = 0, l = this.length; i < l; ++i) {
					if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
				}
				if (toRemove.length) this.remove(toRemove, options);
			}

			// See if sorting is needed, update `length` and splice in new models.
			if (toAdd.length || (order && order.length)) {
				if (sortable) sort = true;
				this.length += toAdd.length;
				if (at != null) {
					for (i = 0, l = toAdd.length; i < l; i++) {
						this.models.splice(at + i, 0, toAdd[i]);
					}
				} else {
					if (order) this.models.length = 0;
					var orderedModels = order || toAdd;
					for (i = 0, l = orderedModels.length; i < l; i++) {
						this.models.push(orderedModels[i]);
					}
				}
			}

			// Silently sort the collection if appropriate.
			if (sort) this.sort({silent: true});

			// Unless silenced, it's time to fire all appropriate add/sort events.
			if (!options.silent) {
				for (i = 0, l = toAdd.length; i < l; i++) {
					(model = toAdd[i]).trigger('add', model, this, options);
				}
				if (sort || (order && order.length)) this.trigger('sort', this, options);
			}
			
			// Return the added (or merged) model (or models).
			return singular ? models[0] : models;
		},

		// When you have more items than you want to add or remove individually,
		// you can reset the entire set with a new list of models, without firing
		// any granular `add` or `remove` events. Fires `reset` when finished.
		// Useful for bulk operations and optimizations.
		reset: function(models, options) {
			options || (options = {});
			for (var i = 0, l = this.models.length; i < l; i++) {
				this._removeReference(this.models[i]);
			}
			options.previousModels = this.models;
			this._reset();
			models = this.add(models, _.extend({silent: true}, options));
			if (!options.silent) this.trigger('reset', this, options);
			return models;
		},

		// Add a model to the end of the collection.
		push: function(model, options) {
			return this.add(model, _.extend({at: this.length}, options));
		},

		// Remove a model from the end of the collection.
		pop: function(options) {
			var model = this.at(this.length - 1);
			this.remove(model, options);
			return model;
		},

		// Add a model to the beginning of the collection.
		unshift: function(model, options) {
			return this.add(model, _.extend({at: 0}, options));
		},

		// Remove a model from the beginning of the collection.
		shift: function(options) {
			var model = this.at(0);
			this.remove(model, options);
			return model;
		},

		// Slice out a sub-array of models from the collection.
		slice: function() {
			return slice.apply(this.models, arguments);
		},

		// Get a model from the set by id.
		get: function(obj) {
			if (obj == null) return void 0;
			return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
		},

		// Get the model at the given index.
		at: function(index) {
			return this.models[index];
		},

		// Return models with matching attributes. Useful for simple cases of
		// `filter`.
		where: function(attrs, first) {
			if (_.isEmpty(attrs)) return first ? void 0 : [];
			return this[first ? 'find' : 'filter'](function(model) {
				for (var key in attrs) {
					if (attrs[key] !== model.get(key)) return false;
				}
				return true;
			});
		},

		// Return the first model with matching attributes. Useful for simple cases
		// of `find`.
		findWhere: function(attrs) {
			return this.where(attrs, true);
		},

		// Force the collection to re-sort itself. You don't need to call this under
		// normal circumstances, as the set will maintain sort order as each item
		// is added.
		sort: function(options) {
			if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
			options || (options = {});

			// Run sort based on type of `comparator`.
			if (_.isString(this.comparator) || this.comparator.length === 1) {
				this.models = this.sortBy(this.comparator, this);
			} else {
				this.models.sort(_.bind(this.comparator, this));
			}

			if (!options.silent) this.trigger('sort', this, options);
			return this;
		},

		// Pluck an attribute from each model in the collection.
		pluck: function(attr) {
			return _.invoke(this.models, 'get', attr);
		},

		// Fetch the default set of models for this collection, resetting the
		// collection when they arrive. If `reset: true` is passed, the response
		// data will be passed through the `reset` method instead of `set`.
		fetch: function(options) {
			options = options ? _.clone(options) : {};
			if (options.parse === void 0) options.parse = true;
			var success = options.success;
			var collection = this;
			options.success = function(resp) {
				var method = options.reset ? 'reset' : 'set';
				collection[method](resp, options);
				if (success) success(collection, resp, options);
				collection.trigger('sync', collection, resp, options);
			};
			wrapError(this, options);
			return this.sync('read', this, options);
		},

		// Create a new instance of a model in this collection. Add the model to the
		// collection immediately, unless `wait: true` is passed, in which case we
		// wait for the server to agree.
		create: function(model, options) {
			options = options ? _.clone(options) : {};
			if (!(model = this._prepareModel(model, options))) return false;
			if (!options.wait) this.add(model, options);
			var collection = this;
			var success = options.success;
			options.success = function(model, resp, options) {
				if (options.wait) collection.add(model, options);
				if (success) success(model, resp, options);
			};
			model.save(null, options);
			return model;
		},

		// **parse** converts a response into a list of models to be added to the
		// collection. The default implementation is just to pass it through.
		parse: function(resp, options) {
			return resp;
		},

		// Create a new collection with an identical list of models as this one.
		clone: function() {
			return new this.constructor(this.models);
		},

		// Private method to reset all internal state. Called when the collection
		// is first initialized or reset.
		_reset: function() {
			this.length = 0;
			this.models = [];
			this._byId  = {};
		},

		// Prepare a hash of attributes (or other model) to be added to this
		// collection.
		_prepareModel: function(attrs, options) {
			if (attrs instanceof Model) {
				if (!attrs.collection) attrs.collection = this;
				return attrs;
			}
			options = options ? _.clone(options) : {};
			options.collection = this;
			var model = new this.model(attrs, options);
			if (!model.validationError) return model;
			this.trigger('invalid', this, model.validationError, options);
			return false;
		},

		// Internal method to sever a model's ties to a collection.
		_removeReference: function(model) {
			if (this === model.collection) delete model.collection;
			model.off('all', this._onModelEvent, this);
		},

		// Internal method called every time a model in the set fires an event.
		// Sets need to update their indexes when models change ids. All other
		// events simply proxy through. "add" and "remove" events that originate
		// in other collections are ignored.
		_onModelEvent: function(event, model, collection, options) {
			if ((event === 'add' || event === 'remove') && collection !== this) return;
			if (event === 'destroy') this.remove(model, options);
			if (model && event === 'change:' + model.idAttribute) {
				delete this._byId[model.previous(model.idAttribute)];
				if (model.id != null) this._byId[model.id] = model;
			}
			this.trigger.apply(this, arguments);
		}

	});

	// Underscore methods that we want to implement on the Collection.
	// 90% of the core usefulness of Backbone Collections is actually implemented
	// right here:
	var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
		'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
		'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
		'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
		'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
		'lastIndexOf', 'isEmpty', 'chain'];

	// Mix in each Underscore method as a proxy to `Collection#models`.
	_.each(methods, function(method) {
		Collection.prototype[method] = function() {
			var args = slice.call(arguments);
			args.unshift(this.models);
			return _[method].apply(_, args);
		};
	});

	// Underscore methods that take a property name as an argument.
	var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

	// Use attributes instead of properties.
	_.each(attributeMethods, function(method) {
		Collection.prototype[method] = function(value, context) {
			var iterator = _.isFunction(value) ? value : function(model) {
				return model.get(value);
			};
			return _[method](this.models, iterator, context);
		};
	});

	// Backbone.View
	// -------------

	// Backbone Views are almost more convention than they are actual code. A View
	// is simply a JavaScript object that represents a logical chunk of UI in the
	// DOM. This might be a single item, an entire list, a sidebar or panel, or
	// even the surrounding frame which wraps your whole app. Defining a chunk of
	// UI as a **View** allows you to define your DOM events declaratively, without
	// having to worry about render order ... and makes it easy for the view to
	// react to specific changes in the state of your models.

	// Creating a Backbone.View creates its initial element outside of the DOM,
	// if an existing element is not provided...
	var View = Backbone.View = function(options) {
		this.cid = _.uniqueId('view');
		options || (options = {});
		_.extend(this, _.pick(options, viewOptions));
		this._ensureElement();
		this.initialize.apply(this, arguments);
		this.delegateEvents();
	};

	// Cached regex to split keys for `delegate`.
	var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	// List of view options to be merged as properties.
	var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

	// Set up all inheritable **Backbone.View** properties and methods.
	_.extend(View.prototype, Events, {

		// The default `tagName` of a View's element is `"div"`.
		tagName: 'div',

		// jQuery delegate for element lookup, scoped to DOM elements within the
		// current view. This should be preferred to global lookups where possible.
		$: function(selector) {
			return this.$el.find(selector);
		},

		// Initialize is an empty function by default. Override it with your own
		// initialization logic.
		initialize: function(){},

		// **render** is the core function that your view should override, in order
		// to populate its element (`this.el`), with the appropriate HTML. The
		// convention is for **render** to always return `this`.
		render: function() {
			return this;
		},

		// Remove this view by taking the element out of the DOM, and removing any
		// applicable Backbone.Events listeners.
		remove: function() {
			this.$el.remove();
			this.stopListening();
			return this;
		},

		// Change the view's element (`this.el` property), including event
		// re-delegation.
		setElement: function(element, delegate) {
			if (this.$el) this.undelegateEvents();
			this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
			this.el = this.$el[0];
			if (delegate !== false) this.delegateEvents();
			return this;
		},

		// Set callbacks, where `this.events` is a hash of
		//
		// *{"event selector": "callback"}*
		//
		//     {
		//       'mousedown .title':  'edit',
		//       'click .button':     'save',
		//       'click .open':       function(e) { ... }
		//     }
		//
		// pairs. Callbacks will be bound to the view, with `this` set properly.
		// Uses event delegation for efficiency.
		// Omitting the selector binds the event to `this.el`.
		// This only works for delegate-able events: not `focus`, `blur`, and
		// not `change`, `submit`, and `reset` in Internet Explorer.
		delegateEvents: function(events) {
			if (!(events || (events = _.result(this, 'events')))) return this;
			this.undelegateEvents();
			for (var key in events) {
				var method = events[key];
				if (!_.isFunction(method)) method = this[events[key]];
				if (!method) continue;

				var match = key.match(delegateEventSplitter);
				var eventName = match[1], selector = match[2];
				method = _.bind(method, this);
				eventName += '.delegateEvents' + this.cid;
				if (selector === '') {
					this.$el.on(eventName, method);
				} else {
					this.$el.on(eventName, selector, method);
				}
			}
			return this;
		},

		// Clears all callbacks previously bound to the view with `delegateEvents`.
		// You usually don't need to use this, but may wish to if you have multiple
		// Backbone views attached to the same DOM element.
		undelegateEvents: function() {
			this.$el.off('.delegateEvents' + this.cid);
			return this;
		},

		// Ensure that the View has a DOM element to render into.
		// If `this.el` is a string, pass it through `$()`, take the first
		// matching element, and re-assign it to `el`. Otherwise, create
		// an element from the `id`, `className` and `tagName` properties.
		_ensureElement: function() {
			if (!this.el) {
				var attrs = _.extend({}, _.result(this, 'attributes'));
				if (this.id) attrs.id = _.result(this, 'id');
				if (this.className) attrs['class'] = _.result(this, 'className');
				var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
				this.setElement($el, false);
			} else {
				this.setElement(_.result(this, 'el'), false);
			}
		}

	});

	// Backbone.sync
	// -------------

	// Override this function to change the manner in which Backbone persists
	// models to the server. You will be passed the type of request, and the
	// model in question. By default, makes a RESTful Ajax request
	// to the model's `url()`. Some possible customizations could be:
	//
	// * Use `setTimeout` to batch rapid-fire updates into a single request.
	// * Send up the models as XML instead of JSON.
	// * Persist models via WebSockets instead of Ajax.
	//
	// Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
	// as `POST`, with a `_method` parameter containing the true HTTP method,
	// as well as all requests with the body as `application/x-www-form-urlencoded`
	// instead of `application/json` with the model in a param named `model`.
	// Useful when interfacing with server-side languages like **PHP** that make
	// it difficult to read the body of `PUT` requests.
	Backbone.sync = function(method, model, options) {
		var type = methodMap[method];

		// Default options, unless specified.
		_.defaults(options || (options = {}), {
			emulateHTTP: Backbone.emulateHTTP,
			emulateJSON: Backbone.emulateJSON
		});

		// Default JSON-request options.
		var params = {type: type, dataType: 'json'};

		// Ensure that we have a URL.
		if (!options.url) {
			params.url = _.result(model, 'url') || urlError();
		}

		// Ensure that we have the appropriate request data.
		if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
			params.contentType = 'application/json';
			params.data = JSON.stringify(options.attrs || model.toJSON(options));
		}

		// For older servers, emulate JSON by encoding the request into an HTML-form.
		if (options.emulateJSON) {
			params.contentType = 'application/x-www-form-urlencoded';
			params.data = params.data ? {model: params.data} : {};
		}

		// For older servers, emulate HTTP by mimicking the HTTP method with `_method`
		// And an `X-HTTP-Method-Override` header.
		if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
			params.type = 'POST';
			if (options.emulateJSON) params.data._method = type;
			var beforeSend = options.beforeSend;
			options.beforeSend = function(xhr) {
				xhr.setRequestHeader('X-HTTP-Method-Override', type);
				if (beforeSend) return beforeSend.apply(this, arguments);
			};
		}

		// Don't process data on a non-GET request.
		if (params.type !== 'GET' && !options.emulateJSON) {
			params.processData = false;
		}

		// If we're sending a `PATCH` request, and we're in an old Internet Explorer
		// that still has ActiveX enabled by default, override jQuery to use that
		// for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
		if (params.type === 'PATCH' && noXhrPatch) {
			params.xhr = function() {
				return new ActiveXObject("Microsoft.XMLHTTP");
			};
		}

		// Make the request, allowing the user to override any Ajax options.
		var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
		model.trigger('request', model, xhr, options);
		return xhr;
	};

	var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

	// Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	var methodMap = {
		'create': 'POST',
		'update': 'PUT',
		'patch':  'PATCH',
		'delete': 'DELETE',
		'read':   'GET'
	};

	// Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	// Override this if you'd like to use a different library.
	Backbone.ajax = function() {
		return Backbone.$.ajax.apply(Backbone.$, arguments);
	};

	// Backbone.Router
	// ---------------

	// Routers map faux-URLs to actions, and fire events when routes are
	// matched. Creating a new one sets its `routes` hash, if not set statically.
	var Router = Backbone.Router = function(options) {
		options || (options = {});
		if (options.routes) this.routes = options.routes;
		this._bindRoutes();
		this.initialize.apply(this, arguments);
	};

	// Cached regular expressions for matching named param parts and splatted
	// parts of route strings.
	var optionalParam = /\((.*?)\)/g;
	var namedParam    = /(\(\?)?:\w+/g;
	var splatParam    = /\*\w+/g;
	var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

	// Set up all inheritable **Backbone.Router** properties and methods.
	_.extend(Router.prototype, Events, {

		// Initialize is an empty function by default. Override it with your own
		// initialization logic.
		initialize: function(){},

		// Manually bind a single named route to a callback. For example:
		//
		//     this.route('search/:query/p:num', 'search', function(query, num) {
		//       ...
		//     });
		//
		route: function(route, name, callback) {
			if (!_.isRegExp(route)) route = this._routeToRegExp(route);
			if (_.isFunction(name)) {
				callback = name;
				name = '';
			}
			if (!callback) callback = this[name];
			var router = this;
			Backbone.history.route(route, function(fragment) {
				var args = router._extractParameters(route, fragment);
				callback && callback.apply(router, args);
				router.trigger.apply(router, ['route:' + name].concat(args));
				router.trigger('route', name, args);
				Backbone.history.trigger('route', router, name, args);
			});
			return this;
		},

		// Simple proxy to `Backbone.history` to save a fragment into the history.
		navigate: function(fragment, options) {
			Backbone.history.navigate(fragment, options);
			return this;
		},

		// Bind all defined routes to `Backbone.history`. We have to reverse the
		// order of the routes here to support behavior where the most general
		// routes can be defined at the bottom of the route map.
		_bindRoutes: function() {
			if (!this.routes) return;
			this.routes = _.result(this, 'routes');
			var route, routes = _.keys(this.routes);
			while ((route = routes.pop()) != null) {
				this.route(route, this.routes[route]);
			}
		},

		// Convert a route string into a regular expression, suitable for matching
		// against the current location hash.
		_routeToRegExp: function(route) {
			route = route.replace(escapeRegExp, '\\$&')
									 .replace(optionalParam, '(?:$1)?')
									 .replace(namedParam, function(match, optional) {
										 return optional ? match : '([^\/]+)';
									 })
									 .replace(splatParam, '(.*?)');
			return new RegExp('^' + route + '$');
		},

		// Given a route, and a URL fragment that it matches, return the array of
		// extracted decoded parameters. Empty or unmatched parameters will be
		// treated as `null` to normalize cross-browser behavior.
		_extractParameters: function(route, fragment) {
			var params = route.exec(fragment).slice(1);
			return _.map(params, function(param) {
				return param ? decodeURIComponent(param) : null;
			});
		}

	});

	// Backbone.History
	// ----------------

	// Handles cross-browser history management, based on either
	// [pushState](http://diveintohtml5.info/history.html) and real URLs, or
	// [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
	// and URL fragments. If the browser supports neither (old IE, natch),
	// falls back to polling.
	var History = Backbone.History = function() {
		this.handlers = [];
		_.bindAll(this, 'checkUrl');

		// Ensure that `History` can be used outside of the browser.
		if (typeof window !== 'undefined') {
			this.location = window.location;
			this.history = window.history;
		}
	};

	// Cached regex for stripping a leading hash/slash and trailing space.
	var routeStripper = /^[#\/]|\s+$/g;

	// Cached regex for stripping leading and trailing slashes.
	var rootStripper = /^\/+|\/+$/g;

	// Cached regex for detecting MSIE.
	var isExplorer = /msie [\w.]+/;

	// Cached regex for removing a trailing slash.
	var trailingSlash = /\/$/;

	// Cached regex for stripping urls of hash and query.
	var pathStripper = /[?#].*$/;

	// Has the history handling already been started?
	History.started = false;

	// Set up all inheritable **Backbone.History** properties and methods.
	_.extend(History.prototype, Events, {

		// The default interval to poll for hash changes, if necessary, is
		// twenty times a second.
		interval: 50,

		// Gets the true hash value. Cannot use location.hash directly due to bug
		// in Firefox where location.hash will always be decoded.
		getHash: function(window) {
			var match = (window || this).location.href.match(/#(.*)$/);
			return match ? match[1] : '';
		},

		// Get the cross-browser normalized URL fragment, either from the URL,
		// the hash, or the override.
		getFragment: function(fragment, forcePushState) {
			if (fragment == null) {
				if (this._hasPushState || !this._wantsHashChange || forcePushState) {
					fragment = this.location.pathname;
					var root = this.root.replace(trailingSlash, '');
					if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
				} else {
					fragment = this.getHash();
				}
			}
			return fragment.replace(routeStripper, '');
		},

		// Start the hash change handling, returning `true` if the current URL matches
		// an existing route, and `false` otherwise.
		start: function(options) {
			if (History.started) throw new Error("Backbone.history has already been started");
			History.started = true;

			// Figure out the initial configuration. Do we need an iframe?
			// Is pushState desired ... is it available?
			this.options          = _.extend({root: '/'}, this.options, options);
			this.root             = this.options.root;
			this._wantsHashChange = this.options.hashChange !== false;
			this._wantsPushState  = !!this.options.pushState;
			this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
			var fragment          = this.getFragment();
			var docMode           = document.documentMode;
			var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

			// Normalize root to always include a leading and trailing slash.
			this.root = ('/' + this.root + '/').replace(rootStripper, '/');

			if (oldIE && this._wantsHashChange) {
				this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
				this.navigate(fragment);
			}

			// Depending on whether we're using pushState or hashes, and whether
			// 'onhashchange' is supported, determine how we check the URL state.
			if (this._hasPushState) {
				Backbone.$(window).on('popstate', this.checkUrl);
			} else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
				Backbone.$(window).on('hashchange', this.checkUrl);
			} else if (this._wantsHashChange) {
				this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
			}

			// Determine if we need to change the base url, for a pushState link
			// opened by a non-pushState browser.
			this.fragment = fragment;
			var loc = this.location;
			var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

			// Transition from hashChange to pushState or vice versa if both are
			// requested.
			if (this._wantsHashChange && this._wantsPushState) {

				// If we've started off with a route from a `pushState`-enabled
				// browser, but we're currently in a browser that doesn't support it...
				if (!this._hasPushState && !atRoot) {
					this.fragment = this.getFragment(null, true);
					this.location.replace(this.root + this.location.search + '#' + this.fragment);
					// Return immediately as browser will do redirect to new url
					return true;

				// Or if we've started out with a hash-based route, but we're currently
				// in a browser where it could be `pushState`-based instead...
				} else if (this._hasPushState && atRoot && loc.hash) {
					this.fragment = this.getHash().replace(routeStripper, '');
					this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
				}

			}

			if (!this.options.silent) return this.loadUrl();
		},

		// Disable Backbone.history, perhaps temporarily. Not useful in a real app,
		// but possibly useful for unit testing Routers.
		stop: function() {
			Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
			clearInterval(this._checkUrlInterval);
			History.started = false;
		},

		// Add a route to be tested when the fragment changes. Routes added later
		// may override previous routes.
		route: function(route, callback) {
			this.handlers.unshift({route: route, callback: callback});
		},

		// Checks the current URL to see if it has changed, and if it has,
		// calls `loadUrl`, normalizing across the hidden iframe.
		checkUrl: function(e) {
			var current = this.getFragment();
			if (current === this.fragment && this.iframe) {
				current = this.getFragment(this.getHash(this.iframe));
			}
			if (current === this.fragment) return false;
			if (this.iframe) this.navigate(current);
			this.loadUrl();
		},

		// Attempt to load the current URL fragment. If a route succeeds with a
		// match, returns `true`. If no defined routes matches the fragment,
		// returns `false`.
		loadUrl: function(fragment) {
			fragment = this.fragment = this.getFragment(fragment);
			return _.any(this.handlers, function(handler) {
				if (handler.route.test(fragment)) {
					handler.callback(fragment);
					return true;
				}
			});
		},

		// Save a fragment into the hash history, or replace the URL state if the
		// 'replace' option is passed. You are responsible for properly URL-encoding
		// the fragment in advance.
		//
		// The options object can contain `trigger: true` if you wish to have the
		// route callback be fired (not usually desirable), or `replace: true`, if
		// you wish to modify the current URL without adding an entry to the history.
		navigate: function(fragment, options) {
			if (!History.started) return false;
			if (!options || options === true) options = {trigger: !!options};

			var url = this.root + (fragment = this.getFragment(fragment || ''));

			// Strip the fragment of the query and hash for matching.
			fragment = fragment.replace(pathStripper, '');

			if (this.fragment === fragment) return;
			this.fragment = fragment;

			// Don't include a trailing slash on the root.
			if (fragment === '' && url !== '/') url = url.slice(0, -1);

			// If pushState is available, we use it to set the fragment as a real URL.
			if (this._hasPushState) {
				this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

			// If hash changes haven't been explicitly disabled, update the hash
			// fragment to store history.
			} else if (this._wantsHashChange) {
				this._updateHash(this.location, fragment, options.replace);
				if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
					// Opening and closing the iframe tricks IE7 and earlier to push a
					// history entry on hash-tag change.  When replace is true, we don't
					// want this.
					if(!options.replace) this.iframe.document.open().close();
					this._updateHash(this.iframe.location, fragment, options.replace);
				}

			// If you've told us that you explicitly don't want fallback hashchange-
			// based history, then `navigate` becomes a page refresh.
			} else {
				return this.location.assign(url);
			}
			if (options.trigger) return this.loadUrl(fragment);
		},

		// Update the hash location, either replacing the current entry, or adding
		// a new one to the browser history.
		_updateHash: function(location, fragment, replace) {
			if (replace) {
				var href = location.href.replace(/(javascript:|#).*$/, '');
				location.replace(href + '#' + fragment);
			} else {
				// Some browsers require that `hash` contains a leading #.
				location.hash = '#' + fragment;
			}
		}

	});

	// Create the default Backbone.history.
	Backbone.history = new History;

	// Helpers
	// -------

	// Helper function to correctly set up the prototype chain, for subclasses.
	// Similar to `goog.inherits`, but uses a hash of prototype properties and
	// class properties to be extended.
	var extend = function(protoProps, staticProps) {
		var parent = this;
		var child;

		// The constructor function for the new subclass is either defined by you
		// (the "constructor" property in your `extend` definition), or defaulted
		// by us to simply call the parent's constructor.
		if (protoProps && _.has(protoProps, 'constructor')) {
			child = protoProps.constructor;
		} else {
			child = function(){ return parent.apply(this, arguments); };
		}

		// Add static properties to the constructor function, if supplied.
		_.extend(child, parent, staticProps);

		// Set the prototype chain to inherit from `parent`, without calling
		// `parent`'s constructor function.
		var Surrogate = function(){ this.constructor = child; };
		Surrogate.prototype = parent.prototype;
		child.prototype = new Surrogate;

		// Add prototype properties (instance properties) to the subclass,
		// if supplied.
		if (protoProps) _.extend(child.prototype, protoProps);

		// Set a convenience property in case the parent's prototype is needed
		// later.
		child.__super__ = parent.prototype;

		return child;
	};

	// Set up inheritance for the model, collection, router, view and history.
	Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

	// Throw an error when a URL is needed, and none is supplied.
	var urlError = function() {
		throw new Error('A "url" property or function must be specified');
	};

	// Wrap an optional error callback with a fallback error event.
	var wrapError = function(model, options) {
		var error = options.error;
		options.error = function(resp) {
			if (error) error(model, resp, options);
			model.trigger('error', model, resp, options);
		};
	};

}).call(this);
; /* ************************ new file ************************ */
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
var Mustache = (typeof module !== "undefined" && module.exports) || {};

(function (exports) {

    exports.name = "mustache.js";
    exports.version = "0.5.0-dev";
    exports.tags = ["{{", "}}"];
    exports.parse = parse;
    exports.compile = compile;
    exports.render = render;
    exports.clearCache = clearCache;

    // This is here for backwards compatibility with 0.4.x.
    exports.to_html = function (template, view, partials, send) {
        var result = render(template, view, partials);

        if (typeof send === "function") {
            send(result);
        } else {
            return result;
        }
    };

    var _toString = Object.prototype.toString;
    var _isArray = Array.isArray;
    var _forEach = Array.prototype.forEach;
    var _trim = String.prototype.trim;

    var isArray;
    if (_isArray) {
        isArray = _isArray;
    } else {
        isArray = function (obj) {
            return _toString.call(obj) === "[object Array]";
        };
    }

    var forEach;
    if (_forEach) {
        forEach = function (obj, callback, scope) {
            return _forEach.call(obj, callback, scope);
        };
    } else {
        forEach = function (obj, callback, scope) {
            for (var i = 0, len = obj.length; i < len; ++i) {
                callback.call(scope, obj[i], i, obj);
            }
        };
    }

    var spaceRe = /^\s*$/;

    function isWhitespace(string) {
        return spaceRe.test(string);
    }

    var trim;
    if (_trim) {
        trim = function (string) {
            return string == null ? "" : _trim.call(string);
        };
    } else {
        var trimLeft, trimRight;

        if (isWhitespace("\xA0")) {
            trimLeft = /^\s+/;
            trimRight = /\s+$/;
        } else {
            // IE doesn't match non-breaking spaces with \s, thanks jQuery.
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        trim = function (string) {
            return string == null ? "" :
                String(string).replace(trimLeft, "").replace(trimRight, "");
        };
    }

    var escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;'
    };

    function escapeHTML(string) {
        return String(string).replace(/&(?!\w+;)|[<>"']/g, function (s) {
            return escapeMap[s] || s;
        });
    }

    /**
     * Adds the `template`, `line`, and `file` properties to the given error
     * object and alters the message to provide more useful debugging information.
     */
    function debug(e, template, line, file) {
        file = file || "<template>";

        var lines = template.split("\n"),
                start = Math.max(line - 3, 0),
                end = Math.min(lines.length, line + 3),
                context = lines.slice(start, end);

        var c;
        for (var i = 0, len = context.length; i < len; ++i) {
            c = i + start + 1;
            context[i] = (c === line ? " >> " : "    ") + context[i];
        }

        e.template = template;
        e.line = line;
        e.file = file;
        e.message = [file + ":" + line, context.join("\n"), "", e.message].join("\n");

        return e;
    }

    /**
     * Looks up the value of the given `name` in the given context `stack`.
     */
    function lookup(name, stack, defaultValue) {
        if (name === ".") {
            return stack[stack.length - 1];
        }

        var names = name.split(".");
        var lastIndex = names.length - 1;
        var target = names[lastIndex];

        var value, context, i = stack.length, j, localStack;
        while (i) {
            localStack = stack.slice(0);
            context = stack[--i];

            j = 0;
            while (j < lastIndex) {
                context = context[names[j++]];

                if (context == null) {
                    break;
                }

                localStack.push(context);
            }

            if (context && typeof context === "object" && target in context) {
                value = context[target];
                break;
            }
        }

        // If the value is a function, call it in the current context.
        if (typeof value === "function") {
            value = value.call(localStack[localStack.length - 1]);
        }

        if (value == null)  {
            return defaultValue;
        }

        return value;
    }

    function renderSection(name, stack, callback, inverted) {
        var buffer = "";
        var value =  lookup(name, stack);

        if (inverted) {
            // From the spec: inverted sections may render text once based on the
            // inverse value of the key. That is, they will be rendered if the key
            // doesn't exist, is false, or is an empty list.
            if (value == null || value === false || (isArray(value) && value.length === 0)) {
                buffer += callback();
            }
        } else if (isArray(value)) {
            forEach(value, function (value) {
                stack.push(value);
                buffer += callback();
                stack.pop();
            });
        } else if (typeof value === "object") {
            stack.push(value);
            buffer += callback();
            stack.pop();
        } else if (typeof value === "function") {
            var scope = stack[stack.length - 1];
            var scopedRender = function (template) {
                return render(template, scope);
            };
            buffer += value.call(scope, callback(), scopedRender) || "";
        } else if (value) {
            buffer += callback();
        }

        return buffer;
    }

    /**
     * Parses the given `template` and returns the source of a function that,
     * with the proper arguments, will render the template. Recognized options
     * include the following:
     *
     *   - file     The name of the file the template comes from (displayed in
     *              error messages)
     *   - tags     An array of open and close tags the `template` uses. Defaults
     *              to the value of Mustache.tags
     *   - debug    Set `true` to log the body of the generated function to the
     *              console
     *   - space    Set `true` to preserve whitespace from lines that otherwise
     *              contain only a {{tag}}. Defaults to `false`
     */
    function parse(template, options) {
        options = options || {};

        var tags = options.tags || exports.tags,
                openTag = tags[0],
                closeTag = tags[tags.length - 1];

        var code = [
            'var buffer = "";', // output buffer
            "\nvar line = 1;", // keep track of source line number
            "\ntry {",
            '\nbuffer += "'
        ];

        var spaces = [],      // indices of whitespace in code on the current line
                hasTag = false,   // is there a {{tag}} on the current line?
                nonSpace = false; // is there a non-space char on the current line?

        // Strips all space characters from the code array for the current line
        // if there was a {{tag}} on it and otherwise only spaces.
        var stripSpace = function () {
            if (hasTag && !nonSpace && !options.space) {
                while (spaces.length) {
                    code.splice(spaces.pop(), 1);
                }
            } else {
                spaces = [];
            }

            hasTag = false;
            nonSpace = false;
        };

        var sectionStack = [], updateLine, nextOpenTag, nextCloseTag;

        var setTags = function (source) {
            tags = trim(source).split(/\s+/);
            nextOpenTag = tags[0];
            nextCloseTag = tags[tags.length - 1];
        };

        var includePartial = function (source) {
            code.push(
                '";',
                updateLine,
                '\nvar partial = partials["' + trim(source) + '"];',
                '\nif (partial) {',
                '\n  buffer += render(partial,stack[stack.length - 1],partials);',
                '\n}',
                '\nbuffer += "'
            );
        };

        var openSection = function (source, inverted) {
            var name = trim(source);

            if (name === "") {
                throw debug(new Error("Section name may not be empty"), template, line, options.file);
            }

            sectionStack.push({name: name, inverted: inverted});

            code.push(
                '";',
                updateLine,
                '\nvar name = "' + name + '";',
                '\nvar callback = (function () {',
                '\n  return function () {',
                '\n    var buffer = "";',
                '\nbuffer += "'
            );
        };

        var openInvertedSection = function (source) {
            openSection(source, true);
        };

        var closeSection = function (source) {
            var name = trim(source);
            var openName = sectionStack.length != 0 && sectionStack[sectionStack.length - 1].name;

            if (!openName || name != openName) {
                throw debug(new Error('Section named "' + name + '" was never opened'), template, line, options.file);
            }

            var section = sectionStack.pop();

            code.push(
                '";',
                '\n    return buffer;',
                '\n  };',
                '\n})();'
            );

            if (section.inverted) {
                code.push("\nbuffer += renderSection(name,stack,callback,true);");
            } else {
                code.push("\nbuffer += renderSection(name,stack,callback);");
            }

            code.push('\nbuffer += "');
        };

        var sendPlain = function (source) {
            code.push(
                '";',
                updateLine,
                '\nbuffer += lookup("' + trim(source) + '",stack,"");',
                '\nbuffer += "'
            );
        };

        var sendEscaped = function (source) {
            code.push(
                '";',
                updateLine,
                '\nbuffer += escapeHTML(lookup("' + trim(source) + '",stack,""));',
                '\nbuffer += "'
            );
        };

        var line = 1, c, callback;
        for (var i = 0, len = template.length; i < len; ++i) {
            if (template.slice(i, i + openTag.length) === openTag) {
                i += openTag.length;
                c = template.substr(i, 1);
                updateLine = '\nline = ' + line + ';';
                nextOpenTag = openTag;
                nextCloseTag = closeTag;
                hasTag = true;

                switch (c) {
                case "!": // comment
                    i++;
                    callback = null;
                    break;
                case "=": // change open/close tags, e.g. {{=<% %>=}}
                    i++;
                    closeTag = "=" + closeTag;
                    callback = setTags;
                    break;
                case ">": // include partial
                    i++;
                    callback = includePartial;
                    break;
                case "#": // start section
                    i++;
                    callback = openSection;
                    break;
                case "^": // start inverted section
                    i++;
                    callback = openInvertedSection;
                    break;
                case "/": // end section
                    i++;
                    callback = closeSection;
                    break;
                case "{": // plain variable
                    closeTag = "}" + closeTag;
                    // fall through
                case "&": // plain variable
                    i++;
                    nonSpace = true;
                    callback = sendPlain;
                    break;
                default: // escaped variable
                    nonSpace = true;
                    callback = sendEscaped;
                }

                var end = template.indexOf(closeTag, i);

                if (end === -1) {
                    throw debug(new Error('Tag "' + openTag + '" was not closed properly'), template, line, options.file);
                }

                var source = template.substring(i, end);

                if (callback) {
                    callback(source);
                }

                // Maintain line count for \n in source.
                var n = 0;
                while (~(n = source.indexOf("\n", n))) {
                    line++;
                    n++;
                }

                i = end + closeTag.length - 1;
                openTag = nextOpenTag;
                closeTag = nextCloseTag;
            } else {
                c = template.substr(i, 1);

                switch (c) {
                case '"':
                case "\\":
                    nonSpace = true;
                    code.push("\\" + c);
                    break;
                case "\r":
                    // Ignore carriage returns.
                    break;
                case "\n":
                    spaces.push(code.length);
                    code.push("\\n");
                    stripSpace(); // Check for whitespace on the current line.
                    line++;
                    break;
                default:
                    if (isWhitespace(c)) {
                        spaces.push(code.length);
                    } else {
                        nonSpace = true;
                    }

                    code.push(c);
                }
            }
        }

        if (sectionStack.length != 0) {
            throw debug(new Error('Section "' + sectionStack[sectionStack.length - 1].name + '" was not closed properly'), template, line, options.file);
        }

        // Clean up any whitespace from a closing {{tag}} that was at the end
        // of the template without a trailing \n.
        stripSpace();

        code.push(
            '";',
            "\nreturn buffer;",
            "\n} catch (e) { throw {error: e, line: line}; }"
        );

        // Ignore `buffer += "";` statements.
        var body = code.join("").replace(/buffer \+= "";\n/g, "");

        if (options.debug) {
            if (typeof console != "undefined" && console.log) {
                console.log(body);
            } else if (typeof print === "function") {
                print(body);
            }
        }

        return body;
    }

    /**
     * Used by `compile` to generate a reusable function for the given `template`.
     */
    function _compile(template, options) {
        var args = "view,partials,stack,lookup,escapeHTML,renderSection,render";
        var body = parse(template, options);
        var fn = new Function(args, body);

        // This anonymous function wraps the generated function so we can do
        // argument coercion, setup some variables, and handle any errors
        // encountered while executing it.
        return function (view, partials) {
            partials = partials || {};

            var stack = [view]; // context stack

            try {
                return fn(view, partials, stack, lookup, escapeHTML, renderSection, render);
            } catch (e) {
                throw debug(e.error, template, e.line, options.file);
            }
        };
    }

    // Cache of pre-compiled templates.
    var _cache = {};

    /**
     * Clear the cache of compiled templates.
     */
    function clearCache() {
        _cache = {};
    }

    /**
     * Compiles the given `template` into a reusable function using the given
     * `options`. In addition to the options accepted by Mustache.parse,
     * recognized options include the following:
     *
     *   - cache    Set `false` to bypass any pre-compiled version of the given
     *              template. Otherwise, a given `template` string will be cached
     *              the first time it is parsed
     */
    function compile(template, options) {
        options = options || {};

        // Use a pre-compiled version from the cache if we have one.
        if (options.cache !== false) {
            if (!_cache[template]) {
                _cache[template] = _compile(template, options);
            }

            return _cache[template];
        }

        return _compile(template, options);
    }

    /**
     * High-level function that renders the given `template` using the given
     * `view` and `partials`. If you need to use any of the template options (see
     * `compile` above), you must compile in a separate step, and then call that
     * compiled function.
     */
    function render(template, view, partials) {
        return compile(template)(view, partials);
    }

})(Mustache);
; /* ************************ new file ************************ */
/*!
 * jQuery blockUI plugin
 * Version 2.33 (29-MAR-2010)
 * @requires jQuery v1.2.3 or later
 *
 * Examples at: http://malsup.com/jquery/block/
 * Copyright (c) 2007-2008 M. Alsup
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Thanks to Amir-Hossein Sobhi for some excellent contributions!
 */

;(function($) {

if (/1\.(0|1|2)\.(0|1|2)/.test($.fn.jquery) || /^1.1/.test($.fn.jquery)) {
	alert('blockUI requires jQuery v1.2.3 or later!  You are using v' + $.fn.jquery);
	return;
}

$.fn._fadeIn = $.fn.fadeIn;

var noOp = function() {};

// this bit is to ensure we don't call setExpression when we shouldn't (with extra muscle to handle
// retarded userAgent strings on Vista)
var mode = document.documentMode || 0;
var setExpr = $.browser.msie && (($.browser.version < 8 && !mode) || mode < 8);
var ie6 = $.browser.msie && /MSIE 6.0/.test(navigator.userAgent) && !mode;

// global $ methods for blocking/unblocking the entire page
$.blockUI   = function(opts) { install(window, opts); };
$.unblockUI = function(opts) { remove(window, opts); };

// convenience method for quick growl-like notifications  (http://www.google.com/search?q=growl)
$.growlUI = function(title, message, timeout, onClose) {
	var $m = $('<div class="growlUI"></div>');
	if (title) $m.append('<h1>'+title+'</h1>');
	if (message) $m.append('<h2>'+message+'</h2>');
	if (timeout == undefined) timeout = 3000;
	$.blockUI({
		message: $m, fadeIn: 700, fadeOut: 1000, centerY: false,
		timeout: timeout, showOverlay: false,
		onUnblock: onClose, 
		css: $.blockUI.defaults.growlCSS
	});
};

// plugin method for blocking element content
$.fn.block = function(opts) {
	return this.unblock({ fadeOut: 0 }).each(function() {
		if ($.css(this,'position') == 'static')
			this.style.position = 'relative';
		if ($.browser.msie)
			this.style.zoom = 1; // force 'hasLayout'
		install(this, opts);
	});
};

// plugin method for unblocking element content
$.fn.unblock = function(opts) {
	return this.each(function() {
		remove(this, opts);
	});
};

$.blockUI.version = 2.33; // 2nd generation blocking at no extra cost!

// override these in your code to change the default behavior and style
$.blockUI.defaults = {
	// message displayed when blocking (use null for no message)
	message:  '<h1>Please wait...</h1>',

	title: null,	  // title string; only used when theme == true
	draggable: true,  // only used when theme == true (requires jquery-ui.js to be loaded)
	
	theme: false, // set to true to use with jQuery UI themes
	
	// styles for the message when blocking; if you wish to disable
	// these and use an external stylesheet then do this in your code:
	// $.blockUI.defaults.css = {};
	css: {
		padding:	0,
		margin:		0,
		width:		'30%',
		top:		'40%',
		left:		'35%',
		textAlign:	'center',
		color:		'#000',
		border:		'3px solid #aaa',
		backgroundColor:'#fff',
		cursor:		'wait'
	},
	
	// minimal style set used when themes are used
	themedCSS: {
		width:	'30%',
		top:	'40%',
		left:	'35%'
	},

	// styles for the overlay
	overlayCSS:  {
		backgroundColor: '#000',
		opacity:	  	 0.6,
		cursor:		  	 'wait'
	},

	// styles applied when using $.growlUI
	growlCSS: {
		width:  	'350px',
		top:		'10px',
		left:   	'',
		right:  	'10px',
		border: 	'none',
		padding:	'5px',
		opacity:	0.6,
		cursor: 	'default',
		color:		'#fff',
		backgroundColor: '#000',
		'-webkit-border-radius': '10px',
		'-moz-border-radius':	 '10px',
		'border-radius': 		 '10px'
	},
	
	// IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w
	// (hat tip to Jorge H. N. de Vasconcelos)
	iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank',

	// force usage of iframe in non-IE browsers (handy for blocking applets)
	forceIframe: false,

	// z-index for the blocking overlay
	baseZ: 1000,

	// set these to true to have the message automatically centered
	centerX: true, // <-- only effects element blocking (page block controlled via css above)
	centerY: true,

	// allow body element to be stetched in ie6; this makes blocking look better
	// on "short" pages.  disable if you wish to prevent changes to the body height
	allowBodyStretch: true,

	// enable if you want key and mouse events to be disabled for content that is blocked
	bindEvents: true,

	// be default blockUI will supress tab navigation from leaving blocking content
	// (if bindEvents is true)
	constrainTabKey: true,

	// fadeIn time in millis; set to 0 to disable fadeIn on block
	fadeIn:  200,

	// fadeOut time in millis; set to 0 to disable fadeOut on unblock
	fadeOut:  400,

	// time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
	timeout: 0,

	// disable if you don't want to show the overlay
	showOverlay: true,

	// if true, focus will be placed in the first available input field when
	// page blocking
	focusInput: true,

	// suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
	applyPlatformOpacityRules: true,
	
	// callback method invoked when fadeIn has completed and blocking message is visible
	onBlock: null,

	// callback method invoked when unblocking has completed; the callback is
	// passed the element that has been unblocked (which is the window object for page
	// blocks) and the options that were passed to the unblock call:
	//	 onUnblock(element, options)
	onUnblock: null,

	// don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493
	quirksmodeOffsetHack: 4
};

// private data and functions follow...

var pageBlock = null;
var pageBlockEls = [];

function install(el, opts) {
	var full = (el == window);
	var msg = opts && opts.message !== undefined ? opts.message : undefined;
	opts = $.extend({}, $.blockUI.defaults, opts || {});
	opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
	var css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
	var themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
	msg = msg === undefined ? opts.message : msg;

	// remove the current block (if there is one)
	if (full && pageBlock)
		remove(window, {fadeOut:0});

	// if an existing element is being used as the blocking content then we capture
	// its current place in the DOM (and current display style) so we can restore
	// it when we unblock
	if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) {
		var node = msg.jquery ? msg[0] : msg;
		var data = {};
		$(el).data('blockUI.history', data);
		data.el = node;
		data.parent = node.parentNode;
		data.display = node.style.display;
		data.position = node.style.position;
		if (data.parent)
			data.parent.removeChild(node);
	}

	var z = opts.baseZ;

	// blockUI uses 3 layers for blocking, for simplicity they are all used on every platform;
	// layer1 is the iframe layer which is used to supress bleed through of underlying content
	// layer2 is the overlay layer which has opacity and a wait cursor (by default)
	// layer3 is the message content that is displayed while blocking

	var lyr1 = ($.browser.msie || opts.forceIframe) 
		? $('<iframe class="blockUI" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="'+opts.iframeSrc+'"></iframe>')
		: $('<div class="blockUI" style="display:none"></div>');
	var lyr2 = $('<div class="blockUI blockOverlay" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
	
	var lyr3, s;
	if (opts.theme && full) {
		s = '<div class="blockUI blockMsg blockPage ui-dialog ui-widget ui-corner-all" style="z-index:'+z+';display:none;position:fixed">' +
				'<div class="ui-widget-header ui-dialog-titlebar blockTitle">'+(opts.title || '&nbsp;')+'</div>' +
				'<div class="ui-widget-content ui-dialog-content"></div>' +
			'</div>';
	}
	else if (opts.theme) {
		s = '<div class="blockUI blockMsg blockElement ui-dialog ui-widget ui-corner-all" style="z-index:'+z+';display:none;position:absolute">' +
				'<div class="ui-widget-header ui-dialog-titlebar blockTitle">'+(opts.title || '&nbsp;')+'</div>' +
				'<div class="ui-widget-content ui-dialog-content"></div>' +
			'</div>';
	}
	else if (full) {
		s = '<div class="blockUI blockMsg blockPage" style="z-index:'+z+';display:none;position:fixed"></div>';
	}			
	else {
		s = '<div class="blockUI blockMsg blockElement" style="z-index:'+z+';display:none;position:absolute"></div>';
	}
	lyr3 = $(s);

	// if we have a message, style it
	if (msg) {
		if (opts.theme) {
			lyr3.css(themedCSS);
			lyr3.addClass('ui-widget-content');
		}
		else 
			lyr3.css(css);
	}

	// style the overlay
	if (!opts.applyPlatformOpacityRules || !($.browser.mozilla && /Linux/.test(navigator.platform)))
		lyr2.css(opts.overlayCSS);
	lyr2.css('position', full ? 'fixed' : 'absolute');

	// make iframe layer transparent in IE
	if ($.browser.msie || opts.forceIframe)
		lyr1.css('opacity',0.0);

	//$([lyr1[0],lyr2[0],lyr3[0]]).appendTo(full ? 'body' : el);
	var layers = [lyr1,lyr2,lyr3], $par = full ? $('body') : $(el);
	$.each(layers, function() {
		this.appendTo($par);
	});
	
	if (opts.theme && opts.draggable && $.fn.draggable) {
		lyr3.draggable({
			handle: '.ui-dialog-titlebar',
			cancel: 'li'
		});
	}

	// ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling)
	var expr = setExpr && (!$.boxModel || $('object,embed', full ? null : el).length > 0);
	if (ie6 || expr) {
		// give body 100% height
		if (full && opts.allowBodyStretch && $.boxModel)
			$('html,body').css('height','100%');

		// fix ie6 issue when blocked element has a border width
		if ((ie6 || !$.boxModel) && !full) {
			var t = sz(el,'borderTopWidth'), l = sz(el,'borderLeftWidth');
			var fixT = t ? '(0 - '+t+')' : 0;
			var fixL = l ? '(0 - '+l+')' : 0;
		}

		// simulate fixed position
		$.each([lyr1,lyr2,lyr3], function(i,o) {
			var s = o[0].style;
			s.position = 'absolute';
			if (i < 2) {
				full ? s.setExpression('height','Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.boxModel?0:'+opts.quirksmodeOffsetHack+') + "px"')
					 : s.setExpression('height','this.parentNode.offsetHeight + "px"');
				full ? s.setExpression('width','jQuery.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"')
					 : s.setExpression('width','this.parentNode.offsetWidth + "px"');
				if (fixL) s.setExpression('left', fixL);
				if (fixT) s.setExpression('top', fixT);
			}
			else if (opts.centerY) {
				if (full) s.setExpression('top','(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
				s.marginTop = 0;
			}
			else if (!opts.centerY && full) {
				var top = (opts.css && opts.css.top) ? parseInt(opts.css.top) : 0;
				var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + '+top+') + "px"';
				s.setExpression('top',expression);
			}
		});
	}

	// show the message
	if (msg) {
		if (opts.theme)
			lyr3.find('.ui-widget-content').append(msg);
		else
			lyr3.append(msg);
		if (msg.jquery || msg.nodeType)
			$(msg).show();
	}

	if (($.browser.msie || opts.forceIframe) && opts.showOverlay)
		lyr1.show(); // opacity is zero
	if (opts.fadeIn) {
		var cb = opts.onBlock ? opts.onBlock : noOp;
		var cb1 = (opts.showOverlay && !msg) ? cb : noOp;
		var cb2 = msg ? cb : noOp;
		if (opts.showOverlay)
			lyr2._fadeIn(opts.fadeIn, cb1);
		if (msg)
			lyr3._fadeIn(opts.fadeIn, cb2);
	}
	else {
		if (opts.showOverlay)
			lyr2.show();
		if (msg)
			lyr3.show();
		if (opts.onBlock)
			opts.onBlock();
	}

	// bind key and mouse events
	bind(1, el, opts);

	if (full) {
		pageBlock = lyr3[0];
		pageBlockEls = $(':input:enabled:visible',pageBlock);
		if (opts.focusInput)
			setTimeout(focus, 20);
	}
	else
		center(lyr3[0], opts.centerX, opts.centerY);

	if (opts.timeout) {
		// auto-unblock
		var to = setTimeout(function() {
			full ? $.unblockUI(opts) : $(el).unblock(opts);
		}, opts.timeout);
		$(el).data('blockUI.timeout', to);
	}
};

// remove the block
function remove(el, opts) {
	var full = (el == window);
	var $el = $(el);
	var data = $el.data('blockUI.history');
	var to = $el.data('blockUI.timeout');
	if (to) {
		clearTimeout(to);
		$el.removeData('blockUI.timeout');
	}
	opts = $.extend({}, $.blockUI.defaults, opts || {});
	bind(0, el, opts); // unbind events
	
	var els;
	if (full) // crazy selector to handle odd field errors in ie6/7
		els = $('body').children().filter('.blockUI').add('body > .blockUI');
	else
		els = $('.blockUI', el);

	if (full)
		pageBlock = pageBlockEls = null;

	if (opts.fadeOut) {
		els.fadeOut(opts.fadeOut);
		setTimeout(function() { reset(els,data,opts,el); }, opts.fadeOut);
	}
	else
		reset(els, data, opts, el);
};

// move blocking element back into the DOM where it started
function reset(els,data,opts,el) {
	els.each(function(i,o) {
		// remove via DOM calls so we don't lose event handlers
		if (this.parentNode)
			this.parentNode.removeChild(this);
	});

	if (data && data.el) {
		data.el.style.display = data.display;
		data.el.style.position = data.position;
		if (data.parent)
			data.parent.appendChild(data.el);
		$(el).removeData('blockUI.history');
	}

	if (typeof opts.onUnblock == 'function')
		opts.onUnblock(el,opts);
};

// bind/unbind the handler
function bind(b, el, opts) {
	var full = el == window, $el = $(el);

	// don't bother unbinding if there is nothing to unbind
	if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked')))
		return;
	if (!full)
		$el.data('blockUI.isBlocked', b);

	// don't bind events when overlay is not in use or if bindEvents is false
	if (!opts.bindEvents || (b && !opts.showOverlay)) 
		return;

	// bind anchors and inputs for mouse and key events
	var events = 'mousedown mouseup keydown keypress';
	b ? $(document).bind(events, opts, handler) : $(document).unbind(events, handler);

// former impl...
//	   var $e = $('a,:input');
//	   b ? $e.bind(events, opts, handler) : $e.unbind(events, handler);
};

// event handler to suppress keyboard/mouse events when blocking
function handler(e) {
	// allow tab navigation (conditionally)
	if (e.keyCode && e.keyCode == 9) {
		if (pageBlock && e.data.constrainTabKey) {
			var els = pageBlockEls;
			var fwd = !e.shiftKey && e.target == els[els.length-1];
			var back = e.shiftKey && e.target == els[0];
			if (fwd || back) {
				setTimeout(function(){focus(back)},10);
				return false;
			}
		}
	}
	// allow events within the message content
	if ($(e.target).parents('div.blockMsg').length > 0)
		return true;

	// allow events for content that is not being blocked
	return $(e.target).parents().children().filter('div.blockUI').length == 0;
};

function focus(back) {
	if (!pageBlockEls)
		return;
	var e = pageBlockEls[back===true ? pageBlockEls.length-1 : 0];
	if (e)
		e.focus();
};

function center(el, x, y) {
	var p = el.parentNode, s = el.style;
	var l = ((p.offsetWidth - el.offsetWidth)/2) - sz(p,'borderLeftWidth');
	var t = ((p.offsetHeight - el.offsetHeight)/2) - sz(p,'borderTopWidth');
	if (x) s.left = l > 0 ? (l+'px') : '0';
	if (y) s.top  = t > 0 ? (t+'px') : '0';
};

function sz(el, p) {
	return parseInt($.css(el,p))||0;
};

})(jQuery);

; /* ************************ new file ************************ */
/******************************************************************************
 * jquery.i18n.properties
 * 
 * Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and 
 * MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
 * 
 * @version     1.0.x
 * @author      Nuno Fernandes
 * @url         www.codingwithcoffee.com
 * @inspiration Localisation assistance for jQuery (http://keith-wood.name/localisation.html)
 *              by Keith Wood (kbwood{at}iinet.com.au) June 2007
 * 
 *****************************************************************************/

(function($) {
$.i18n = {};

/** Map holding bundle keys (if mode: 'map') */
$.i18n.map = {};

/**
 * Load and parse message bundle files (.properties),
 * making bundles keys available as javascript variables.
 * 
 * i18n files are named <name>.js, or <name>_<language>.js or <name>_<language>_<country>.js
 * Where:
 *      The <language> argument is a valid ISO Language Code. These codes are the lower-case, 
 *      two-letter codes as defined by ISO-639. You can find a full list of these codes at a 
 *      number of sites, such as: http://www.loc.gov/standards/iso639-2/englangn.html
 *      The <country> argument is a valid ISO Country Code. These codes are the upper-case,
 *      two-letter codes as defined by ISO-3166. You can find a full list of these codes at a
 *      number of sites, such as: http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html
 * 
 * Sample usage for a bundles/Messages.properties bundle:
 * $.i18n.properties({
 *      name:      'Messages', 
 *      language:  'en_US',
 *      path:      'bundles'
 * });
 * @param  name         (string/string[], required) names of file to load (eg, 'Messages' or ['Msg1','Msg2'])
 * @param  language     (string, optional) language/country code (eg, 'en', 'en_US', 'pt_PT'). if not specified, language reported by the browser will be used instead.
 * @param  path         (string, optional) path of directory that contains file to load
 * @param  mode         (string, optional) whether bundles keys are available as JavaScript variables/functions or as a map (eg, 'vars' or 'map')
 * @param  callback     (function, optional) callback function to be called after script is terminated
 */
$.i18n.properties = function(settings) {
    // set up settings
        var defaults = {
                name:           'Messages',
                language:       '',
                path:           '',  
                mode:           'vars',       
                callback:       function(){}
        };
        settings = $.extend(defaults, settings);    
        if(settings.language === null || settings.language == '') {
         settings.language = $.i18n.browserLang();//normaliseLanguageCode(navigator.language /* Mozilla */ || navigator.userLanguage /* IE */);
    }
    if(settings.language === null) {settings.language='';}
    
    // load and parse bundle files
    var files = getFiles(settings.name);
    for(i=0; i<files.length; i++) {
        // 1. load base (eg, Messages.properties)
        loadAndParseFile(settings.path + files[i] + '.properties', settings.language, settings.mode);
                // 2. with language code (eg, Messages_pt.properties)
        if(settings.language.length >= 2) {
                        loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 2) +'.properties', settings.language, settings.mode);
        }
        // 3. with language code and country code (eg, Messages_pt_PT.properties)
                if(settings.language.length >= 5) {
                        loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 5) +'.properties', settings.language, settings.mode);
                }
    }
    
    // call callback
    if(settings.callback){ settings.callback(); }
};


/**
 * When configured with mode: 'map', allows access to bundle values by specifying its key.
 * Eg, jQuery.i18n.prop('com.company.bundles.menu_add')
 */
$.i18n.prop = function(key, placeHolderValues) {
    var value = $.i18n.map[key];
    if(value == null) { return '[' + key + ']'; }
    if(!placeHolderValues) {
        //if(key == 'spv.lbl.modified') {alert(value);}
        return value;
    }else{
        for(var i=0; i<placeHolderValues.length; i++) {
            var regexp = new RegExp('\\{('+i+')\\}', "g");
            value = value.replace(regexp, placeHolderValues[i]);
        }
        return value;
    }
};

/** Language reported by browser, normalized code */
$.i18n.browserLang = function() {
    return normaliseLanguageCode(navigator.language /* Mozilla */ || navigator.userLanguage /* IE */);
}


/** Load and parse .properties files */
function loadAndParseFile(filename, language, mode) {
        $.ajax({
                url:        filename,
                async:      false,
                contentType: "text/plain;charset=UTF-8",
                dataType:   'text',
                success:    function(data, status) {
                                             var parsed = '';
                                             var parameters = data.split( /\n/ );
                                             var regPlaceHolder = /(\{\d+\})/g;
                                             var regRepPlaceHolder = /\{(\d+)\}/g;
                                             var unicodeRE = /(\\u.{4})/ig;
                                             for(var i=0; i<parameters.length; i++ ) {
                                                     parameters[i] = parameters[i].replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
                                                     if(parameters[i].length > 0 && parameters[i].match("^#")!="#") { // skip comments
                                                             var pair = parameters[i].split('=');
                                                             if(pair.length > 0) {
                                                                     /** Process key & value */
                                                                     var name = unescape(pair[0]).replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
                                                                     var value = pair.length == 1 ? "" : pair[1];
                                                                     for(var s=2;s<pair.length;s++){ value +='=' + pair[s]; }
                                                                     value = value.replace( /"/g, '\\"' ); // escape quotation mark (")
                                                                     value = value.replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim  
                                                                     
                                                                     /** Mode: bundle keys in a map */
                                                                     if(mode == 'map' || mode == 'both') {
                                                                             // handle unicode chars possibly left out
                                                                             var unicodeMatches = value.match(unicodeRE);
                                                                             if(unicodeMatches) {
                                                                                 for(var u=0; u<unicodeMatches.length; u++) {
                                                                                        value = value.replace( unicodeMatches[u], unescapeUnicode(unicodeMatches[u]));
                                                                                 }
                                                                             }
                                                                             // add to map
                                                                             $.i18n.map[name] = value;
                                                                     }
                                                                     
                                                                     /** Mode: bundle keys as vars/functions */
                                                                     if(mode == 'vars' || mode == 'both') {
                                                                             // make sure namespaced key exists (eg, 'some.key') 
                                                                             checkKeyNamespace(name);
                                                                             
                                                                             // value with variable substitutions
                                                                             if(regPlaceHolder.test(value)) {
                                                                                     var parts = value.split(regPlaceHolder);
                                                                                     // process function args
                                                                                     var first = true;
                                                                                     var fnArgs = '';
                                                                                     var usedArgs = [];
                                                                                     for(var p=0; p<parts.length; p++) {
                                                                                             if(regPlaceHolder.test(parts[p]) && usedArgs.indexOf(parts[p]) == -1) {
                                                                                                     if(!first) {fnArgs += ',';}
                                                                                                     fnArgs += parts[p].replace(regRepPlaceHolder, 'v$1');
                                                                                                     usedArgs.push(parts[p]);
                                                                                                     first = false;
                                                                                             }
                                                                                     }
                                                                                     parsed += name + '=function(' + fnArgs + '){';
                                                                                     // process function body
                                                                                     var fnExpr = '"' + value.replace(regRepPlaceHolder, '"+v$1+"') + '"';
                                                                                     parsed += 'return ' + fnExpr + ';' + '};';
                                                                                     
                                                                             // simple value
                                                                             }else{
                                                                                     parsed += name+'="'+value+'";';
                                                                             }
                                                                     }
                                                             }
                                                     }
                                             }
                                             eval(parsed);
                                     }
        });
}

/** Make sure namespace exists (for keys with dots in name) */
function checkKeyNamespace(key) {
    var regDot = /\./;
    if(regDot.test(key)) {
        var fullname = '';
        var names = key.split( /\./ );
        for(var i=0; i<names.length; i++) {
            if(i>0) {fullname += '.';}
            fullname += names[i];
            if(eval('typeof '+fullname+' == "undefined"')) {
                eval(fullname + '={};');
            }
        }
    }
}

/** Make sure filename is an array */
function getFiles(names) {
    return (names && names.constructor == Array) ? names : [names];
}

/** Ensure language code is in the format aa_AA. */
function normaliseLanguageCode(lang) {
        lang = lang.toLowerCase();
        if(lang.length > 3) {
                lang = lang.substring(0, 3) + lang.substring(3).toUpperCase();
        }
        return lang;
}

/** Unescape unicode chars ('\u00e3') */
function unescapeUnicode(str) {
    // unescape unicode codes
    var codes = [];
    var code = parseInt(str.substr(2), 16);
    if (code >= 0 && code < Math.pow(2, 16)) {
         codes.push(code);
    }
    // convert codes to text
    var unescaped = '';
    for (var i = 0; i < codes.length; ++i) {
        unescaped += String.fromCharCode(codes[i]);
    }
    return unescaped;
}

})(jQuery);
; /* ************************ new file ************************ */
/**
*
* jquery.sparkline.js
*
* v2.1
* (c) Splunk, Inc
* Contact: Gareth Watts (gareth@splunk.com)
* http://omnipotent.net/jquery.sparkline/
*
* Generates inline sparkline charts from data supplied either to the method
* or inline in HTML
*
* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag
* (Firefox 2.0+, Safari, Opera, etc)
*
* License: New BSD License
*
* Copyright (c) 2012, Splunk Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright notice,
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright notice,
*       this list of conditions and the following disclaimer in the documentation
*       and/or other materials provided with the distribution.
*     * Neither the name of Splunk Inc nor the names of its contributors may
*       be used to endorse or promote products derived from this software without
*       specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*
* Usage:
*  $(selector).sparkline(values, options)
*
* If values is undefined or set to 'html' then the data values are read from the specified tag:
*   <p>Sparkline: <span class="sparkline">1,4,6,6,8,5,3,5</span></p>
*   $('.sparkline').sparkline();
* There must be no spaces in the enclosed data set
*
* Otherwise values must be an array of numbers or null values
*    <p>Sparkline: <span id="sparkline1">This text replaced if the browser is compatible</span></p>
*    $('#sparkline1').sparkline([1,4,6,6,8,5,3,5])
*    $('#sparkline2').sparkline([1,4,6,null,null,5,3,5])
*
* Values can also be specified in an HTML comment, or as a values attribute:
*    <p>Sparkline: <span class="sparkline"><!--1,4,6,6,8,5,3,5 --></span></p>
*    <p>Sparkline: <span class="sparkline" values="1,4,6,6,8,5,3,5"></span></p>
*    $('.sparkline').sparkline();
*
* For line charts, x values can also be specified:
*   <p>Sparkline: <span class="sparkline">1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5</span></p>
*    $('#sparkline1').sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])
*
* By default, options should be passed in as teh second argument to the sparkline function:
*   $('.sparkline').sparkline([1,2,3,4], {type: 'bar'})
*
* Options can also be set by passing them on the tag itself.  This feature is disabled by default though
* as there's a slight performance overhead:
*   $('.sparkline').sparkline([1,2,3,4], {enableTagOptions: true})
*   <p>Sparkline: <span class="sparkline" sparkType="bar" sparkBarColor="red">loading</span></p>
* Prefix all options supplied as tag attribute with "spark" (configurable by setting tagOptionPrefix)
*
* Supported options:
*   lineColor - Color of the line used for the chart
*   fillColor - Color used to fill in the chart - Set to '' or false for a transparent chart
*   width - Width of the chart - Defaults to 3 times the number of values in pixels
*   height - Height of the chart - Defaults to the height of the containing element
*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied
*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied
*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax
*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied
*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied
*   composite - If true then don't erase any existing chart attached to the tag, but draw
*           another chart over the top - Note that width and height are ignored if an
*           existing chart is detected.
*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to 'values'
*   enableTagOptions - Whether to check tags for sparkline options
*   tagOptionPrefix - Prefix used for options supplied as tag attributes - Defaults to 'spark'
*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a
*           hidden dom element, avoding a browser reflow
*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,
*       making the plugin perform much like it did in 1.x
*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)
*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled
*       defaults to false (highlights enabled)
*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase
*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body
*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied
*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis
*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis
*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip
*       callback is given arguments of (sparkline, options, fields)
*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title
*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)
*       to control the format of the tooltip
*   tooltipPrefix - A string to prepend to each field displayed in a tooltip
*   tooltipSuffix - A string to append to each field displayed in a tooltip
*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)
*   tooltipValueLookups - An object or range map to map field values to tooltip strings
*       (eg. to map -1 to "Lost", 0 to "Draw", and 1 to "Win")
*   numberFormatter - Optional callback for formatting numbers in tooltips
*   numberDigitGroupSep - Character to use for group separator in numbers "1,234" - Defaults to ","
*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to "."
*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3
*
* There are 7 types of sparkline, selected by supplying a "type" option of 'line' (default),
* 'bar', 'tristate', 'bullet', 'discrete', 'pie' or 'box'
*    line - Line chart.  Options:
*       spotColor - Set to '' to not end each line in a circular spot
*       minSpotColor - If set, color of spot at minimum value
*       maxSpotColor - If set, color of spot at maximum value
*       spotRadius - Radius in pixels
*       lineWidth - Width of line in pixels
*       normalRangeMin
*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the "normal"
*                      or expected range of values
*       normalRangeColor - Color to use for the above bar
*       drawNormalOnTop - Draw the normal range above the chart fill color if true
*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart
*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable
*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable
*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map
*
*   bar - Bar chart.  Options:
*       barColor - Color of bars for postive values
*       negBarColor - Color of bars for negative values
*       zeroColor - Color of bars with zero values
*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely
*       barWidth - Width of bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*       barSpacing - Gap between bars in pixels
*       zeroAxis - Centers the y-axis around zero if true
*
*   tristate - Charts values of win (>0), lose (<0) or draw (=0)
*       posBarColor - Color of win values
*       negBarColor - Color of lose values
*       zeroBarColor - Color of draw values
*       barWidth - Width of bars in pixels
*       barSpacing - Gap between bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*
*   discrete - Options:
*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height
*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor
*       thresholdColor
*
*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...
*       options:
*       targetColor - The color of the vertical target marker
*       targetWidth - The width of the target marker in pixels
*       performanceColor - The color of the performance measure horizontal bar
*       rangeColors - Colors to use for each qualitative range background color
*
*   pie - Pie chart. Options:
*       sliceColors - An array of colors to use for pie slices
*       offset - Angle in degrees to offset the first slice - Try -90 or +90
*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)
*       borderColor - Color to use for the pie chart border - Defaults to #000
*
*   box - Box plot. Options:
*       raw - Set to true to supply pre-computed plot points as values
*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier
*             When set to false you can supply any number of values and the box plot will
*             be computed for you.  Default is false.
*       showOutliers - Set to true (default) to display outliers as circles
*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5
*       boxLineColor - Outline color of the box
*       boxFillColor - Fill color for the box
*       whiskerColor - Line color used for whiskers
*       outlierLineColor - Outline color of outlier circles
*       outlierFillColor - Fill color of the outlier circles
*       spotRadius - Radius of outlier circles
*       medianColor - Line color of the median line
*       target - Draw a target cross hair at the supplied value (default undefined)
*
*
*
*   Examples:
*   $('#sparkline1').sparkline(myvalues, { lineColor: '#f00', fillColor: false });
*   $('.barsparks').sparkline('html', { type:'bar', height:'40px', barWidth:5 });
*   $('#tristate').sparkline([1,1,-1,1,0,0,-1], { type:'tristate' }):
*   $('#discrete').sparkline([1,3,4,5,5,3,4,5], { type:'discrete' });
*   $('#bullet').sparkline([10,12,12,9,7], { type:'bullet' });
*   $('#pie').sparkline([1,1,2], { type:'pie' });
*/

/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */

(function(factory) {
    if(typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	}
	else {
		factory(jQuery);
	}
}
(function($) {
    'use strict';

    var UNSET_OPTION = {},
        getDefaults, createClass, SPFormat, clipval, quartile, normalizeValue, normalizeValues,
        remove, isNumber, all, sum, addCSS, ensureArray, formatNumber, RangeMap,
        MouseHandler, Tooltip, barHighlightMixin,
        line, bar, tristate, discrete, bullet, pie, box, defaultStyles, initStyles,
         VShape, VCanvas_base, VCanvas_canvas, VCanvas_vml, pending, shapeCount = 0;

    /**
     * Default configuration settings
     */
    getDefaults = function () {
        return {
            // Settings common to most/all chart types
            common: {
                type: 'line',
                lineColor: '#00f',
                fillColor: '#cdf',
                defaultPixelsPerValue: 3,
                width: 'auto',
                height: 'auto',
                composite: false,
                tagValuesAttribute: 'values',
                tagOptionsPrefix: 'spark',
                enableTagOptions: false,
                enableHighlight: true,
                highlightLighten: 1.4,
                tooltipSkipNull: true,
                tooltipPrefix: '',
                tooltipSuffix: '',
                disableHiddenCheck: false,
                numberFormatter: false,
                numberDigitGroupCount: 3,
                numberDigitGroupSep: ',',
                numberDecimalMark: '.',
                disableTooltips: false,
                disableInteraction: false
            },
            // Defaults for line charts
            line: {
                spotColor: '#f80',
                highlightSpotColor: '#5f5',
                highlightLineColor: '#f22',
                spotRadius: 1.5,
                minSpotColor: '#f80',
                maxSpotColor: '#f80',
                lineWidth: 1,
                normalRangeMin: undefined,
                normalRangeMax: undefined,
                normalRangeColor: '#ccc',
                drawNormalOnTop: false,
                chartRangeMin: undefined,
                chartRangeMax: undefined,
                chartRangeMinX: undefined,
                chartRangeMaxX: undefined,
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{y}}{{suffix}}')
            },
            // Defaults for bar charts
            bar: {
                barColor: '#3366cc',
                negBarColor: '#f44',
                stackedBarColor: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00',
                    '#dd4477', '#0099c6', '#990099'],
                zeroColor: undefined,
                nullColor: undefined,
                zeroAxis: true,
                barWidth: 4,
                barSpacing: 1,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: false,
                colorMap: undefined,
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{value}}{{suffix}}')
            },
            // Defaults for tristate charts
            tristate: {
                barWidth: 4,
                barSpacing: 1,
                posBarColor: '#6f6',
                negBarColor: '#f44',
                zeroBarColor: '#999',
                colorMap: {},
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value:map}}'),
                tooltipValueLookups: { map: { '-1': 'Loss', '0': 'Draw', '1': 'Win' } }
            },
            // Defaults for discrete charts
            discrete: {
                lineHeight: 'auto',
                thresholdColor: undefined,
                thresholdValue: 0,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: false,
                tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')
            },
            // Defaults for bullet charts
            bullet: {
                targetColor: '#f33',
                targetWidth: 3, // width of the target bar in pixels
                performanceColor: '#33f',
                rangeColors: ['#d3dafe', '#a8b6ff', '#7f94ff'],
                base: undefined, // set this to a number to change the base start number
                tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),
                tooltipValueLookups: { fields: {r: 'Range', p: 'Performance', t: 'Target'} }
            },
            // Defaults for pie charts
            pie: {
                offset: 0,
                sliceColors: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00',
                    '#dd4477', '#0099c6', '#990099'],
                borderWidth: 0,
                borderColor: '#000',
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value}} ({{percent.1}}%)')
            },
            // Defaults for box plots
            box: {
                raw: false,
                boxLineColor: '#000',
                boxFillColor: '#cdf',
                whiskerColor: '#000',
                outlierLineColor: '#333',
                outlierFillColor: '#fff',
                medianColor: '#f00',
                showOutliers: true,
                outlierIQR: 1.5,
                spotRadius: 1.5,
                target: undefined,
                targetColor: '#4a2',
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),
                tooltipFormatFieldlistKey: 'field',
                tooltipValueLookups: { fields: { lq: 'Lower Quartile', med: 'Median',
                    uq: 'Upper Quartile', lo: 'Left Outlier', ro: 'Right Outlier',
                    lw: 'Left Whisker', rw: 'Right Whisker'} }
            }
        };
    };

    // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname
    defaultStyles = '.jqstooltip { ' +
            'position: absolute;' +
            'left: 0px;' +
            'top: 0px;' +
            'visibility: hidden;' +
            'background: rgb(0, 0, 0) transparent;' +
            'background-color: rgba(0,0,0,0.6);' +
            'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);' +
            '-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)";' +
            'color: white;' +
            'font: 10px arial, san serif;' +
            'text-align: left;' +
            'white-space: nowrap;' +
            'padding: 5px;' +
            'border: 1px solid white;' +
            'z-index: 10000;' +
            '}' +
            '.jqsfield { ' +
            'color: white;' +
            'font: 10px arial, san serif;' +
            'text-align: left;' +
            '}';

    /**
     * Utilities
     */

    createClass = function (/* [baseclass, [mixin, ...]], definition */) {
        var Class, args;
        Class = function () {
            this.init.apply(this, arguments);
        };
        if (arguments.length > 1) {
            if (arguments[0]) {
                Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);
                Class._super = arguments[0].prototype;
            } else {
                Class.prototype = arguments[arguments.length - 1];
            }
            if (arguments.length > 2) {
                args = Array.prototype.slice.call(arguments, 1, -1);
                args.unshift(Class.prototype);
                $.extend.apply($, args);
            }
        } else {
            Class.prototype = arguments[0];
        }
        Class.prototype.cls = Class;
        return Class;
    };

    /**
     * Wraps a format string for tooltips
     * {{x}}
     * {{x.2}
     * {{x:months}}
     */
    $.SPFormatClass = SPFormat = createClass({
        fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g,
        precre: /(\w+)\.(\d+)/,

        init: function (format, fclass) {
            this.format = format;
            this.fclass = fclass;
        },

        render: function (fieldset, lookups, options) {
            var self = this,
                fields = fieldset,
                match, token, lookupkey, fieldvalue, prec;
            return this.format.replace(this.fre, function () {
                var lookup;
                token = arguments[1];
                lookupkey = arguments[3];
                match = self.precre.exec(token);
                if (match) {
                    prec = match[2];
                    token = match[1];
                } else {
                    prec = false;
                }
                fieldvalue = fields[token];
                if (fieldvalue === undefined) {
                    return '';
                }
                if (lookupkey && lookups && lookups[lookupkey]) {
                    lookup = lookups[lookupkey];
                    if (lookup.get) { // RangeMap
                        return lookups[lookupkey].get(fieldvalue) || fieldvalue;
                    } else {
                        return lookups[lookupkey][fieldvalue] || fieldvalue;
                    }
                }
                if (isNumber(fieldvalue)) {
                    if (options.get('numberFormatter')) {
                        fieldvalue = options.get('numberFormatter')(fieldvalue);
                    } else {
                        fieldvalue = formatNumber(fieldvalue, prec,
                            options.get('numberDigitGroupCount'),
                            options.get('numberDigitGroupSep'),
                            options.get('numberDecimalMark'));
                    }
                }
                return fieldvalue;
            });
        }
    });

    // convience method to avoid needing the new operator
    $.spformat = function(format, fclass) {
        return new SPFormat(format, fclass);
    };

    clipval = function (val, min, max) {
        if (val < min) {
            return min;
        }
        if (val > max) {
            return max;
        }
        return val;
    };

    quartile = function (values, q) {
        var vl;
        if (q === 2) {
            vl = Math.floor(values.length / 2);
            return values.length % 2 ? values[vl] : (values[vl-1] + values[vl]) / 2;
        } else {
            if (values.length % 2 ) { // odd
                vl = (values.length * q + q) / 4;
                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl-1];
            } else { //even
                vl = (values.length * q + 2) / 4;
                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 :  values[vl-1];

            }
        }
    };

    normalizeValue = function (val) {
        var nf;
        switch (val) {
            case 'undefined':
                val = undefined;
                break;
            case 'null':
                val = null;
                break;
            case 'true':
                val = true;
                break;
            case 'false':
                val = false;
                break;
            default:
                nf = parseFloat(val);
                if (val == nf) {
                    val = nf;
                }
        }
        return val;
    };

    normalizeValues = function (vals) {
        var i, result = [];
        for (i = vals.length; i--;) {
            result[i] = normalizeValue(vals[i]);
        }
        return result;
    };

    remove = function (vals, filter) {
        var i, vl, result = [];
        for (i = 0, vl = vals.length; i < vl; i++) {
            if (vals[i] !== filter) {
                result.push(vals[i]);
            }
        }
        return result;
    };

    isNumber = function (num) {
        return !isNaN(parseFloat(num)) && isFinite(num);
    };

    formatNumber = function (num, prec, groupsize, groupsep, decsep) {
        var p, i;
        num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');
        p = (p = $.inArray('.', num)) < 0 ? num.length : p;
        if (p < num.length) {
            num[p] = decsep;
        }
        for (i = p - groupsize; i > 0; i -= groupsize) {
            num.splice(i, 0, groupsep);
        }
        return num.join('');
    };

    // determine if all values of an array match a value
    // returns true if the array is empty
    all = function (val, arr, ignoreNull) {
        var i;
        for (i = arr.length; i--; ) {
            if (ignoreNull && arr[i] === null) continue;
            if (arr[i] !== val) {
                return false;
            }
        }
        return true;
    };

    // sums the numeric values in an array, ignoring other values
    sum = function (vals) {
        var total = 0, i;
        for (i = vals.length; i--;) {
            total += typeof vals[i] === 'number' ? vals[i] : 0;
        }
        return total;
    };

    ensureArray = function (val) {
        return $.isArray(val) ? val : [val];
    };

    // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/
    addCSS = function(css) {
        var tag;
        //if ('\v' == 'v') /* ie only */ {
        if (document.createStyleSheet) {
            document.createStyleSheet().cssText = css;
        } else {
            tag = document.createElement('style');
            tag.type = 'text/css';
            document.getElementsByTagName('head')[0].appendChild(tag);
            tag[(typeof document.body.style.WebkitAppearance == 'string') /* webkit only */ ? 'innerText' : 'innerHTML'] = css;
        }
    };

    // Provide a cross-browser interface to a few simple drawing primitives
    $.fn.simpledraw = function (width, height, useExisting, interact) {
        var target, mhandler;
        if (useExisting && (target = this.data('_jqs_vcanvas'))) {
            return target;
        }
        if (width === undefined) {
            width = $(this).innerWidth();
        }
        if (height === undefined) {
            height = $(this).innerHeight();
        }
        if ($.browser.hasCanvas) {
            target = new VCanvas_canvas(width, height, this, interact);
        } else if ($.browser.msie) {
            target = new VCanvas_vml(width, height, this);
        } else {
            return false;
        }
        mhandler = $(this).data('_jqs_mhandler');
        if (mhandler) {
            mhandler.registerCanvas(target);
        }
        return target;
    };

    $.fn.cleardraw = function () {
        var target = this.data('_jqs_vcanvas');
        if (target) {
            target.reset();
        }
    };

    $.RangeMapClass = RangeMap = createClass({
        init: function (map) {
            var key, range, rangelist = [];
            for (key in map) {
                if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {
                    range = key.split(':');
                    range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);
                    range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);
                    range[2] = map[key];
                    rangelist.push(range);
                }
            }
            this.map = map;
            this.rangelist = rangelist || false;
        },

        get: function (value) {
            var rangelist = this.rangelist,
                i, range, result;
            if ((result = this.map[value]) !== undefined) {
                return result;
            }
            if (rangelist) {
                for (i = rangelist.length; i--;) {
                    range = rangelist[i];
                    if (range[0] <= value && range[1] >= value) {
                        return range[2];
                    }
                }
            }
            return undefined;
        }
    });

    // Convenience function
    $.range_map = function(map) {
        return new RangeMap(map);
    };

    MouseHandler = createClass({
        init: function (el, options) {
            var $el = $(el);
            this.$el = $el;
            this.options = options;
            this.currentPageX = 0;
            this.currentPageY = 0;
            this.el = el;
            this.splist = [];
            this.tooltip = null;
            this.over = false;
            this.displayTooltips = !options.get('disableTooltips');
            this.highlightEnabled = !options.get('disableHighlight');
        },

        registerSparkline: function (sp) {
            this.splist.push(sp);
            if (this.over) {
                this.updateDisplay();
            }
        },

        registerCanvas: function (canvas) {
            var $canvas = $(canvas.canvas);
            this.canvas = canvas;
            this.$canvas = $canvas;
            $canvas.mouseenter($.proxy(this.mouseenter, this));
            $canvas.mouseleave($.proxy(this.mouseleave, this));
            $canvas.click($.proxy(this.mouseclick, this));
        },

        reset: function (removeTooltip) {
            this.splist = [];
            if (this.tooltip && removeTooltip) {
                this.tooltip.remove();
                this.tooltip = undefined;
            }
        },

        mouseclick: function (e) {
            var clickEvent = $.Event('sparklineClick');
            clickEvent.originalEvent = e;
            clickEvent.sparklines = this.splist;
            this.$el.trigger(clickEvent);
        },

        mouseenter: function (e) {
            $(document.body).unbind('mousemove.jqs');
            $(document.body).bind('mousemove.jqs', $.proxy(this.mousemove, this));
            this.over = true;
            this.currentPageX = e.pageX;
            this.currentPageY = e.pageY;
            this.currentEl = e.target;
            if (!this.tooltip && this.displayTooltips) {
                this.tooltip = new Tooltip(this.options);
                this.tooltip.updatePosition(e.pageX, e.pageY);
            }
            this.updateDisplay();
        },

        mouseleave: function () {
            $(document.body).unbind('mousemove.jqs');
            var splist = this.splist,
                 spcount = splist.length,
                 needsRefresh = false,
                 sp, i;
            this.over = false;
            this.currentEl = null;

            if (this.tooltip) {
                this.tooltip.remove();
                this.tooltip = null;
            }

            for (i = 0; i < spcount; i++) {
                sp = splist[i];
                if (sp.clearRegionHighlight()) {
                    needsRefresh = true;
                }
            }

            if (needsRefresh) {
                this.canvas.render();
            }
        },

        mousemove: function (e) {
            this.currentPageX = e.pageX;
            this.currentPageY = e.pageY;
            this.currentEl = e.target;
            if (this.tooltip) {
                this.tooltip.updatePosition(e.pageX, e.pageY);
            }
            this.updateDisplay();
        },

        updateDisplay: function () {
            var splist = this.splist,
                 spcount = splist.length,
                 needsRefresh = false,
                 offset = this.$canvas.offset(),
                 localX = this.currentPageX - offset.left,
                 localY = this.currentPageY - offset.top,
                 tooltiphtml, sp, i, result, changeEvent;
            if (!this.over) {
                return;
            }
            for (i = 0; i < spcount; i++) {
                sp = splist[i];
                result = sp.setRegionHighlight(this.currentEl, localX, localY);
                if (result) {
                    needsRefresh = true;
                }
            }
            if (needsRefresh) {
                changeEvent = $.Event('sparklineRegionChange');
                changeEvent.sparklines = this.splist;
                this.$el.trigger(changeEvent);
                if (this.tooltip) {
                    tooltiphtml = '';
                    for (i = 0; i < spcount; i++) {
                        sp = splist[i];
                        tooltiphtml += sp.getCurrentRegionTooltip();
                    }
                    this.tooltip.setContent(tooltiphtml);
                }
                if (!this.disableHighlight) {
                    this.canvas.render();
                }
            }
            if (result === null) {
                this.mouseleave();
            }
        }
    });


    Tooltip = createClass({
        sizeStyle: 'position: static !important;' +
            'display: block !important;' +
            'visibility: hidden !important;' +
            'float: left !important;',

        init: function (options) {
            var tooltipClassname = options.get('tooltipClassname', 'jqstooltip'),
                sizetipStyle = this.sizeStyle,
                offset;
            this.container = options.get('tooltipContainer') || document.body;
            this.tooltipOffsetX = options.get('tooltipOffsetX', 10);
            this.tooltipOffsetY = options.get('tooltipOffsetY', 12);
            // remove any previous lingering tooltip
            $('#jqssizetip').remove();
            $('#jqstooltip').remove();
            this.sizetip = $('<div/>', {
                id: 'jqssizetip',
                style: sizetipStyle,
                'class': tooltipClassname
            });
            this.tooltip = $('<div/>', {
                id: 'jqstooltip',
                'class': tooltipClassname
            }).appendTo(this.container);
            // account for the container's location
            offset = this.tooltip.offset();
            this.offsetLeft = offset.left;
            this.offsetTop = offset.top;
            this.hidden = true;
            $(window).unbind('resize.jqs scroll.jqs');
            $(window).bind('resize.jqs scroll.jqs', $.proxy(this.updateWindowDims, this));
            this.updateWindowDims();
        },

        updateWindowDims: function () {
            this.scrollTop = $(window).scrollTop();
            this.scrollLeft = $(window).scrollLeft();
            this.scrollRight = this.scrollLeft + $(window).width();
            this.updatePosition();
        },

        getSize: function (content) {
            this.sizetip.html(content).appendTo(this.container);
            this.width = this.sizetip.width() + 1;
            this.height = this.sizetip.height();
            this.sizetip.remove();
        },

        setContent: function (content) {
            if (!content) {
                this.tooltip.css('visibility', 'hidden');
                this.hidden = true;
                return;
            }
            this.getSize(content);
            this.tooltip.html(content)
                .css({
                    'width': this.width,
                    'height': this.height,
                    'visibility': 'visible'
                });
            if (this.hidden) {
                this.hidden = false;
                this.updatePosition();
            }
        },

        updatePosition: function (x, y) {
            if (x === undefined) {
                if (this.mousex === undefined) {
                    return;
                }
                x = this.mousex - this.offsetLeft;
                y = this.mousey - this.offsetTop;

            } else {
                this.mousex = x = x - this.offsetLeft;
                this.mousey = y = y - this.offsetTop;
            }
            if (!this.height || !this.width || this.hidden) {
                return;
            }

            y -= this.height + this.tooltipOffsetY;
            x += this.tooltipOffsetX;

            if (y < this.scrollTop) {
                y = this.scrollTop;
            }
            if (x < this.scrollLeft) {
                x = this.scrollLeft;
            } else if (x + this.width > this.scrollRight) {
                x = this.scrollRight - this.width;
            }

            this.tooltip.css({
                'left': x,
                'top': y
            });
        },

        remove: function () {
            this.tooltip.remove();
            this.sizetip.remove();
            this.sizetip = this.tooltip = undefined;
            $(window).unbind('resize.jqs scroll.jqs');
        }
    });

    initStyles = function() {
        addCSS(defaultStyles);
    };

    $(initStyles);

    pending = [];
    $.fn.sparkline = function (userValues, userOptions) {
        return this.each(function () {
            var options = new $.fn.sparkline.options(this, userOptions),
                 $this = $(this),
                 render, i;
            render = function () {
                var values, width, height, tmp, mhandler, sp, vals;
                if (userValues === 'html' || userValues === undefined) {
                    vals = this.getAttribute(options.get('tagValuesAttribute'));
                    if (vals === undefined || vals === null) {
                        vals = $this.html();
                    }
                    values = vals.replace(/(^\s*<!--)|(-->\s*$)|\s+/g, '').split(',');
                } else {
                    values = userValues;
                }

                width = options.get('width') === 'auto' ? values.length * options.get('defaultPixelsPerValue') : options.get('width');
                if (options.get('height') === 'auto') {
                    if (!options.get('composite') || !$.data(this, '_jqs_vcanvas')) {
                        // must be a better way to get the line height
                        tmp = document.createElement('span');
                        tmp.innerHTML = 'a';
                        $this.html(tmp);
                        height = $(tmp).innerHeight() || $(tmp).height();
                        $(tmp).remove();
                        tmp = null;
                    }
                } else {
                    height = options.get('height');
                }

                if (!options.get('disableInteraction')) {
                    mhandler = $.data(this, '_jqs_mhandler');
                    if (!mhandler) {
                        mhandler = new MouseHandler(this, options);
                        $.data(this, '_jqs_mhandler', mhandler);
                    } else if (!options.get('composite')) {
                        mhandler.reset();
                    }
                } else {
                    mhandler = false;
                }

                if (options.get('composite') && !$.data(this, '_jqs_vcanvas')) {
                    if (!$.data(this, '_jqs_errnotify')) {
                        alert('Attempted to attach a composite sparkline to an element with no existing sparkline');
                        $.data(this, '_jqs_errnotify', true);
                    }
                    return;
                }

                sp = new $.fn.sparkline[options.get('type')](this, values, options, width, height);

                sp.render();

                if (mhandler) {
                    mhandler.registerSparkline(sp);
                }
            };
            // jQuery 1.3.0 completely changed the meaning of :hidden :-/
            if (($(this).html() && !options.get('disableHiddenCheck') && $(this).is(':hidden')) || ($.fn.jquery < '1.3.0' && $(this).parents().is(':hidden')) || !$(this).parents('body').length) {
                if (!options.get('composite') && $.data(this, '_jqs_pending')) {
                    // remove any existing references to the element
                    for (i = pending.length; i; i--) {
                        if (pending[i - 1][0] == this) {
                            pending.splice(i - 1, 1);
                        }
                    }
                }
                pending.push([this, render]);
                $.data(this, '_jqs_pending', true);
            } else {
                render.call(this);
            }
        });
    };

    $.fn.sparkline.defaults = getDefaults();


    $.sparkline_display_visible = function () {
        var el, i, pl;
        var done = [];
        for (i = 0, pl = pending.length; i < pl; i++) {
            el = pending[i][0];
            if ($(el).is(':visible') && !$(el).parents().is(':hidden')) {
                pending[i][1].call(el);
                $.data(pending[i][0], '_jqs_pending', false);
                done.push(i);
            } else if (!$(el).closest('html').length && !$.data(el, '_jqs_pending')) {
                // element has been inserted and removed from the DOM
                // If it was not yet inserted into the dom then the .data request
                // will return true.
                // removing from the dom causes the data to be removed.
                $.data(pending[i][0], '_jqs_pending', false);
                done.push(i);
            }
        }
        for (i = done.length; i; i--) {
            pending.splice(done[i - 1], 1);
        }
    };


    /**
     * User option handler
     */
    $.fn.sparkline.options = createClass({
        init: function (tag, userOptions) {
            var extendedOptions, defaults, base, tagOptionType;
            this.userOptions = userOptions = userOptions || {};
            this.tag = tag;
            this.tagValCache = {};
            defaults = $.fn.sparkline.defaults;
            base = defaults.common;
            this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);

            tagOptionType = this.getTagSetting('type');
            if (tagOptionType === UNSET_OPTION) {
                extendedOptions = defaults[userOptions.type || base.type];
            } else {
                extendedOptions = defaults[tagOptionType];
            }
            this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);
        },


        getTagSetting: function (key) {
            var prefix = this.tagOptionsPrefix,
                val, i, pairs, keyval;
            if (prefix === false || prefix === undefined) {
                return UNSET_OPTION;
            }
            if (this.tagValCache.hasOwnProperty(key)) {
                val = this.tagValCache.key;
            } else {
                val = this.tag.getAttribute(prefix + key);
                if (val === undefined || val === null) {
                    val = UNSET_OPTION;
                } else if (val.substr(0, 1) === '[') {
                    val = val.substr(1, val.length - 2).split(',');
                    for (i = val.length; i--;) {
                        val[i] = normalizeValue(val[i].replace(/(^\s*)|(\s*$)/g, ''));
                    }
                } else if (val.substr(0, 1) === '{') {
                    pairs = val.substr(1, val.length - 2).split(',');
                    val = {};
                    for (i = pairs.length; i--;) {
                        keyval = pairs[i].split(':', 2);
                        val[keyval[0].replace(/(^\s*)|(\s*$)/g, '')] = normalizeValue(keyval[1].replace(/(^\s*)|(\s*$)/g, ''));
                    }
                } else {
                    val = normalizeValue(val);
                }
                this.tagValCache.key = val;
            }
            return val;
        },

        get: function (key, defaultval) {
            var tagOption = this.getTagSetting(key),
                result;
            if (tagOption !== UNSET_OPTION) {
                return tagOption;
            }
            return (result = this.mergedOptions[key]) === undefined ? defaultval : result;
        }
    });


    $.fn.sparkline._base = createClass({
        disabled: false,

        init: function (el, values, options, width, height) {
            this.el = el;
            this.$el = $(el);
            this.values = values;
            this.options = options;
            this.width = width;
            this.height = height;
            this.currentRegion = undefined;
        },

        /**
         * Setup the canvas
         */
        initTarget: function () {
            var interactive = !this.options.get('disableInteraction');
            if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get('composite'), interactive))) {
                this.disabled = true;
            } else {
                this.canvasWidth = this.target.pixelWidth;
                this.canvasHeight = this.target.pixelHeight;
            }
        },

        /**
         * Actually render the chart to the canvas
         */
        render: function () {
            if (this.disabled) {
                this.el.innerHTML = '';
                return false;
            }
            return true;
        },

        /**
         * Return a region id for a given x/y co-ordinate
         */
        getRegion: function (x, y) {
        },

        /**
         * Highlight an item based on the moused-over x,y co-ordinate
         */
        setRegionHighlight: function (el, x, y) {
            var currentRegion = this.currentRegion,
                highlightEnabled = !this.options.get('disableHighlight'),
                newRegion;
            if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {
                return null;
            }
            newRegion = this.getRegion(el, x, y);
            if (currentRegion !== newRegion) {
                if (currentRegion !== undefined && highlightEnabled) {
                    this.removeHighlight();
                }
                this.currentRegion = newRegion;
                if (newRegion !== undefined && highlightEnabled) {
                    this.renderHighlight();
                }
                return true;
            }
            return false;
        },

        /**
         * Reset any currently highlighted item
         */
        clearRegionHighlight: function () {
            if (this.currentRegion !== undefined) {
                this.removeHighlight();
                this.currentRegion = undefined;
                return true;
            }
            return false;
        },

        renderHighlight: function () {
            this.changeHighlight(true);
        },

        removeHighlight: function () {
            this.changeHighlight(false);
        },

        changeHighlight: function (highlight)  {},

        /**
         * Fetch the HTML to display as a tooltip
         */
        getCurrentRegionTooltip: function () {
            var options = this.options,
                header = '',
                entries = [],
                fields, formats, formatlen, fclass, text, i,
                showFields, showFieldsKey, newFields, fv,
                formatter, format, fieldlen, j;
            if (this.currentRegion === undefined) {
                return '';
            }
            fields = this.getCurrentRegionFields();
            formatter = options.get('tooltipFormatter');
            if (formatter) {
                return formatter(this, options, fields);
            }
            if (options.get('tooltipChartTitle')) {
                header += '<div class="jqs jqstitle">' + options.get('tooltipChartTitle') + '</div>\n';
            }
            formats = this.options.get('tooltipFormat');
            if (!formats) {
                return '';
            }
            if (!$.isArray(formats)) {
                formats = [formats];
            }
            if (!$.isArray(fields)) {
                fields = [fields];
            }
            showFields = this.options.get('tooltipFormatFieldlist');
            showFieldsKey = this.options.get('tooltipFormatFieldlistKey');
            if (showFields && showFieldsKey) {
                // user-selected ordering of fields
                newFields = [];
                for (i = fields.length; i--;) {
                    fv = fields[i][showFieldsKey];
                    if ((j = $.inArray(fv, showFields)) != -1) {
                        newFields[j] = fields[i];
                    }
                }
                fields = newFields;
            }
            formatlen = formats.length;
            fieldlen = fields.length;
            for (i = 0; i < formatlen; i++) {
                format = formats[i];
                if (typeof format === 'string') {
                    format = new SPFormat(format);
                }
                fclass = format.fclass || 'jqsfield';
                for (j = 0; j < fieldlen; j++) {
                    if (!fields[j].isNull || !options.get('tooltipSkipNull')) {
                        $.extend(fields[j], {
                            prefix: options.get('tooltipPrefix'),
                            suffix: options.get('tooltipSuffix')
                        });
                        text = format.render(fields[j], options.get('tooltipValueLookups'), options);
                        entries.push('<div class="' + fclass + '">' + text + '</div>');
                    }
                }
            }
            if (entries.length) {
                return header + entries.join('\n');
            }
            return '';
        },

        getCurrentRegionFields: function () {},

        calcHighlightColor: function (color, options) {
            var highlightColor = options.get('highlightColor'),
                lighten = options.get('highlightLighten'),
                parse, mult, rgbnew, i;
            if (highlightColor) {
                return highlightColor;
            }
            if (lighten) {
                // extract RGB values
                parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);
                if (parse) {
                    rgbnew = [];
                    mult = color.length === 4 ? 16 : 1;
                    for (i = 0; i < 3; i++) {
                        rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);
                    }
                    return 'rgb(' + rgbnew.join(',') + ')';
                }

            }
            return color;
        }

    });

    barHighlightMixin = {
        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                target = this.target,
                shapeids = this.regionShapes[currentRegion],
                newShapes;
            // will be null if the region value was null
            if (shapeids) {
                newShapes = this.renderRegion(currentRegion, highlight);
                if ($.isArray(newShapes) || $.isArray(shapeids)) {
                    target.replaceWithShapes(shapeids, newShapes);
                    this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {
                        return newShape.id;
                    });
                } else {
                    target.replaceWithShape(shapeids, newShapes);
                    this.regionShapes[currentRegion] = newShapes.id;
                }
            }
        },

        render: function () {
            var values = this.values,
                target = this.target,
                regionShapes = this.regionShapes,
                shapes, ids, i, j;

            if (!this.cls._super.render.call(this)) {
                return;
            }
            for (i = values.length; i--;) {
                shapes = this.renderRegion(i);
                if (shapes) {
                    if ($.isArray(shapes)) {
                        ids = [];
                        for (j = shapes.length; j--;) {
                            shapes[j].append();
                            ids.push(shapes[j].id);
                        }
                        regionShapes[i] = ids;
                    } else {
                        shapes.append();
                        regionShapes[i] = shapes.id; // store just the shapeid
                    }
                } else {
                    // null value
                    regionShapes[i] = null;
                }
            }
            target.render();
        }
    };

    /**
     * Line charts
     */
    $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {
        type: 'line',

        init: function (el, values, options, width, height) {
            line._super.init.call(this, el, values, options, width, height);
            this.vertices = [];
            this.regionMap = [];
            this.xvalues = [];
            this.yvalues = [];
            this.yminmax = [];
            this.hightlightSpotId = null;
            this.lastShapeId = null;
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            var i,
                regionMap = this.regionMap; // maps regions to value positions
            for (i = regionMap.length; i--;) {
                if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {
                    return regionMap[i][2];
                }
            }
            return undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.yvalues[currentRegion] === null,
                x: this.xvalues[currentRegion],
                y: this.yvalues[currentRegion],
                color: this.options.get('lineColor'),
                fillColor: this.options.get('fillColor'),
                offset: currentRegion
            };
        },

        renderHighlight: function () {
            var currentRegion = this.currentRegion,
                target = this.target,
                vertex = this.vertices[currentRegion],
                options = this.options,
                spotRadius = options.get('spotRadius'),
                highlightSpotColor = options.get('highlightSpotColor'),
                highlightLineColor = options.get('highlightLineColor'),
                highlightSpot, highlightLine;

            if (!vertex) {
                return;
            }
            if (spotRadius && highlightSpotColor) {
                highlightSpot = target.drawCircle(vertex[0], vertex[1],
                    spotRadius, undefined, highlightSpotColor);
                this.highlightSpotId = highlightSpot.id;
                target.insertAfterShape(this.lastShapeId, highlightSpot);
            }
            if (highlightLineColor) {
                highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0],
                    this.canvasTop + this.canvasHeight, highlightLineColor);
                this.highlightLineId = highlightLine.id;
                target.insertAfterShape(this.lastShapeId, highlightLine);
            }
        },

        removeHighlight: function () {
            var target = this.target;
            if (this.highlightSpotId) {
                target.removeShapeId(this.highlightSpotId);
                this.highlightSpotId = null;
            }
            if (this.highlightLineId) {
                target.removeShapeId(this.highlightLineId);
                this.highlightLineId = null;
            }
        },

        scanValues: function () {
            var values = this.values,
                valcount = values.length,
                xvalues = this.xvalues,
                yvalues = this.yvalues,
                yminmax = this.yminmax,
                i, val, isStr, isArray, sp;
            for (i = 0; i < valcount; i++) {
                val = values[i];
                isStr = typeof(values[i]) === 'string';
                isArray = typeof(values[i]) === 'object' && values[i] instanceof Array;
                sp = isStr && values[i].split(':');
                if (isStr && sp.length === 2) { // x:y
                    xvalues.push(Number(sp[0]));
                    yvalues.push(Number(sp[1]));
                    yminmax.push(Number(sp[1]));
                } else if (isArray) {
                    xvalues.push(val[0]);
                    yvalues.push(val[1]);
                    yminmax.push(val[1]);
                } else {
                    xvalues.push(i);
                    if (values[i] === null || values[i] === 'null') {
                        yvalues.push(null);
                    } else {
                        yvalues.push(Number(val));
                        yminmax.push(Number(val));
                    }
                }
            }
            if (this.options.get('xvalues')) {
                xvalues = this.options.get('xvalues');
            }

            this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);
            this.miny = this.minyorg = Math.min.apply(Math, yminmax);

            this.maxx = Math.max.apply(Math, xvalues);
            this.minx = Math.min.apply(Math, xvalues);

            this.xvalues = xvalues;
            this.yvalues = yvalues;
            this.yminmax = yminmax;

        },

        processRangeOptions: function () {
            var options = this.options,
                normalRangeMin = options.get('normalRangeMin'),
                normalRangeMax = options.get('normalRangeMax');

            if (normalRangeMin !== undefined) {
                if (normalRangeMin < this.miny) {
                    this.miny = normalRangeMin;
                }
                if (normalRangeMax > this.maxy) {
                    this.maxy = normalRangeMax;
                }
            }
            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {
                this.miny = options.get('chartRangeMin');
            }
            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {
                this.maxy = options.get('chartRangeMax');
            }
            if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {
                this.minx = options.get('chartRangeMinX');
            }
            if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {
                this.maxx = options.get('chartRangeMaxX');
            }

        },

        drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {
            var normalRangeMin = this.options.get('normalRangeMin'),
                normalRangeMax = this.options.get('normalRangeMax'),
                ytop = canvasTop + Math.round(canvasHeight - (canvasHeight * ((normalRangeMax - this.miny) / rangey))),
                height = Math.round((canvasHeight * (normalRangeMax - normalRangeMin)) / rangey);
            this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();
        },

        render: function () {
            var options = this.options,
                target = this.target,
                canvasWidth = this.canvasWidth,
                canvasHeight = this.canvasHeight,
                vertices = this.vertices,
                spotRadius = options.get('spotRadius'),
                regionMap = this.regionMap,
                rangex, rangey, yvallast,
                canvasTop, canvasLeft,
                vertex, path, paths, x, y, xnext, xpos, xposnext,
                last, next, yvalcount, lineShapes, fillShapes, plen,
                valueSpots, hlSpotsEnabled, color, xvalues, yvalues, i;

            if (!line._super.render.call(this)) {
                return;
            }

            this.scanValues();
            this.processRangeOptions();

            xvalues = this.xvalues;
            yvalues = this.yvalues;

            if (!this.yminmax.length || this.yvalues.length < 2) {
                // empty or all null valuess
                return;
            }

            canvasTop = canvasLeft = 0;

            rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;
            rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;
            yvallast = this.yvalues.length - 1;

            if (spotRadius && (canvasWidth < (spotRadius * 4) || canvasHeight < (spotRadius * 4))) {
                spotRadius = 0;
            }
            if (spotRadius) {
                // adjust the canvas size as required so that spots will fit
                hlSpotsEnabled = options.get('highlightSpotColor') &&  !options.get('disableInteraction');
                if (hlSpotsEnabled || options.get('minSpotColor') || (options.get('spotColor') && yvalues[yvallast] === this.miny)) {
                    canvasHeight -= Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled || options.get('maxSpotColor') || (options.get('spotColor') && yvalues[yvallast] === this.maxy)) {
                    canvasHeight -= Math.ceil(spotRadius);
                    canvasTop += Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled ||
                     ((options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy))) {
                    canvasLeft += Math.ceil(spotRadius);
                    canvasWidth -= Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled || options.get('spotColor') ||
                    (options.get('minSpotColor') || options.get('maxSpotColor') &&
                        (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy))) {
                    canvasWidth -= Math.ceil(spotRadius);
                }
            }


            canvasHeight--;

            if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {
                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
            }

            path = [];
            paths = [path];
            last = next = null;
            yvalcount = yvalues.length;
            for (i = 0; i < yvalcount; i++) {
                x = xvalues[i];
                xnext = xvalues[i + 1];
                y = yvalues[i];
                xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));
                xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;
                next = xpos + ((xposnext - xpos) / 2);
                regionMap[i] = [last || 0, next, i];
                last = next;
                if (y === null) {
                    if (i) {
                        if (yvalues[i - 1] !== null) {
                            path = [];
                            paths.push(path);
                        }
                        vertices.push(null);
                    }
                } else {
                    if (y < this.miny) {
                        y = this.miny;
                    }
                    if (y > this.maxy) {
                        y = this.maxy;
                    }
                    if (!path.length) {
                        // previous value was null
                        path.push([xpos, canvasTop + canvasHeight]);
                    }
                    vertex = [xpos, canvasTop + Math.round(canvasHeight - (canvasHeight * ((y - this.miny) / rangey)))];
                    path.push(vertex);
                    vertices.push(vertex);
                }
            }

            lineShapes = [];
            fillShapes = [];
            plen = paths.length;
            for (i = 0; i < plen; i++) {
                path = paths[i];
                if (path.length) {
                    if (options.get('fillColor')) {
                        path.push([path[path.length - 1][0], (canvasTop + canvasHeight)]);
                        fillShapes.push(path.slice(0));
                        path.pop();
                    }
                    // if there's only a single point in this path, then we want to display it
                    // as a vertical line which means we keep path[0]  as is
                    if (path.length > 2) {
                        // else we want the first value
                        path[0] = [path[0][0], path[1][1]];
                    }
                    lineShapes.push(path);
                }
            }

            // draw the fill first, then optionally the normal range, then the line on top of that
            plen = fillShapes.length;
            for (i = 0; i < plen; i++) {
                target.drawShape(fillShapes[i],
                    options.get('fillColor'), options.get('fillColor')).append();
            }

            if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {
                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
            }

            plen = lineShapes.length;
            for (i = 0; i < plen; i++) {
                target.drawShape(lineShapes[i], options.get('lineColor'), undefined,
                    options.get('lineWidth')).append();
            }

            if (spotRadius && options.get('valueSpots')) {
                valueSpots = options.get('valueSpots');
                if (valueSpots.get === undefined) {
                    valueSpots = new RangeMap(valueSpots);
                }
                for (i = 0; i < yvalcount; i++) {
                    color = valueSpots.get(yvalues[i]);
                    if (color) {
                        target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)),
                            canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[i] - this.miny) / rangey))),
                            spotRadius, undefined,
                            color).append();
                    }
                }

            }
            if (spotRadius && options.get('spotColor')) {
                target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)),
                    canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[yvallast] - this.miny) / rangey))),
                    spotRadius, undefined,
                    options.get('spotColor')).append();
            }
            if (this.maxy !== this.minyorg) {
                if (spotRadius && options.get('minSpotColor')) {
                    x = xvalues[$.inArray(this.minyorg, yvalues)];
                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),
                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.minyorg - this.miny) / rangey))),
                        spotRadius, undefined,
                        options.get('minSpotColor')).append();
                }
                if (spotRadius && options.get('maxSpotColor')) {
                    x = xvalues[$.inArray(this.maxyorg, yvalues)];
                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),
                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.maxyorg - this.miny) / rangey))),
                        spotRadius, undefined,
                        options.get('maxSpotColor')).append();
                }
            }

            this.lastShapeId = target.getLastShapeId();
            this.canvasTop = canvasTop;
            target.render();
        }
    });

    /**
     * Bar charts
     */
    $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: 'bar',

        init: function (el, values, options, width, height) {
            var barWidth = parseInt(options.get('barWidth'), 10),
                barSpacing = parseInt(options.get('barSpacing'), 10),
                chartRangeMin = options.get('chartRangeMin'),
                chartRangeMax = options.get('chartRangeMax'),
                chartRangeClip = options.get('chartRangeClip'),
                stackMin = Infinity,
                stackMax = -Infinity,
                isStackString, groupMin, groupMax, stackRanges,
                numValues, i, vlen, range, zeroAxis, xaxisOffset, min, max, clipMin, clipMax,
                stacked, vlist, j, slen, svals, val, yoffset, yMaxCalc, canvasHeightEf;
            bar._super.init.call(this, el, values, options, width, height);

            // scan values to determine whether to stack bars
            for (i = 0, vlen = values.length; i < vlen; i++) {
                val = values[i];
                isStackString = typeof(val) === 'string' && val.indexOf(':') > -1;
                if (isStackString || $.isArray(val)) {
                    stacked = true;
                    if (isStackString) {
                        val = values[i] = normalizeValues(val.split(':'));
                    }
                    val = remove(val, null); // min/max will treat null as zero
                    groupMin = Math.min.apply(Math, val);
                    groupMax = Math.max.apply(Math, val);
                    if (groupMin < stackMin) {
                        stackMin = groupMin;
                    }
                    if (groupMax > stackMax) {
                        stackMax = groupMax;
                    }
                }
            }

            this.stacked = stacked;
            this.regionShapes = {};
            this.barWidth = barWidth;
            this.barSpacing = barSpacing;
            this.totalBarWidth = barWidth + barSpacing;
            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);

            this.initTarget();

            if (chartRangeClip) {
                clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;
                clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;
            }

            numValues = [];
            stackRanges = stacked ? [] : numValues;
            var stackTotals = [];
            var stackRangesNeg = [];
            for (i = 0, vlen = values.length; i < vlen; i++) {
                if (stacked) {
                    vlist = values[i];
                    values[i] = svals = [];
                    stackTotals[i] = 0;
                    stackRanges[i] = stackRangesNeg[i] = 0;
                    for (j = 0, slen = vlist.length; j < slen; j++) {
                        val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];
                        if (val !== null) {
                            if (val > 0) {
                                stackTotals[i] += val;
                            }
                            if (stackMin < 0 && stackMax > 0) {
                                if (val < 0) {
                                    stackRangesNeg[i] += Math.abs(val);
                                } else {
                                    stackRanges[i] += val;
                                }
                            } else {
                                stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));
                            }
                            numValues.push(val);
                        }
                    }
                } else {
                    val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];
                    val = values[i] = normalizeValue(val);
                    if (val !== null) {
                        numValues.push(val);
                    }
                }
            }
            this.max = max = Math.max.apply(Math, numValues);
            this.min = min = Math.min.apply(Math, numValues);
            this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;
            this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;

            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {
                min = options.get('chartRangeMin');
            }
            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {
                max = options.get('chartRangeMax');
            }

            this.zeroAxis = zeroAxis = options.get('zeroAxis', true);
            if (min <= 0 && max >= 0 && zeroAxis) {
                xaxisOffset = 0;
            } else if (zeroAxis == false) {
                xaxisOffset = min;
            } else if (min > 0) {
                xaxisOffset = min;
            } else {
                xaxisOffset = max;
            }
            this.xaxisOffset = xaxisOffset;

            range = stacked ? (Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg)) : max - min;

            // as we plot zero/min values a single pixel line, we add a pixel to all other
            // values - Reduce the effective canvas size to suit
            this.canvasHeightEf = (zeroAxis && min < 0) ? this.canvasHeight - 2 : this.canvasHeight - 1;

            if (min < xaxisOffset) {
                yMaxCalc = (stacked && max >= 0) ? stackMax : max;
                yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;
                if (yoffset !== Math.ceil(yoffset)) {
                    this.canvasHeightEf -= 2;
                    yoffset = Math.ceil(yoffset);
                }
            } else {
                yoffset = this.canvasHeight;
            }
            this.yoffset = yoffset;

            if ($.isArray(options.get('colorMap'))) {
                this.colorMapByIndex = options.get('colorMap');
                this.colorMapByValue = null;
            } else {
                this.colorMapByIndex = null;
                this.colorMapByValue = options.get('colorMap');
                if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                    this.colorMapByValue = new RangeMap(this.colorMapByValue);
                }
            }

            this.range = range;
        },

        getRegion: function (el, x, y) {
            var result = Math.floor(x / this.totalBarWidth);
            return (result < 0 || result >= this.values.length) ? undefined : result;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion,
                values = ensureArray(this.values[currentRegion]),
                result = [],
                value, i;
            for (i = values.length; i--;) {
                value = values[i];
                result.push({
                    isNull: value === null,
                    value: value,
                    color: this.calcColor(i, value, currentRegion),
                    offset: currentRegion
                });
            }
            return result;
        },

        calcColor: function (stacknum, value, valuenum) {
            var colorMapByIndex = this.colorMapByIndex,
                colorMapByValue = this.colorMapByValue,
                options = this.options,
                color, newColor;
            if (this.stacked) {
                color = options.get('stackedBarColor');
            } else {
                color = (value < 0) ? options.get('negBarColor') : options.get('barColor');
            }
            if (value === 0 && options.get('zeroColor') !== undefined) {
                color = options.get('zeroColor');
            }
            if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                color = newColor;
            } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                color = colorMapByIndex[valuenum];
            }
            return $.isArray(color) ? color[stacknum % color.length] : color;
        },

        /**
         * Render bar(s) for a region
         */
        renderRegion: function (valuenum, highlight) {
            var vals = this.values[valuenum],
                options = this.options,
                xaxisOffset = this.xaxisOffset,
                result = [],
                range = this.range,
                stacked = this.stacked,
                target = this.target,
                x = valuenum * this.totalBarWidth,
                canvasHeightEf = this.canvasHeightEf,
                yoffset = this.yoffset,
                y, height, color, isNull, yoffsetNeg, i, valcount, val, minPlotted, allMin;

            vals = $.isArray(vals) ? vals : [vals];
            valcount = vals.length;
            val = vals[0];
            isNull = all(null, vals);
            allMin = all(xaxisOffset, vals, true);

            if (isNull) {
                if (options.get('nullColor')) {
                    color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);
                    y = (yoffset > 0) ? yoffset - 1 : yoffset;
                    return target.drawRect(x, y, this.barWidth - 1, 0, color, color);
                } else {
                    return undefined;
                }
            }
            yoffsetNeg = yoffset;
            for (i = 0; i < valcount; i++) {
                val = vals[i];

                if (stacked && val === xaxisOffset) {
                    if (!allMin || minPlotted) {
                        continue;
                    }
                    minPlotted = true;
                }

                if (range > 0) {
                    height = Math.floor(canvasHeightEf * ((Math.abs(val - xaxisOffset) / range))) + 1;
                } else {
                    height = 1;
                }
                if (val < xaxisOffset || (val === xaxisOffset && yoffset === 0)) {
                    y = yoffsetNeg;
                    yoffsetNeg += height;
                } else {
                    y = yoffset - height;
                    yoffset -= height;
                }
                color = this.calcColor(i, val, valuenum);
                if (highlight) {
                    color = this.calcHighlightColor(color, options);
                }
                result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));
            }
            if (result.length === 1) {
                return result[0];
            }
            return result;
        }
    });

    /**
     * Tristate charts
     */
    $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: 'tristate',

        init: function (el, values, options, width, height) {
            var barWidth = parseInt(options.get('barWidth'), 10),
                barSpacing = parseInt(options.get('barSpacing'), 10);
            tristate._super.init.call(this, el, values, options, width, height);

            this.regionShapes = {};
            this.barWidth = barWidth;
            this.barSpacing = barSpacing;
            this.totalBarWidth = barWidth + barSpacing;
            this.values = $.map(values, Number);
            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);

            if ($.isArray(options.get('colorMap'))) {
                this.colorMapByIndex = options.get('colorMap');
                this.colorMapByValue = null;
            } else {
                this.colorMapByIndex = null;
                this.colorMapByValue = options.get('colorMap');
                if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                    this.colorMapByValue = new RangeMap(this.colorMapByValue);
                }
            }
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            return Math.floor(x / this.totalBarWidth);
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                color: this.calcColor(this.values[currentRegion], currentRegion),
                offset: currentRegion
            };
        },

        calcColor: function (value, valuenum) {
            var values = this.values,
                options = this.options,
                colorMapByIndex = this.colorMapByIndex,
                colorMapByValue = this.colorMapByValue,
                color, newColor;

            if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                color = newColor;
            } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                color = colorMapByIndex[valuenum];
            } else if (values[valuenum] < 0) {
                color = options.get('negBarColor');
            } else if (values[valuenum] > 0) {
                color = options.get('posBarColor');
            } else {
                color = options.get('zeroBarColor');
            }
            return color;
        },

        renderRegion: function (valuenum, highlight) {
            var values = this.values,
                options = this.options,
                target = this.target,
                canvasHeight, height, halfHeight,
                x, y, color;

            canvasHeight = target.pixelHeight;
            halfHeight = Math.round(canvasHeight / 2);

            x = valuenum * this.totalBarWidth;
            if (values[valuenum] < 0) {
                y = halfHeight;
                height = halfHeight - 1;
            } else if (values[valuenum] > 0) {
                y = 0;
                height = halfHeight - 1;
            } else {
                y = halfHeight - 1;
                height = 2;
            }
            color = this.calcColor(values[valuenum], valuenum);
            if (color === null) {
                return;
            }
            if (highlight) {
                color = this.calcHighlightColor(color, options);
            }
            return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);
        }
    });

    /**
     * Discrete charts
     */
    $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: 'discrete',

        init: function (el, values, options, width, height) {
            discrete._super.init.call(this, el, values, options, width, height);

            this.regionShapes = {};
            this.values = values = $.map(values, Number);
            this.min = Math.min.apply(Math, values);
            this.max = Math.max.apply(Math, values);
            this.range = this.max - this.min;
            this.width = width = options.get('width') === 'auto' ? values.length * 2 : this.width;
            this.interval = Math.floor(width / values.length);
            this.itemWidth = width / values.length;
            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {
                this.min = options.get('chartRangeMin');
            }
            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {
                this.max = options.get('chartRangeMax');
            }
            this.initTarget();
            if (this.target) {
                this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');
            }
        },

        getRegion: function (el, x, y) {
            return Math.floor(x / this.itemWidth);
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                offset: currentRegion
            };
        },

        renderRegion: function (valuenum, highlight) {
            var values = this.values,
                options = this.options,
                min = this.min,
                max = this.max,
                range = this.range,
                interval = this.interval,
                target = this.target,
                canvasHeight = this.canvasHeight,
                lineHeight = this.lineHeight,
                pheight = canvasHeight - lineHeight,
                ytop, val, color, x;

            val = clipval(values[valuenum], min, max);
            x = valuenum * interval;
            ytop = Math.round(pheight - pheight * ((val - min) / range));
            color = (options.get('thresholdColor') && val < options.get('thresholdValue')) ? options.get('thresholdColor') : options.get('lineColor');
            if (highlight) {
                color = this.calcHighlightColor(color, options);
            }
            return target.drawLine(x, ytop, x, ytop + lineHeight, color);
        }
    });

    /**
     * Bullet charts
     */
    $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {
        type: 'bullet',

        init: function (el, values, options, width, height) {
            var min, max, vals;
            bullet._super.init.call(this, el, values, options, width, height);

            // values: target, performance, range1, range2, range3
            this.values = values = normalizeValues(values);
            // target or performance could be null
            vals = values.slice();
            vals[0] = vals[0] === null ? vals[2] : vals[0];
            vals[1] = values[1] === null ? vals[2] : vals[1];
            min = Math.min.apply(Math, values);
            max = Math.max.apply(Math, values);
            if (options.get('base') === undefined) {
                min = min < 0 ? min : 0;
            } else {
                min = options.get('base');
            }
            this.min = min;
            this.max = max;
            this.range = max - min;
            this.shapes = {};
            this.valueShapes = {};
            this.regiondata = {};
            this.width = width = options.get('width') === 'auto' ? '4.0em' : width;
            this.target = this.$el.simpledraw(width, height, options.get('composite'));
            if (!values.length) {
                this.disabled = true;
            }
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            var shapeid = this.target.getShapeAt(el, x, y);
            return (shapeid !== undefined && this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                fieldkey: currentRegion.substr(0, 1),
                value: this.values[currentRegion.substr(1)],
                region: currentRegion
            };
        },

        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                shapeid = this.valueShapes[currentRegion],
                shape;
            delete this.shapes[shapeid];
            switch (currentRegion.substr(0, 1)) {
                case 'r':
                    shape = this.renderRange(currentRegion.substr(1), highlight);
                    break;
                case 'p':
                    shape = this.renderPerformance(highlight);
                    break;
                case 't':
                    shape = this.renderTarget(highlight);
                    break;
            }
            this.valueShapes[currentRegion] = shape.id;
            this.shapes[shape.id] = currentRegion;
            this.target.replaceWithShape(shapeid, shape);
        },

        renderRange: function (rn, highlight) {
            var rangeval = this.values[rn],
                rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),
                color = this.options.get('rangeColors')[rn - 2];
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);
        },

        renderPerformance: function (highlight) {
            var perfval = this.values[1],
                perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),
                color = this.options.get('performanceColor');
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1,
                Math.round(this.canvasHeight * 0.4) - 1, color, color);
        },

        renderTarget: function (highlight) {
            var targetval = this.values[0],
                x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - (this.options.get('targetWidth') / 2)),
                targettop = Math.round(this.canvasHeight * 0.10),
                targetheight = this.canvasHeight - (targettop * 2),
                color = this.options.get('targetColor');
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);
        },

        render: function () {
            var vlen = this.values.length,
                target = this.target,
                i, shape;
            if (!bullet._super.render.call(this)) {
                return;
            }
            for (i = 2; i < vlen; i++) {
                shape = this.renderRange(i).append();
                this.shapes[shape.id] = 'r' + i;
                this.valueShapes['r' + i] = shape.id;
            }
            if (this.values[1] !== null) {
                shape = this.renderPerformance().append();
                this.shapes[shape.id] = 'p1';
                this.valueShapes.p1 = shape.id;
            }
            if (this.values[0] !== null) {
                shape = this.renderTarget().append();
                this.shapes[shape.id] = 't0';
                this.valueShapes.t0 = shape.id;
            }
            target.render();
        }
    });

    /**
     * Pie charts
     */
    $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {
        type: 'pie',

        init: function (el, values, options, width, height) {
            var total = 0, i;

            pie._super.init.call(this, el, values, options, width, height);

            this.shapes = {}; // map shape ids to value offsets
            this.valueShapes = {}; // maps value offsets to shape ids
            this.values = values = $.map(values, Number);

            if (options.get('width') === 'auto') {
                this.width = this.height;
            }

            if (values.length > 0) {
                for (i = values.length; i--;) {
                    total += values[i];
                }
            }
            this.total = total;
            this.initTarget();
            this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);
        },

        getRegion: function (el, x, y) {
            var shapeid = this.target.getShapeAt(el, x, y);
            return (shapeid !== undefined && this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                percent: this.values[currentRegion] / this.total * 100,
                color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],
                offset: currentRegion
            };
        },

        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                 newslice = this.renderSlice(currentRegion, highlight),
                 shapeid = this.valueShapes[currentRegion];
            delete this.shapes[shapeid];
            this.target.replaceWithShape(shapeid, newslice);
            this.valueShapes[currentRegion] = newslice.id;
            this.shapes[newslice.id] = currentRegion;
        },

        renderSlice: function (valuenum, highlight) {
            var target = this.target,
                options = this.options,
                radius = this.radius,
                borderWidth = options.get('borderWidth'),
                offset = options.get('offset'),
                circle = 2 * Math.PI,
                values = this.values,
                total = this.total,
                next = offset ? (2*Math.PI)*(offset/360) : 0,
                start, end, i, vlen, color;

            vlen = values.length;
            for (i = 0; i < vlen; i++) {
                start = next;
                end = next;
                if (total > 0) {  // avoid divide by zero
                    end = next + (circle * (values[i] / total));
                }
                if (valuenum === i) {
                    color = options.get('sliceColors')[i % options.get('sliceColors').length];
                    if (highlight) {
                        color = this.calcHighlightColor(color, options);
                    }

                    return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);
                }
                next = end;
            }
        },

        render: function () {
            var target = this.target,
                values = this.values,
                options = this.options,
                radius = this.radius,
                borderWidth = options.get('borderWidth'),
                shape, i;

            if (!pie._super.render.call(this)) {
                return;
            }
            if (borderWidth) {
                target.drawCircle(radius, radius, Math.floor(radius - (borderWidth / 2)),
                    options.get('borderColor'), undefined, borderWidth).append();
            }
            for (i = values.length; i--;) {
                if (values[i]) { // don't render zero values
                    shape = this.renderSlice(i).append();
                    this.valueShapes[i] = shape.id; // store just the shapeid
                    this.shapes[shape.id] = i;
                }
            }
            target.render();
        }
    });

    /**
     * Box plots
     */
    $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {
        type: 'box',

        init: function (el, values, options, width, height) {
            box._super.init.call(this, el, values, options, width, height);
            this.values = $.map(values, Number);
            this.width = options.get('width') === 'auto' ? '4.0em' : width;
            this.initTarget();
            if (!this.values.length) {
                this.disabled = 1;
            }
        },

        /**
         * Simulate a single region
         */
        getRegion: function () {
            return 1;
        },

        getCurrentRegionFields: function () {
            var result = [
                { field: 'lq', value: this.quartiles[0] },
                { field: 'med', value: this.quartiles[1] },
                { field: 'uq', value: this.quartiles[2] }
            ];
            if (this.loutlier !== undefined) {
                result.push({ field: 'lo', value: this.loutlier});
            }
            if (this.routlier !== undefined) {
                result.push({ field: 'ro', value: this.routlier});
            }
            if (this.lwhisker !== undefined) {
                result.push({ field: 'lw', value: this.lwhisker});
            }
            if (this.rwhisker !== undefined) {
                result.push({ field: 'rw', value: this.rwhisker});
            }
            return result;
        },

        render: function () {
            var target = this.target,
                values = this.values,
                vlen = values.length,
                options = this.options,
                canvasWidth = this.canvasWidth,
                canvasHeight = this.canvasHeight,
                minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'),
                maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'),
                canvasLeft = 0,
                lwhisker, loutlier, iqr, q1, q2, q3, rwhisker, routlier, i,
                size, unitSize;

            if (!box._super.render.call(this)) {
                return;
            }

            if (options.get('raw')) {
                if (options.get('showOutliers') && values.length > 5) {
                    loutlier = values[0];
                    lwhisker = values[1];
                    q1 = values[2];
                    q2 = values[3];
                    q3 = values[4];
                    rwhisker = values[5];
                    routlier = values[6];
                } else {
                    lwhisker = values[0];
                    q1 = values[1];
                    q2 = values[2];
                    q3 = values[3];
                    rwhisker = values[4];
                }
            } else {
                values.sort(function (a, b) { return a - b; });
                q1 = quartile(values, 1);
                q2 = quartile(values, 2);
                q3 = quartile(values, 3);
                iqr = q3 - q1;
                if (options.get('showOutliers')) {
                    lwhisker = rwhisker = undefined;
                    for (i = 0; i < vlen; i++) {
                        if (lwhisker === undefined && values[i] > q1 - (iqr * options.get('outlierIQR'))) {
                            lwhisker = values[i];
                        }
                        if (values[i] < q3 + (iqr * options.get('outlierIQR'))) {
                            rwhisker = values[i];
                        }
                    }
                    loutlier = values[0];
                    routlier = values[vlen - 1];
                } else {
                    lwhisker = values[0];
                    rwhisker = values[vlen - 1];
                }
            }
            this.quartiles = [q1, q2, q3];
            this.lwhisker = lwhisker;
            this.rwhisker = rwhisker;
            this.loutlier = loutlier;
            this.routlier = routlier;

            unitSize = canvasWidth / (maxValue - minValue + 1);
            if (options.get('showOutliers')) {
                canvasLeft = Math.ceil(options.get('spotRadius'));
                canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));
                unitSize = canvasWidth / (maxValue - minValue + 1);
                if (loutlier < lwhisker) {
                    target.drawCircle((loutlier - minValue) * unitSize + canvasLeft,
                        canvasHeight / 2,
                        options.get('spotRadius'),
                        options.get('outlierLineColor'),
                        options.get('outlierFillColor')).append();
                }
                if (routlier > rwhisker) {
                    target.drawCircle((routlier - minValue) * unitSize + canvasLeft,
                        canvasHeight / 2,
                        options.get('spotRadius'),
                        options.get('outlierLineColor'),
                        options.get('outlierFillColor')).append();
                }
            }

            // box
            target.drawRect(
                Math.round((q1 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.1),
                Math.round((q3 - q1) * unitSize),
                Math.round(canvasHeight * 0.8),
                options.get('boxLineColor'),
                options.get('boxFillColor')).append();
            // left whisker
            target.drawLine(
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                Math.round((q1 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                options.get('lineColor')).append();
            target.drawLine(
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 4),
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight - canvasHeight / 4),
                options.get('whiskerColor')).append();
            // right whisker
            target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                Math.round((q3 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                options.get('lineColor')).append();
            target.drawLine(
                Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 4),
                Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight - canvasHeight / 4),
                options.get('whiskerColor')).append();
            // median line
            target.drawLine(
                Math.round((q2 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.1),
                Math.round((q2 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.9),
                options.get('medianColor')).append();
            if (options.get('target')) {
                size = Math.ceil(options.get('spotRadius'));
                target.drawLine(
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft),
                    Math.round((canvasHeight / 2) - size),
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft),
                    Math.round((canvasHeight / 2) + size),
                    options.get('targetColor')).append();
                target.drawLine(
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size),
                    Math.round(canvasHeight / 2),
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size),
                    Math.round(canvasHeight / 2),
                    options.get('targetColor')).append();
            }
            target.render();
        }
    });

    // Setup a very simple "virtual canvas" to make drawing the few shapes we need easier
    // This is accessible as $(foo).simpledraw()

    if ($.browser.msie && document.namespaces && !document.namespaces.v) {
        document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');
    }

    if ($.browser.hasCanvas === undefined) {
        $.browser.hasCanvas = document.createElement('canvas').getContext !== undefined;
    }

    VShape = createClass({
        init: function (target, id, type, args) {
            this.target = target;
            this.id = id;
            this.type = type;
            this.args = args;
        },
        append: function () {
            this.target.appendShape(this);
            return this;
        }
    });

    VCanvas_base = createClass({
        _pxregex: /(\d+)(px)?\s*$/i,

        init: function (width, height, target) {
            if (!width) {
                return;
            }
            this.width = width;
            this.height = height;
            this.target = target;
            this.lastShapeId = null;
            if (target[0]) {
                target = target[0];
            }
            $.data(target, '_jqs_vcanvas', this);
        },

        drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {
            return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);
        },

        drawShape: function (path, lineColor, fillColor, lineWidth) {
            return this._genShape('Shape', [path, lineColor, fillColor, lineWidth]);
        },

        drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {
            return this._genShape('Circle', [x, y, radius, lineColor, fillColor, lineWidth]);
        },

        drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            return this._genShape('PieSlice', [x, y, radius, startAngle, endAngle, lineColor, fillColor]);
        },

        drawRect: function (x, y, width, height, lineColor, fillColor) {
            return this._genShape('Rect', [x, y, width, height, lineColor, fillColor]);
        },

        getElement: function () {
            return this.canvas;
        },

        /**
         * Return the most recently inserted shape id
         */
        getLastShapeId: function () {
            return this.lastShapeId;
        },

        /**
         * Clear and reset the canvas
         */
        reset: function () {
            alert('reset not implemented');
        },

        _insert: function (el, target) {
            $(target).html(el);
        },

        /**
         * Calculate the pixel dimensions of the canvas
         */
        _calculatePixelDims: function (width, height, canvas) {
            // XXX This should probably be a configurable option
            var match;
            match = this._pxregex.exec(height);
            if (match) {
                this.pixelHeight = match[1];
            } else {
                this.pixelHeight = $(canvas).height();
            }
            match = this._pxregex.exec(width);
            if (match) {
                this.pixelWidth = match[1];
            } else {
                this.pixelWidth = $(canvas).width();
            }
        },

        /**
         * Generate a shape object and id for later rendering
         */
        _genShape: function (shapetype, shapeargs) {
            var id = shapeCount++;
            shapeargs.unshift(id);
            return new VShape(this, id, shapetype, shapeargs);
        },

        /**
         * Add a shape to the end of the render queue
         */
        appendShape: function (shape) {
            alert('appendShape not implemented');
        },

        /**
         * Replace one shape with another
         */
        replaceWithShape: function (shapeid, shape) {
            alert('replaceWithShape not implemented');
        },

        /**
         * Insert one shape after another in the render queue
         */
        insertAfterShape: function (shapeid, shape) {
            alert('insertAfterShape not implemented');
        },

        /**
         * Remove a shape from the queue
         */
        removeShapeId: function (shapeid) {
            alert('removeShapeId not implemented');
        },

        /**
         * Find a shape at the specified x/y co-ordinates
         */
        getShapeAt: function (el, x, y) {
            alert('getShapeAt not implemented');
        },

        /**
         * Render all queued shapes onto the canvas
         */
        render: function () {
            alert('render not implemented');
        }
    });

    VCanvas_canvas = createClass(VCanvas_base, {
        init: function (width, height, target, interact) {
            VCanvas_canvas._super.init.call(this, width, height, target);
            this.canvas = document.createElement('canvas');
            if (target[0]) {
                target = target[0];
            }
            $.data(target, '_jqs_vcanvas', this);
            $(this.canvas).css({ display: 'inline-block', width: width, height: height, verticalAlign: 'top' });
            this._insert(this.canvas, target);
            this._calculatePixelDims(width, height, this.canvas);
            this.canvas.width = this.pixelWidth;
            this.canvas.height = this.pixelHeight;
            this.interact = interact;
            this.shapes = {};
            this.shapeseq = [];
            this.currentTargetShapeId = undefined;
            $(this.canvas).css({width: this.pixelWidth, height: this.pixelHeight});
        },

        _getContext: function (lineColor, fillColor, lineWidth) {
            var context = this.canvas.getContext('2d');
            if (lineColor !== undefined) {
                context.strokeStyle = lineColor;
            }
            context.lineWidth = lineWidth === undefined ? 1 : lineWidth;
            if (fillColor !== undefined) {
                context.fillStyle = fillColor;
            }
            return context;
        },

        reset: function () {
            var context = this._getContext();
            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
            this.shapes = {};
            this.shapeseq = [];
            this.currentTargetShapeId = undefined;
        },

        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
            var context = this._getContext(lineColor, fillColor, lineWidth),
                i, plen;
            context.beginPath();
            context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);
            for (i = 1, plen = path.length; i < plen; i++) {
                context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines
            }
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor !== undefined) {
                context.fill();
            }
            if (this.targetX !== undefined && this.targetY !== undefined &&
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
        },

        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
            var context = this._getContext(lineColor, fillColor, lineWidth);
            context.beginPath();
            context.arc(x, y, radius, 0, 2 * Math.PI, false);
            if (this.targetX !== undefined && this.targetY !== undefined &&
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor !== undefined) {
                context.fill();
            }
        },

        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            var context = this._getContext(lineColor, fillColor);
            context.beginPath();
            context.moveTo(x, y);
            context.arc(x, y, radius, startAngle, endAngle, false);
            context.lineTo(x, y);
            context.closePath();
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor) {
                context.fill();
            }
            if (this.targetX !== undefined && this.targetY !== undefined &&
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
        },

        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
            return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);
        },

        appendShape: function (shape) {
            this.shapes[shape.id] = shape;
            this.shapeseq.push(shape.id);
            this.lastShapeId = shape.id;
            return shape.id;
        },

        replaceWithShape: function (shapeid, shape) {
            var shapeseq = this.shapeseq,
                i;
            this.shapes[shape.id] = shape;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] == shapeid) {
                    shapeseq[i] = shape.id;
                }
            }
            delete this.shapes[shapeid];
        },

        replaceWithShapes: function (shapeids, shapes) {
            var shapeseq = this.shapeseq,
                shapemap = {},
                sid, i, first;

            for (i = shapeids.length; i--;) {
                shapemap[shapeids[i]] = true;
            }
            for (i = shapeseq.length; i--;) {
                sid = shapeseq[i];
                if (shapemap[sid]) {
                    shapeseq.splice(i, 1);
                    delete this.shapes[sid];
                    first = i;
                }
            }
            for (i = shapes.length; i--;) {
                shapeseq.splice(first, 0, shapes[i].id);
                this.shapes[shapes[i].id] = shapes[i];
            }

        },

        insertAfterShape: function (shapeid, shape) {
            var shapeseq = this.shapeseq,
                i;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] === shapeid) {
                    shapeseq.splice(i + 1, 0, shape.id);
                    this.shapes[shape.id] = shape;
                    return;
                }
            }
        },

        removeShapeId: function (shapeid) {
            var shapeseq = this.shapeseq,
                i;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] === shapeid) {
                    shapeseq.splice(i, 1);
                    break;
                }
            }
            delete this.shapes[shapeid];
        },

        getShapeAt: function (el, x, y) {
            this.targetX = x;
            this.targetY = y;
            this.render();
            return this.currentTargetShapeId;
        },

        render: function () {
            var shapeseq = this.shapeseq,
                shapes = this.shapes,
                shapeCount = shapeseq.length,
                context = this._getContext(),
                shapeid, shape, i;
            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
            for (i = 0; i < shapeCount; i++) {
                shapeid = shapeseq[i];
                shape = shapes[shapeid];
                this['_draw' + shape.type].apply(this, shape.args);
            }
            if (!this.interact) {
                // not interactive so no need to keep the shapes array
                this.shapes = {};
                this.shapeseq = [];
            }
        }

    });

    VCanvas_vml = createClass(VCanvas_base, {
        init: function (width, height, target) {
            var groupel;
            VCanvas_vml._super.init.call(this, width, height, target);
            if (target[0]) {
                target = target[0];
            }
            $.data(target, '_jqs_vcanvas', this);
            this.canvas = document.createElement('span');
            $(this.canvas).css({ display: 'inline-block', position: 'relative', overflow: 'hidden', width: width, height: height, margin: '0px', padding: '0px', verticalAlign: 'top'});
            this._insert(this.canvas, target);
            this._calculatePixelDims(width, height, this.canvas);
            this.canvas.width = this.pixelWidth;
            this.canvas.height = this.pixelHeight;
            groupel = '<v:group coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '"' +
                    ' style="position:absolute;top:0;left:0;width:' + this.pixelWidth + 'px;height=' + this.pixelHeight + 'px;"></v:group>';
            this.canvas.insertAdjacentHTML('beforeEnd', groupel);
            this.group = $(this.canvas).children()[0];
            this.rendered = false;
            this.prerender = '';
        },

        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
            var vpath = [],
                initial, stroke, fill, closed, vel, plen, i;
            for (i = 0, plen = path.length; i < plen; i++) {
                vpath[i] = '' + (path[i][0]) + ',' + (path[i][1]);
            }
            initial = vpath.splice(0, 1);
            lineWidth = lineWidth === undefined ? 1 : lineWidth;
            stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
            fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
            closed = vpath[0] === vpath[vpath.length - 1] ? 'x ' : '';
            vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' +
                 ' id="jqsshape' + shapeid + '" ' +
                 stroke +
                 fill +
                ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;" ' +
                ' path="m ' + initial + ' l ' + vpath.join(', ') + ' ' + closed + 'e">' +
                ' </v:shape>';
            return vel;
        },

        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
            var stroke, fill, vel;
            x -= radius;
            y -= radius;
            stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
            fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
            vel = '<v:oval ' +
                 ' id="jqsshape' + shapeid + '" ' +
                stroke +
                fill +
                ' style="position:absolute;top:' + y + 'px; left:' + x + 'px; width:' + (radius * 2) + 'px; height:' + (radius * 2) + 'px"></v:oval>';
            return vel;

        },

        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            var vpath, startx, starty, endx, endy, stroke, fill, vel;
            if (startAngle === endAngle) {
                return;  // VML seems to have problem when start angle equals end angle.
            }
            if ((endAngle - startAngle) === (2 * Math.PI)) {
                startAngle = 0.0;  // VML seems to have a problem when drawing a full circle that doesn't start 0
                endAngle = (2 * Math.PI);
            }

            startx = x + Math.round(Math.cos(startAngle) * radius);
            starty = y + Math.round(Math.sin(startAngle) * radius);
            endx = x + Math.round(Math.cos(endAngle) * radius);
            endy = y + Math.round(Math.sin(endAngle) * radius);

            // Prevent very small slices from being mistaken as a whole pie
            if (startx === endx && starty === endy && (endAngle - startAngle) < Math.PI) {
                return;
            }

            vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];
            stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + lineColor + '" ';
            fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
            vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' +
                 ' id="jqsshape' + shapeid + '" ' +
                 stroke +
                 fill +
                ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;" ' +
                ' path="m ' + x + ',' + y + ' wa ' + vpath.join(', ') + ' x e">' +
                ' </v:shape>';
            return vel;
        },

        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
            return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);
        },

        reset: function () {
            this.group.innerHTML = '';
        },

        appendShape: function (shape) {
            var vel = this['_draw' + shape.type].apply(this, shape.args);
            if (this.rendered) {
                this.group.insertAdjacentHTML('beforeEnd', vel);
            } else {
                this.prerender += vel;
            }
            this.lastShapeId = shape.id;
            return shape.id;
        },

        replaceWithShape: function (shapeid, shape) {
            var existing = $('#jqsshape' + shapeid),
                vel = this['_draw' + shape.type].apply(this, shape.args);
            existing[0].outerHTML = vel;
        },

        replaceWithShapes: function (shapeids, shapes) {
            // replace the first shapeid with all the new shapes then toast the remaining old shapes
            var existing = $('#jqsshape' + shapeids[0]),
                replace = '',
                slen = shapes.length,
                i;
            for (i = 0; i < slen; i++) {
                replace += this['_draw' + shapes[i].type].apply(this, shapes[i].args);
            }
            existing[0].outerHTML = replace;
            for (i = 1; i < shapeids.length; i++) {
                $('#jqsshape' + shapeids[i]).remove();
            }
        },

        insertAfterShape: function (shapeid, shape) {
            var existing = $('#jqsshape' + shapeid),
                 vel = this['_draw' + shape.type].apply(this, shape.args);
            existing[0].insertAdjacentHTML('afterEnd', vel);
        },

        removeShapeId: function (shapeid) {
            var existing = $('#jqsshape' + shapeid);
            this.group.removeChild(existing[0]);
        },

        getShapeAt: function (el, x, y) {
            var shapeid = el.id.substr(8);
            return shapeid;
        },

        render: function () {
            if (!this.rendered) {
                // batch the intial render into a single repaint
                this.group.innerHTML = this.prerender;
                this.rendered = true;
            }
        }
    });

}));
; /* ************************ new file ************************ */
/*
 * File:        jquery.dataTables.js
 * Version:     1.7.4
 * Description: Paginate, search and sort HTML tables
 * Author:      Allan Jardine (www.sprymedia.co.uk)
 * Created:     28/3/2008
 * Language:    Javascript
 * License:     GPL v2 or BSD 3 point style
 * Project:     Mtaala
 * Contact:     allan.jardine@sprymedia.co.uk
 * 
 * Copyright 2008-2010 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, as supplied with this software.
 * 
 * This source file is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 * 
 * For details please refer to: http://www.datatables.net
 */

/*
 * When considering jsLint, we need to allow eval() as it it is used for reading cookies and 
 * building the dynamic multi-column sort functions.
 */
/*jslint evil: true, undef: true, browser: true */
/*globals $, jQuery,_fnExternApiFunc,_fnInitalise,_fnLanguageProcess,_fnAddColumn,_fnColumnOptions,_fnAddData,_fnGatherData,_fnDrawHead,_fnDraw,_fnReDraw,_fnAjaxUpdate,_fnAjaxUpdateDraw,_fnAddOptionsHtml,_fnFeatureHtmlTable,_fnScrollDraw,_fnAjustColumnSizing,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnBuildSearchArray,_fnBuildSearchRow,_fnFilterCreateSearch,_fnDataToSearch,_fnSort,_fnSortAttachListener,_fnSortingClasses,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnFeatureHtmlLength,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnNodeToDataIndex,_fnVisbleColumns,_fnCalculateEnd,_fnConvertToWidth,_fnCalculateColumnWidths,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnArrayCmp,_fnDetectType,_fnSettingsFromNode,_fnGetDataMaster,_fnGetTrNodes,_fnGetTdNodes,_fnEscapeRegex,_fnDeleteIndex,_fnReOrderIndex,_fnColumnOrdering,_fnLog,_fnClearTable,_fnSaveState,_fnLoadState,_fnCreateCookie,_fnReadCookie,_fnGetUniqueThs,_fnScrollBarWidth,_fnApplyToChildren,_fnMap*/

(function($, window, document) {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Section - DataTables variables
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	/*
	 * Variable: dataTableSettings
	 * Purpose:  Store the settings for each dataTables instance
	 * Scope:    jQuery.fn
	 */
	$.fn.dataTableSettings = [];
	var _aoSettings = $.fn.dataTableSettings; /* Short reference for fast internal lookup */
	
	/*
	 * Variable: dataTableExt
	 * Purpose:  Container for customisable parts of DataTables
	 * Scope:    jQuery.fn
	 */
	$.fn.dataTableExt = {};
	var _oExt = $.fn.dataTableExt;
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Section - DataTables extensible objects
	 * 
	 * The _oExt object is used to provide an area where user dfined plugins can be 
	 * added to DataTables. The following properties of the object are used:
	 *   oApi - Plug-in API functions
	 *   aTypes - Auto-detection of types
	 *   oSort - Sorting functions used by DataTables (based on the type)
	 *   oPagination - Pagination functions for different input styles
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	/*
	 * Variable: sVersion
	 * Purpose:  Version string for plug-ins to check compatibility
	 * Scope:    jQuery.fn.dataTableExt
	 * Notes:    Allowed format is a.b.c.d.e where:
	 *   a:int, b:int, c:int, d:string(dev|beta), e:int. d and e are optional
	 */
	_oExt.sVersion = "1.7.4";
	
	/*
	 * Variable: sErrMode
	 * Purpose:  How should DataTables report an error. Can take the value 'alert' or 'throw'
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt.sErrMode = "alert";
	
	/*
	 * Variable: iApiIndex
	 * Purpose:  Index for what 'this' index API functions should use
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt.iApiIndex = 0;
	
	/*
	 * Variable: oApi
	 * Purpose:  Container for plugin API functions
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt.oApi = { };
	
	/*
	 * Variable: aFiltering
	 * Purpose:  Container for plugin filtering functions
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt.afnFiltering = [ ];
	
	/*
	 * Variable: aoFeatures
	 * Purpose:  Container for plugin function functions
	 * Scope:    jQuery.fn.dataTableExt
	 * Notes:    Array of objects with the following parameters:
	 *   fnInit: Function for initialisation of Feature. Takes oSettings and returns node
	 *   cFeature: Character that will be matched in sDom - case sensitive
	 *   sFeature: Feature name - just for completeness :-)
	 */
	_oExt.aoFeatures = [ ];
	
	/*
	 * Variable: ofnSearch
	 * Purpose:  Container for custom filtering functions
	 * Scope:    jQuery.fn.dataTableExt
	 * Notes:    This is an object (the name should match the type) for custom filtering function,
	 *   which can be used for live DOM checking or formatted text filtering
	 */
	_oExt.ofnSearch = { };
	
	/*
	 * Variable: afnSortData
	 * Purpose:  Container for custom sorting data source functions
	 * Scope:    jQuery.fn.dataTableExt
	 * Notes:    Array (associative) of functions which is run prior to a column of this 
	 *   'SortDataType' being sorted upon.
	 *   Function input parameters:
	 *     object:oSettings-  DataTables settings object
	 *     int:iColumn - Target column number
	 *   Return value: Array of data which exactly matched the full data set size for the column to
	 *     be sorted upon
	 */
	_oExt.afnSortData = [ ];
	
	/*
	 * Variable: oStdClasses
	 * Purpose:  Storage for the various classes that DataTables uses
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt.oStdClasses = {
		/* Two buttons buttons */
		"sPagePrevEnabled": "paginate_enabled_previous",
		"sPagePrevDisabled": "paginate_disabled_previous",
		"sPageNextEnabled": "paginate_enabled_next",
		"sPageNextDisabled": "paginate_disabled_next",
		"sPageJUINext": "",
		"sPageJUIPrev": "",
		
		/* Full numbers paging buttons */
		"sPageButton": "paginate_button",
		"sPageButtonActive": "paginate_active",
		"sPageButtonStaticDisabled": "paginate_button",
		"sPageFirst": "first",
		"sPagePrevious": "previous",
		"sPageNext": "next",
		"sPageLast": "last",
		
		/* Stripping classes */
		"sStripOdd": "odd",
		"sStripEven": "even",
		
		/* Empty row */
		"sRowEmpty": "dataTables_empty",
		
		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",
		
		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_asc_disabled",
		"sSortableDesc": "sorting_desc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		
		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",
		
		/* Misc */
		"sFooterTH": ""
	};
	
	/*
	 * Variable: oJUIClasses
	 * Purpose:  Storage for the various classes that DataTables uses - jQuery UI suitable
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt.oJUIClasses = {
		/* Two buttons buttons */
		"sPagePrevEnabled": "fg-button ui-button ui-state-default ui-corner-left",
		"sPagePrevDisabled": "fg-button ui-button ui-state-default ui-corner-left ui-state-disabled",
		"sPageNextEnabled": "fg-button ui-button ui-state-default ui-corner-right",
		"sPageNextDisabled": "fg-button ui-button ui-state-default ui-corner-right ui-state-disabled",
		"sPageJUINext": "ui-icon ui-icon-circle-arrow-e",
		"sPageJUIPrev": "ui-icon ui-icon-circle-arrow-w",
		
		/* Full numbers paging buttons */
		"sPageButton": "fg-button ui-button ui-state-default",
		"sPageButtonActive": "fg-button ui-button ui-state-default ui-state-disabled",
		"sPageButtonStaticDisabled": "fg-button ui-button ui-state-default ui-state-disabled",
		"sPageFirst": "first ui-corner-tl ui-corner-bl",
		"sPagePrevious": "previous",
		"sPageNext": "next",
		"sPageLast": "last ui-corner-tr ui-corner-br",
		
		/* Stripping classes */
		"sStripOdd": "odd",
		"sStripEven": "even",
		
		/* Empty row */
		"sRowEmpty": "dataTables_empty",
		
		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
			"ui-buttonset-multi paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",
		
		/* Sorting */
		"sSortAsc": "ui-state-default",
		"sSortDesc": "ui-state-default",
		"sSortable": "ui-state-default",
		"sSortableAsc": "ui-state-default",
		"sSortableDesc": "ui-state-default",
		"sSortableNone": "ui-state-default",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
		"sSortJUIAsc": "css_right ui-icon ui-icon-triangle-1-n",
		"sSortJUIDesc": "css_right ui-icon ui-icon-triangle-1-s",
		"sSortJUI": "css_right ui-icon ui-icon-carat-2-n-s",
		"sSortJUIAscAllowed": "css_right ui-icon ui-icon-carat-1-n",
		"sSortJUIDescAllowed": "css_right ui-icon ui-icon-carat-1-s",
		"sSortJUIWrapper": "DataTables_sort_wrapper",
		
		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead ui-state-default",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot ui-state-default",
		"sScrollFootInner": "dataTables_scrollFootInner",
		
		/* Misc */
		"sFooterTH": "ui-state-default"
	};
	
	/*
	 * Variable: oPagination
	 * Purpose:  Container for the various type of pagination that dataTables supports
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt.oPagination = {
		/*
		 * Variable: two_button
		 * Purpose:  Standard two button (forward/back) pagination
	 	 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"two_button": {
			/*
			 * Function: oPagination.two_button.fnInit
			 * Purpose:  Initalise dom elements required for pagination with forward/back buttons only
			 * Returns:  -
	 		 * Inputs:   object:oSettings - dataTables settings object
	     *           node:nPaging - the DIV which contains this pagination control
			 *           function:fnCallbackDraw - draw function which must be called on update
			 */
			"fnInit": function ( oSettings, nPaging, fnCallbackDraw )
			{
				var nPrevious, nNext, nPreviousInner, nNextInner;
				
				/* Store the next and previous elements in the oSettings object as they can be very
				 * usful for automation - particularly testing
				 */
				if ( !oSettings.bJUI )
				{
					nPrevious = document.createElement( 'div' );
					nNext = document.createElement( 'div' );
				}
				else
				{
					nPrevious = document.createElement( 'a' );
					nNext = document.createElement( 'a' );
					
					nNextInner = document.createElement('span');
					nNextInner.className = oSettings.oClasses.sPageJUINext;
					nNext.appendChild( nNextInner );
					
					nPreviousInner = document.createElement('span');
					nPreviousInner.className = oSettings.oClasses.sPageJUIPrev;
					nPrevious.appendChild( nPreviousInner );
				}
				
				nPrevious.className = oSettings.oClasses.sPagePrevDisabled;
				nNext.className = oSettings.oClasses.sPageNextDisabled;
				
				nPrevious.title = oSettings.oLanguage.oPaginate.sPrevious;
				nNext.title = oSettings.oLanguage.oPaginate.sNext;
				
				nPaging.appendChild( nPrevious );
				nPaging.appendChild( nNext );
				
				$(nPrevious).click( function() {
					if ( oSettings.oApi._fnPageChange( oSettings, "previous" ) )
					{
						/* Only draw when the page has actually changed */
						fnCallbackDraw( oSettings );
					}
				} );
				
				$(nNext).click( function() {
					if ( oSettings.oApi._fnPageChange( oSettings, "next" ) )
					{
						fnCallbackDraw( oSettings );
					}
				} );
				
				/* Take the brutal approach to cancelling text selection */
				$(nPrevious).bind( 'selectstart', function () { return false; } );
				$(nNext).bind( 'selectstart', function () { return false; } );
				
				/* ID the first elements only */
				if ( oSettings.sTableId !== '' && typeof oSettings.aanFeatures.p == "undefined" )
				{
					nPaging.setAttribute( 'id', oSettings.sTableId+'_paginate' );
					nPrevious.setAttribute( 'id', oSettings.sTableId+'_previous' );
					nNext.setAttribute( 'id', oSettings.sTableId+'_next' );
				}
			},
			
			/*
			 * Function: oPagination.two_button.fnUpdate
			 * Purpose:  Update the two button pagination at the end of the draw
			 * Returns:  -
	 		 * Inputs:   object:oSettings - dataTables settings object
			 *           function:fnCallbackDraw - draw function to call on page change
			 */
			"fnUpdate": function ( oSettings, fnCallbackDraw )
			{
				if ( !oSettings.aanFeatures.p )
				{
					return;
				}
				
				/* Loop over each instance of the pager */
				var an = oSettings.aanFeatures.p;
				for ( var i=0, iLen=an.length ; i<iLen ; i++ )
				{
					if ( an[i].childNodes.length !== 0 )
					{
						an[i].childNodes[0].className = 
							( oSettings._iDisplayStart === 0 ) ? 
							oSettings.oClasses.sPagePrevDisabled : oSettings.oClasses.sPagePrevEnabled;
						
						an[i].childNodes[1].className = 
							( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) ? 
							oSettings.oClasses.sPageNextDisabled : oSettings.oClasses.sPageNextEnabled;
					}
				}
			}
		},
		
		
		/*
		 * Variable: iFullNumbersShowPages
		 * Purpose:  Change the number of pages which can be seen
	 	 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"iFullNumbersShowPages": 5,
		
		/*
		 * Variable: full_numbers
		 * Purpose:  Full numbers pagination
	 	 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"full_numbers": {
			/*
			 * Function: oPagination.full_numbers.fnInit
			 * Purpose:  Initalise dom elements required for pagination with a list of the pages
			 * Returns:  -
	 		 * Inputs:   object:oSettings - dataTables settings object
	     *           node:nPaging - the DIV which contains this pagination control
			 *           function:fnCallbackDraw - draw function which must be called on update
			 */
			"fnInit": function ( oSettings, nPaging, fnCallbackDraw )
			{
				var nFirst = document.createElement( 'span' );
				var nPrevious = document.createElement( 'span' );
				var nList = document.createElement( 'span' );
				var nNext = document.createElement( 'span' );
				var nLast = document.createElement( 'span' );
				
				nFirst.innerHTML = oSettings.oLanguage.oPaginate.sFirst;
				nPrevious.innerHTML = oSettings.oLanguage.oPaginate.sPrevious;
				nNext.innerHTML = oSettings.oLanguage.oPaginate.sNext;
				nLast.innerHTML = oSettings.oLanguage.oPaginate.sLast;
				
				var oClasses = oSettings.oClasses;
				nFirst.className = oClasses.sPageButton+" "+oClasses.sPageFirst;
				nPrevious.className = oClasses.sPageButton+" "+oClasses.sPagePrevious;
				nNext.className= oClasses.sPageButton+" "+oClasses.sPageNext;
				nLast.className = oClasses.sPageButton+" "+oClasses.sPageLast;
				
				nPaging.appendChild( nFirst );
				nPaging.appendChild( nPrevious );
				nPaging.appendChild( nList );
				nPaging.appendChild( nNext );
				nPaging.appendChild( nLast );
				
				$(nFirst).click( function () {
					if ( oSettings.oApi._fnPageChange( oSettings, "first" ) )
					{
						fnCallbackDraw( oSettings );
					}
				} );
				
				$(nPrevious).click( function() {
					if ( oSettings.oApi._fnPageChange( oSettings, "previous" ) )
					{
						fnCallbackDraw( oSettings );
					}
				} );
				
				$(nNext).click( function() {
					if ( oSettings.oApi._fnPageChange( oSettings, "next" ) )
					{
						fnCallbackDraw( oSettings );
					}
				} );
				
				$(nLast).click( function() {
					if ( oSettings.oApi._fnPageChange( oSettings, "last" ) )
					{
						fnCallbackDraw( oSettings );
					}
				} );
				
				/* Take the brutal approach to cancelling text selection */
				$('span', nPaging)
					.bind( 'mousedown', function () { return false; } )
					.bind( 'selectstart', function () { return false; } );
				
				/* ID the first elements only */
				if ( oSettings.sTableId !== '' && typeof oSettings.aanFeatures.p == "undefined" )
				{
					nPaging.setAttribute( 'id', oSettings.sTableId+'_paginate' );
					nFirst.setAttribute( 'id', oSettings.sTableId+'_first' );
					nPrevious.setAttribute( 'id', oSettings.sTableId+'_previous' );
					nNext.setAttribute( 'id', oSettings.sTableId+'_next' );
					nLast.setAttribute( 'id', oSettings.sTableId+'_last' );
				}
			},
			
			/*
			 * Function: oPagination.full_numbers.fnUpdate
			 * Purpose:  Update the list of page buttons shows
			 * Returns:  -
	 		 * Inputs:   object:oSettings - dataTables settings object
			 *           function:fnCallbackDraw - draw function to call on page change
			 */
			"fnUpdate": function ( oSettings, fnCallbackDraw )
			{
				if ( !oSettings.aanFeatures.p )
				{
					return;
				}
				
				var iPageCount = _oExt.oPagination.iFullNumbersShowPages;
				var iPageCountHalf = Math.floor(iPageCount / 2);
				var iPages = Math.ceil((oSettings.fnRecordsDisplay()) / oSettings._iDisplayLength);
				var iCurrentPage = Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength) + 1;
				var sList = "";
				var iStartButton, iEndButton, i, iLen;
				var oClasses = oSettings.oClasses;
				
				/* Pages calculation */
				if (iPages < iPageCount)
				{
					iStartButton = 1;
					iEndButton = iPages;
				}
				else
				{
					if (iCurrentPage <= iPageCountHalf)
					{
						iStartButton = 1;
						iEndButton = iPageCount;
					}
					else
					{
						if (iCurrentPage >= (iPages - iPageCountHalf))
						{
							iStartButton = iPages - iPageCount + 1;
							iEndButton = iPages;
						}
						else
						{
							iStartButton = iCurrentPage - Math.ceil(iPageCount / 2) + 1;
							iEndButton = iStartButton + iPageCount - 1;
						}
					}
				}
				
				/* Build the dynamic list */
				for ( i=iStartButton ; i<=iEndButton ; i++ )
				{
					if ( iCurrentPage != i )
					{
						sList += '<span class="'+oClasses.sPageButton+'">'+i+'</span>';
					}
					else
					{
						sList += '<span class="'+oClasses.sPageButtonActive+'">'+i+'</span>';
					}
				}
				
				/* Loop over each instance of the pager */
				var an = oSettings.aanFeatures.p;
				var anButtons, anStatic, nPaginateList;
				var fnClick = function() {
					/* Use the information in the element to jump to the required page */
					var iTarget = (this.innerHTML * 1) - 1;
					oSettings._iDisplayStart = iTarget * oSettings._iDisplayLength;
					fnCallbackDraw( oSettings );
					return false;
				};
				var fnFalse = function () { return false; };
				
				for ( i=0, iLen=an.length ; i<iLen ; i++ )
				{
					if ( an[i].childNodes.length === 0 )
					{
						continue;
					}
					
					/* Build up the dynamic list forst - html and listeners */
					var qjPaginateList = $('span:eq(2)', an[i]);
					qjPaginateList.html( sList );
					$('span', qjPaginateList).click( fnClick ).bind( 'mousedown', fnFalse )
						.bind( 'selectstart', fnFalse );
					
					/* Update the 'premanent botton's classes */
					anButtons = an[i].getElementsByTagName('span');
					anStatic = [
						anButtons[0], anButtons[1], 
						anButtons[anButtons.length-2], anButtons[anButtons.length-1]
					];
					$(anStatic).removeClass( oClasses.sPageButton+" "+oClasses.sPageButtonActive+" "+oClasses.sPageButtonStaticDisabled );
					if ( iCurrentPage == 1 )
					{
						anStatic[0].className += " "+oClasses.sPageButtonStaticDisabled;
						anStatic[1].className += " "+oClasses.sPageButtonStaticDisabled;
					}
					else
					{
						anStatic[0].className += " "+oClasses.sPageButton;
						anStatic[1].className += " "+oClasses.sPageButton;
					}
					
					if ( iPages === 0 || iCurrentPage == iPages || oSettings._iDisplayLength == -1 )
					{
						anStatic[2].className += " "+oClasses.sPageButtonStaticDisabled;
						anStatic[3].className += " "+oClasses.sPageButtonStaticDisabled;
					}
					else
					{
						anStatic[2].className += " "+oClasses.sPageButton;
						anStatic[3].className += " "+oClasses.sPageButton;
					}
				}
			}
		}
	};
	
	/*
	 * Variable: oSort
	 * Purpose:  Wrapper for the sorting functions that can be used in DataTables
	 * Scope:    jQuery.fn.dataTableExt
	 * Notes:    The functions provided in this object are basically standard javascript sort
	 *   functions - they expect two inputs which they then compare and then return a priority
	 *   result. For each sort method added, two functions need to be defined, an ascending sort and
	 *   a descending sort.
	 */
	_oExt.oSort = {
		/*
		 * text sorting
		 */
		"string-asc": function ( a, b )
		{
			var x = a.toLowerCase();
			var y = b.toLowerCase();
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
		
		"string-desc": function ( a, b )
		{
			var x = a.toLowerCase();
			var y = b.toLowerCase();
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		},
		
		
		/*
		 * html sorting (ignore html tags)
		 */
		"html-asc": function ( a, b )
		{
			var x = a.replace( /<.*?>/g, "" ).toLowerCase();
			var y = b.replace( /<.*?>/g, "" ).toLowerCase();
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
		
		"html-desc": function ( a, b )
		{
			var x = a.replace( /<.*?>/g, "" ).toLowerCase();
			var y = b.replace( /<.*?>/g, "" ).toLowerCase();
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		},
		
		
		/*
		 * date sorting
		 */
		"date-asc": function ( a, b )
		{
			var x = Date.parse( a );
			var y = Date.parse( b );
			
			if ( isNaN(x) || x==="" )
			{
    		x = Date.parse( "01/01/1970 00:00:00" );
			}
			if ( isNaN(y) || y==="" )
			{
				y =	Date.parse( "01/01/1970 00:00:00" );
			}
			
			return x - y;
		},
		
		"date-desc": function ( a, b )
		{
			var x = Date.parse( a );
			var y = Date.parse( b );
			
			if ( isNaN(x) || x==="" )
			{
    		x = Date.parse( "01/01/1970 00:00:00" );
			}
			if ( isNaN(y) || y==="" )
			{
				y =	Date.parse( "01/01/1970 00:00:00" );
			}
			
			return y - x;
		},
		
		
		/*
		 * numerical sorting
		 */
		"numeric-asc": function ( a, b )
		{
			var x = (a=="-" || a==="") ? 0 : a*1;
			var y = (b=="-" || b==="") ? 0 : b*1;
			return x - y;
		},
		
		"numeric-desc": function ( a, b )
		{
			var x = (a=="-" || a==="") ? 0 : a*1;
			var y = (b=="-" || b==="") ? 0 : b*1;
			return y - x;
		}
	};
	
	
	/*
	 * Variable: aTypes
	 * Purpose:  Container for the various type of type detection that dataTables supports
	 * Scope:    jQuery.fn.dataTableExt
	 * Notes:    The functions in this array are expected to parse a string to see if it is a data
	 *   type that it recognises. If so then the function should return the name of the type (a
	 *   corresponding sort function should be defined!), if the type is not recognised then the
	 *   function should return null such that the parser and move on to check the next type.
	 *   Note that ordering is important in this array - the functions are processed linearly,
	 *   starting at index 0.
	 *   Note that the input for these functions is always a string! It cannot be any other data
	 *   type
	 */
	_oExt.aTypes = [
		/*
		 * Function: -
		 * Purpose:  Check to see if a string is numeric
		 * Returns:  string:'numeric' or null
		 * Inputs:   string:sText - string to check
		 */
		function ( sData )
		{
			/* Allow zero length strings as a number */
			if ( sData.length === 0 )
			{
				return 'numeric';
			}
			
			var sValidFirstChars = "0123456789-";
			var sValidChars = "0123456789.";
			var Char;
			var bDecimal = false;
			
			/* Check for a valid first char (no period and allow negatives) */
			Char = sData.charAt(0); 
			if (sValidFirstChars.indexOf(Char) == -1) 
			{
				return null;
			}
			
			/* Check all the other characters are valid */
			for ( var i=1 ; i<sData.length ; i++ ) 
			{
				Char = sData.charAt(i); 
				if (sValidChars.indexOf(Char) == -1) 
				{
					return null;
				}
				
				/* Only allowed one decimal place... */
				if ( Char == "." )
				{
					if ( bDecimal )
					{
						return null;
					}
					bDecimal = true;
				}
			}
			
			return 'numeric';
		},
		
		/*
		 * Function: -
		 * Purpose:  Check to see if a string is actually a formatted date
		 * Returns:  string:'date' or null
		 * Inputs:   string:sText - string to check
		 */
		function ( sData )
		{
			var iParse = Date.parse(sData);
			if ( (iParse !== null && !isNaN(iParse)) || sData.length === 0 )
			{
				return 'date';
			}
			return null;
		},
		
		/*
		 * Function: -
		 * Purpose:  Check to see if a string should be treated as an HTML string
		 * Returns:  string:'html' or null
		 * Inputs:   string:sText - string to check
		 */
		function ( sData )
		{
			if ( sData.indexOf('<') != -1 && sData.indexOf('>') != -1 )
			{
				return 'html';
			}
			return null;
		}
	];
	
	/*
	 * Function: fnVersionCheck
	 * Purpose:  Check a version string against this version of DataTables. Useful for plug-ins
	 * Returns:  bool:true -this version of DataTables is greater or equal to the required version
	 *                false -this version of DataTales is not suitable
	 * Inputs:   string:sVersion - the version to check against. May be in the following formats:
	 *             "a", "a.b" or "a.b.c"
	 * Notes:    This function will only check the first three parts of a version string. It is
	 *   assumed that beta and dev versions will meet the requirements. This might change in future
	 */
	_oExt.fnVersionCheck = function( sVersion )
	{
		/* This is cheap, but very effective */
		var fnZPad = function (Zpad, count)
		{
			while(Zpad.length < count) {
				Zpad += '0';
			}
			return Zpad;
		};
		var aThis = _oExt.sVersion.split('.');
		var aThat = sVersion.split('.');
		var sThis = '', sThat = '';
		
		for ( var i=0, iLen=aThat.length ; i<iLen ; i++ )
		{
			sThis += fnZPad( aThis[i], 3 );
			sThat += fnZPad( aThat[i], 3 );
		}
		
		return parseInt(sThis, 10) >= parseInt(sThat, 10);
	};
	
	/*
	 * Variable: _oExternConfig
	 * Purpose:  Store information for DataTables to access globally about other instances
	 * Scope:    jQuery.fn.dataTableExt
	 */
	_oExt._oExternConfig = {
		/* int:iNextUnique - next unique number for an instance */
		"iNextUnique": 0
	};
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Section - DataTables prototype
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	/*
	 * Function: dataTable
	 * Purpose:  DataTables information
	 * Returns:  -
	 * Inputs:   object:oInit - initalisation options for the table
	 */
	$.fn.dataTable = function( oInit )
	{
		/*
		 * Function: classSettings
		 * Purpose:  Settings container function for all 'class' properties which are required
		 *   by dataTables
		 * Returns:  -
		 * Inputs:   -
		 */
		function classSettings ()
		{
			this.fnRecordsTotal = function ()
			{
				if ( this.oFeatures.bServerSide ) {
					return parseInt(this._iRecordsTotal, 10);
				} else {
					return this.aiDisplayMaster.length;
				}
			};
			
			this.fnRecordsDisplay = function ()
			{
				if ( this.oFeatures.bServerSide ) {
					return parseInt(this._iRecordsDisplay, 10);
				} else {
					return this.aiDisplay.length;
				}
			};
			
			this.fnDisplayEnd = function ()
			{
				if ( this.oFeatures.bServerSide ) {
					if ( this.oFeatures.bPaginate === false || this._iDisplayLength == -1 ) {
						return this._iDisplayStart+this.aiDisplay.length;
					} else {
						return Math.min( this._iDisplayStart+this._iDisplayLength, 
							this._iRecordsDisplay );
					}
				} else {
					return this._iDisplayEnd;
				}
			};
			
			/*
			 * Variable: oInstance
			 * Purpose:  The DataTables object for this table
			 * Scope:    jQuery.dataTable.classSettings 
			 */
			this.oInstance = null;
			
			/*
			 * Variable: sInstance
			 * Purpose:  Unique idendifier for each instance of the DataTables object
			 * Scope:    jQuery.dataTable.classSettings 
			 */
			this.sInstance = null;
			
			/*
			 * Variable: oFeatures
			 * Purpose:  Indicate the enablement of key dataTable features
			 * Scope:    jQuery.dataTable.classSettings 
			 */
			this.oFeatures = {
				"bPaginate": true,
				"bLengthChange": true,
				"bFilter": true,
				"bSort": true,
				"bInfo": true,
				"bAutoWidth": true,
				"bProcessing": false,
				"bSortClasses": true,
				"bStateSave": false,
				"bServerSide": false
			};
			
			/*
			 * Variable: oScroll
			 * Purpose:  Container for scrolling options
			 * Scope:    jQuery.dataTable.classSettings 
			 */
			this.oScroll = {
				"sX": "",
				"sXInner": "",
				"sY": "",
				"bCollapse": false,
				"bInfinite": false,
				"iLoadGap": 100,
				"iBarWidth": 0
			};
			
			/*
			 * Variable: aanFeatures
			 * Purpose:  Array referencing the nodes which are used for the features
			 * Scope:    jQuery.dataTable.classSettings 
			 * Notes:    The parameters of this object match what is allowed by sDom - i.e.
			 *   'l' - Length changing
			 *   'f' - Filtering input
			 *   't' - The table!
			 *   'i' - Information
			 *   'p' - Pagination
			 *   'r' - pRocessing
			 */
			this.aanFeatures = [];
			
			/*
			 * Variable: oLanguage
			 * Purpose:  Store the language strings used by dataTables
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    The words in the format _VAR_ are variables which are dynamically replaced
			 *   by javascript
			 */
			this.oLanguage = {
				"sProcessing": "Processing...",
				"sLengthMenu": "Show _MENU_ entries",
				"sZeroRecords": "No matching records found",
				"sEmptyTable": "No data available in table",
				"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
				"sInfoEmpty": "Showing 0 to 0 of 0 entries",
				"sInfoFiltered": "(filtered from _MAX_ total entries)",
				"sInfoPostFix": "",
				"sSearch": "Search:",
				"sUrl": "",
				"oPaginate": {
					"sFirst":    "First",
					"sPrevious": "Previous",
					"sNext":     "Next",
					"sLast":     "Last"
				},
				"fnInfoCallback": null
			};
			
			/*
			 * Variable: aoData
			 * Purpose:  Store data information
			 * Scope:    jQuery.dataTable.classSettings 
			 * Notes:    This is an array of objects with the following parameters:
			 *   int: _iId - internal id for tracking
			 *   array: _aData - internal data - used for sorting / filtering etc
			 *   node: nTr - display node
			 *   array node: _anHidden - hidden TD nodes
			 *   string: _sRowStripe
			 */
			this.aoData = [];
			
			/*
			 * Variable: aiDisplay
			 * Purpose:  Array of indexes which are in the current display (after filtering etc)
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.aiDisplay = [];
			
			/*
			 * Variable: aiDisplayMaster
			 * Purpose:  Array of indexes for display - no filtering
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.aiDisplayMaster = [];
							
			/*
			 * Variable: aoColumns
			 * Purpose:  Store information about each column that is in use
			 * Scope:    jQuery.dataTable.classSettings 
			 */
			this.aoColumns = [];
			
			/*
			 * Variable: iNextId
			 * Purpose:  Store the next unique id to be used for a new row
			 * Scope:    jQuery.dataTable.classSettings 
			 */
			this.iNextId = 0;
			
			/*
			 * Variable: asDataSearch
			 * Purpose:  Search data array for regular expression searching
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.asDataSearch = [];
			
			/*
			 * Variable: oPreviousSearch
			 * Purpose:  Store the previous search incase we want to force a re-search
			 *   or compare the old search to a new one
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.oPreviousSearch = {
				"sSearch": "",
				"bRegex": false,
				"bSmart": true
			};
			
			/*
			 * Variable: aoPreSearchCols
			 * Purpose:  Store the previous search for each column
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.aoPreSearchCols = [];
			
			/*
			 * Variable: aaSorting
			 * Purpose:  Sorting information
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    Index 0 - column number
			 *           Index 1 - current sorting direction
			 *           Index 2 - index of asSorting for this column
			 */
			this.aaSorting = [ [0, 'asc', 0] ];
			
			/*
			 * Variable: aaSortingFixed
			 * Purpose:  Sorting information that is always applied
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.aaSortingFixed = null;
			
			/*
			 * Variable: asStripClasses
			 * Purpose:  Classes to use for the striping of a table
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.asStripClasses = [];
			
			/*
			 * Variable: asDestoryStrips
			 * Purpose:  If restoring a table - we should restore it's striping classes as well
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.asDestoryStrips = [];
			
			/*
			 * Variable: sDestroyWidth
			 * Purpose:  If restoring a table - we should restore it's width
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.sDestroyWidth = 0;
			
			/*
			 * Variable: fnRowCallback
			 * Purpose:  Call this function every time a row is inserted (draw)
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.fnRowCallback = null;
			
			/*
			 * Variable: fnHeaderCallback
			 * Purpose:  Callback function for the header on each draw
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.fnHeaderCallback = null;
			
			/*
			 * Variable: fnFooterCallback
			 * Purpose:  Callback function for the footer on each draw
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.fnFooterCallback = null;
			
			/*
			 * Variable: aoDrawCallback
			 * Purpose:  Array of callback functions for draw callback functions
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    Each array element is an object with the following parameters:
			 *   function:fn - function to call
			 *   string:sName - name callback (feature). useful for arranging array
			 */
			this.aoDrawCallback = [];
			
			/*
			 * Variable: fnInitComplete
			 * Purpose:  Callback function for when the table has been initalised
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.fnInitComplete = null;
			
			/*
			 * Variable: sTableId
			 * Purpose:  Cache the table ID for quick access
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.sTableId = "";
			
			/*
			 * Variable: nTable
			 * Purpose:  Cache the table node for quick access
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.nTable = null;
			
			/*
			 * Variable: nTHead
			 * Purpose:  Permanent ref to the thead element
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.nTHead = null;
			
			/*
			 * Variable: nTFoot
			 * Purpose:  Permanent ref to the tfoot element - if it exists
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.nTFoot = null;
			
			/*
			 * Variable: nTBody
			 * Purpose:  Permanent ref to the tbody element
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.nTBody = null;
			
			/*
			 * Variable: nTableWrapper
			 * Purpose:  Cache the wrapper node (contains all DataTables controlled elements)
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.nTableWrapper = null;
			
			/*
			 * Variable: bInitialised
			 * Purpose:  Indicate if all required information has been read in
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.bInitialised = false;
			
			/*
			 * Variable: aoOpenRows
			 * Purpose:  Information about open rows
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    Has the parameters 'nTr' and 'nParent'
			 */
			this.aoOpenRows = [];
			
			/*
			 * Variable: sDom
			 * Purpose:  Dictate the positioning that the created elements will take
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    
			 *   The following options are allowed:
			 *     'l' - Length changing
			 *     'f' - Filtering input
			 *     't' - The table!
			 *     'i' - Information
			 *     'p' - Pagination
			 *     'r' - pRocessing
			 *   The following constants are allowed:
			 *     'H' - jQueryUI theme "header" classes
			 *     'F' - jQueryUI theme "footer" classes
			 *   The following syntax is expected:
			 *     '<' and '>' - div elements
			 *     '<"class" and '>' - div with a class
			 *   Examples:
			 *     '<"wrapper"flipt>', '<lf<t>ip>'
			 */
			this.sDom = 'lfrtip';
			
			/*
			 * Variable: sPaginationType
			 * Purpose:  Note which type of sorting should be used
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.sPaginationType = "two_button";
			
			/*
			 * Variable: iCookieDuration
			 * Purpose:  The cookie duration (for bStateSave) in seconds - default 2 hours
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.iCookieDuration = 60 * 60 * 2;
			
			/*
			 * Variable: sCookiePrefix
			 * Purpose:  The cookie name prefix
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.sCookiePrefix = "SpryMedia_DataTables_";
			
			/*
			 * Variable: fnCookieCallback
			 * Purpose:  Callback function for cookie creation
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.fnCookieCallback = null;
			
			/*
			 * Variable: aoStateSave
			 * Purpose:  Array of callback functions for state saving
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    Each array element is an object with the following parameters:
			 *   function:fn - function to call. Takes two parameters, oSettings and the JSON string to
			 *     save that has been thus far created. Returns a JSON string to be inserted into a 
			 *     json object (i.e. '"param": [ 0, 1, 2]')
			 *   string:sName - name of callback
			 */
			this.aoStateSave = [];
			
			/*
			 * Variable: aoStateLoad
			 * Purpose:  Array of callback functions for state loading
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    Each array element is an object with the following parameters:
			 *   function:fn - function to call. Takes two parameters, oSettings and the object stored.
			 *     May return false to cancel state loading.
			 *   string:sName - name of callback
			 */
			this.aoStateLoad = [];
			
			/*
			 * Variable: oLoadedState
			 * Purpose:  State that was loaded from the cookie. Useful for back reference
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.oLoadedState = null;
			
			/*
			 * Variable: sAjaxSource
			 * Purpose:  Source url for AJAX data for the table
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.sAjaxSource = null;
			
			/*
			 * Variable: bAjaxDataGet
			 * Purpose:  Note if draw should be blocked while getting data
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.bAjaxDataGet = true;
			
			/*
			 * Variable: fnServerData
			 * Purpose:  Function to get the server-side data - can be overruled by the developer
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.fnServerData = function ( url, data, callback ) {
				$.ajax( {
					"url": url,
					"data": data,
					"success": callback,
					"dataType": "json",
					"cache": false,
					"error": function (xhr, error, thrown) {
						if ( error == "parsererror" ) {
							alert( "DataTables warning: JSON data from server could not be parsed. "+
								"This is caused by a JSON formatting error." );
						}
					}
				} );
			};
			
			/*
			 * Variable: fnFormatNumber
			 * Purpose:  Format numbers for display
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.fnFormatNumber = function ( iIn )
			{
				if ( iIn < 1000 )
				{
					/* A small optimisation for what is likely to be the vast majority of use cases */
					return iIn;
				}
				else
				{
					var s=(iIn+""), a=s.split(""), out="", iLen=s.length;
					
					for ( var i=0 ; i<iLen ; i++ )
					{
						if ( i%3 === 0 && i !== 0 )
						{
							out = ','+out;
						}
						out = a[iLen-i-1]+out;
					}
				}
				return out;
			};
			
			/*
			 * Variable: aLengthMenu
			 * Purpose:  List of options that can be used for the user selectable length menu
			 * Scope:    jQuery.dataTable.classSettings
			 * Note:     This varaible can take for form of a 1D array, in which case the value and the 
			 *   displayed value in the menu are the same, or a 2D array in which case the value comes
			 *   from the first array, and the displayed value to the end user comes from the second
			 *   array. 2D example: [ [ 10, 25, 50, 100, -1 ], [ 10, 25, 50, 100, 'All' ] ];
			 */
			this.aLengthMenu = [ 10, 25, 50, 100 ];
			
			/*
			 * Variable: iDraw
			 * Purpose:  Counter for the draws that the table does. Also used as a tracker for
			 *   server-side processing
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.iDraw = 0;
			
			/*
			 * Variable: bDrawing
			 * Purpose:  Indicate if a redraw is being done - useful for Ajax
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.bDrawing = 0;
			
			/*
			 * Variable: iDrawError
			 * Purpose:  Last draw error
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.iDrawError = -1;
			
			/*
			 * Variable: _iDisplayLength, _iDisplayStart, _iDisplayEnd
			 * Purpose:  Display length variables
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    These variable must NOT be used externally to get the data length. Rather, use
			 *   the fnRecordsTotal() (etc) functions.
			 */
			this._iDisplayLength = 10;
			this._iDisplayStart = 0;
			this._iDisplayEnd = 10;
			
			/*
			 * Variable: _iRecordsTotal, _iRecordsDisplay
			 * Purpose:  Display length variables used for server side processing
			 * Scope:    jQuery.dataTable.classSettings
			 * Notes:    These variable must NOT be used externally to get the data length. Rather, use
			 *   the fnRecordsTotal() (etc) functions.
			 */
			this._iRecordsTotal = 0;
			this._iRecordsDisplay = 0;
			
			/*
			 * Variable: bJUI
			 * Purpose:  Should we add the markup needed for jQuery UI theming?
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.bJUI = false;
			
			/*
			 * Variable: bJUI
			 * Purpose:  Should we add the markup needed for jQuery UI theming?
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.oClasses = _oExt.oStdClasses;
			
			/*
			 * Variable: bFiltered and bSorted
			 * Purpose:  Flags to allow callback functions to see what actions have been performed
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.bFiltered = false;
			this.bSorted = false;
			
			/*
			 * Variable: oInit
			 * Purpose:  Initialisation object that is used for the table
			 * Scope:    jQuery.dataTable.classSettings
			 */
			this.oInit = null;
		}
		
		/*
		 * Variable: oApi
		 * Purpose:  Container for publicly exposed 'private' functions
		 * Scope:    jQuery.dataTable
		 */
		this.oApi = {};
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - API functions
		 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		
		/*
		 * Function: fnDraw
		 * Purpose:  Redraw the table
		 * Returns:  -
		 * Inputs:   bool:bComplete - Refilter and resort (if enabled) the table before the draw.
		 *             Optional: default - true
		 */
		this.fnDraw = function( bComplete )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			if ( typeof bComplete != 'undefined' && bComplete === false )
			{
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
			else
			{
				_fnReDraw( oSettings );
			}
		};
		
		/*
		 * Function: fnFilter
		 * Purpose:  Filter the input based on data
		 * Returns:  -
		 * Inputs:   string:sInput - string to filter the table on
		 *           int:iColumn - optional - column to limit filtering to
		 *           bool:bRegex - optional - treat as regular expression or not - default false
		 *           bool:bSmart - optional - perform smart filtering or not - default true
		 *           bool:bShowGlobal - optional - show the input global filter in it's input box(es)
		 *              - default true
		 */
		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			
			if ( !oSettings.oFeatures.bFilter )
			{
				return;
			}
			
			if ( typeof bRegex == 'undefined' )
			{
				bRegex = false;
			}
			
			if ( typeof bSmart == 'undefined' )
			{
				bSmart = true;
			}
			
			if ( typeof bShowGlobal == 'undefined' )
			{
				bShowGlobal = true;
			}
			
			if ( typeof iColumn == "undefined" || iColumn === null )
			{
				/* Global filter */
				_fnFilterComplete( oSettings, {
					"sSearch":sInput,
					"bRegex": bRegex,
					"bSmart": bSmart
				}, 1 );
				
				if ( bShowGlobal && typeof oSettings.aanFeatures.f != 'undefined' )
				{
					var n = oSettings.aanFeatures.f;
					for ( var i=0, iLen=n.length ; i<iLen ; i++ )
					{
						$('input', n[i]).val( sInput );
					}
				}
			}
			else
			{
				/* Single column filter */
				oSettings.aoPreSearchCols[ iColumn ].sSearch = sInput;
				oSettings.aoPreSearchCols[ iColumn ].bRegex = bRegex;
				oSettings.aoPreSearchCols[ iColumn ].bSmart = bSmart;
				_fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
			}
		};
		
		/*
		 * Function: fnSettings
		 * Purpose:  Get the settings for a particular table for extern. manipulation
		 * Returns:  -
		 * Inputs:   -
		 */
		this.fnSettings = function( nNode  )
		{
			return _fnSettingsFromNode( this[_oExt.iApiIndex] );
		};
		
		/*
		 * Function: fnVersionCheck
		 * Notes:    The function is the same as the 'static' function provided in the ext variable
		 */
		this.fnVersionCheck = _oExt.fnVersionCheck;
		
		/*
		 * Function: fnSort
		 * Purpose:  Sort the table by a particular row
		 * Returns:  -
		 * Inputs:   int:iCol - the data index to sort on. Note that this will
		 *   not match the 'display index' if you have hidden data entries
		 */
		this.fnSort = function( aaSort )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			oSettings.aaSorting = aaSort;
			_fnSort( oSettings );
		};
		
		/*
		 * Function: fnSortListener
		 * Purpose:  Attach a sort listener to an element for a given column
		 * Returns:  -
		 * Inputs:   node:nNode - the element to attach the sort listener to
		 *           int:iColumn - the column that a click on this node will sort on
		 *           function:fnCallback - callback function when sort is run - optional
		 */
		this.fnSortListener = function( nNode, iColumn, fnCallback )
		{
			_fnSortAttachListener( _fnSettingsFromNode( this[_oExt.iApiIndex] ), nNode, iColumn,
			 	fnCallback );
		};
		
		/*
		 * Function: fnAddData
		 * Purpose:  Add new row(s) into the table
		 * Returns:  array int: array of indexes (aoData) which have been added (zero length on error)
		 * Inputs:   array:mData - the data to be added. The length must match
		 *               the original data from the DOM
		 *             or
		 *             array array:mData - 2D array of data to be added
		 *           bool:bRedraw - redraw the table or not - default true
		 * Notes:    Warning - the refilter here will cause the table to redraw
		 *             starting at zero
		 * Notes:    Thanks to Yekimov Denis for contributing the basis for this function!
		 */
		this.fnAddData = function( mData, bRedraw )
		{
			if ( mData.length === 0 )
			{
				return [];
			}
			
			var aiReturn = [];
			var iTest;
			
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			
			/* Check if we want to add multiple rows or not */
			if ( typeof mData[0] == "object" )
			{
				for ( var i=0 ; i<mData.length ; i++ )
				{
					iTest = _fnAddData( oSettings, mData[i] );
					if ( iTest == -1 )
					{
						return aiReturn;
					}
					aiReturn.push( iTest );
				}
			}
			else
			{
				iTest = _fnAddData( oSettings, mData );
				if ( iTest == -1 )
				{
					return aiReturn;
				}
				aiReturn.push( iTest );
			}
			
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
			if ( typeof bRedraw == 'undefined' || bRedraw )
			{
				_fnReDraw( oSettings );
			}
			return aiReturn;
		};
		
		/*
		 * Function: fnDeleteRow
		 * Purpose:  Remove a row for the table
		 * Returns:  array:aReturn - the row that was deleted
		 * Inputs:   mixed:mTarget - 
		 *             int: - index of aoData to be deleted, or
		 *             node(TR): - TR element you want to delete
		 *           function:fnCallBack - callback function - default null
		 *           bool:bRedraw - redraw the table or not - default true
		 */
		this.fnDeleteRow = function( mTarget, fnCallBack, bRedraw )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			var i, iAODataIndex;
			
			iAODataIndex = (typeof mTarget == 'object') ? 
				_fnNodeToDataIndex(oSettings, mTarget) : mTarget;
			
			/* Return the data array from this row */
			var oData = oSettings.aoData.splice( iAODataIndex, 1 );
			
			/* Remove the target row from the search array */
			var iDisplayIndex = $.inArray( iAODataIndex, oSettings.aiDisplay );
			oSettings.asDataSearch.splice( iDisplayIndex, 1 );
			
			/* Delete from the display arrays */
			_fnDeleteIndex( oSettings.aiDisplayMaster, iAODataIndex );
			_fnDeleteIndex( oSettings.aiDisplay, iAODataIndex );
			
			/* If there is a user callback function - call it */
			if ( typeof fnCallBack == "function" )
			{
				fnCallBack.call( this, oSettings, oData );
			}
			
			/* Check for an 'overflow' they case for dislaying the table */
			if ( oSettings._iDisplayStart >= oSettings.aiDisplay.length )
			{
				oSettings._iDisplayStart -= oSettings._iDisplayLength;
				if ( oSettings._iDisplayStart < 0 )
				{
					oSettings._iDisplayStart = 0;
				}
			}
			
			if ( typeof bRedraw == 'undefined' || bRedraw )
			{
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
			
			return oData;
		};
		
		/*
		 * Function: fnClearTable
		 * Purpose:  Quickly and simply clear a table
		 * Returns:  -
		 * Inputs:   bool:bRedraw - redraw the table or not - default true
		 * Notes:    Thanks to Yekimov Denis for contributing the basis for this function!
		 */
		this.fnClearTable = function( bRedraw )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			_fnClearTable( oSettings );
			
			if ( typeof bRedraw == 'undefined' || bRedraw )
			{
				_fnDraw( oSettings );
			}
		};
		
		/*
		 * Function: fnOpen
		 * Purpose:  Open a display row (append a row after the row in question)
		 * Returns:  node:nNewRow - the row opened
		 * Inputs:   node:nTr - the table row to 'open'
		 *           string:sHtml - the HTML to put into the row
		 *           string:sClass - class to give the new TD cell
		 */
		this.fnOpen = function( nTr, sHtml, sClass )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			
			/* the old open one if there is one */
			this.fnClose( nTr );
			
			var nNewRow = document.createElement("tr");
			var nNewCell = document.createElement("td");
			nNewRow.appendChild( nNewCell );
			nNewCell.className = sClass;
			nNewCell.colSpan = _fnVisbleColumns( oSettings );
			nNewCell.innerHTML = sHtml;
			
			/* If the nTr isn't on the page at the moment - then we don't insert at the moment */
			var nTrs = $('tr', oSettings.nTBody);
			if ( $.inArray(nTr, nTrs) != -1 )
			{
				$(nNewRow).insertAfter(nTr);
			}
			
			oSettings.aoOpenRows.push( {
				"nTr": nNewRow,
				"nParent": nTr
			} );
			
			return nNewRow;
		};
		
		/*
		 * Function: fnClose
		 * Purpose:  Close a display row
		 * Returns:  int: 0 (success) or 1 (failed)
		 * Inputs:   node:nTr - the table row to 'close'
		 */
		this.fnClose = function( nTr )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			
			for ( var i=0 ; i<oSettings.aoOpenRows.length ; i++ )
			{
				if ( oSettings.aoOpenRows[i].nParent == nTr )
				{
					var nTrParent = oSettings.aoOpenRows[i].nTr.parentNode;
					if ( nTrParent )
					{
						/* Remove it if it is currently on display */
						nTrParent.removeChild( oSettings.aoOpenRows[i].nTr );
					}
					oSettings.aoOpenRows.splice( i, 1 );
					return 0;
				}
			}
			return 1;
		};
		
		/*
		 * Function: fnGetData
		 * Purpose:  Return an array with the data which is used to make up the table
		 * Returns:  array array string: 2d data array ([row][column]) or array string: 1d data array
		 *           or
		 *           array string (if iRow specified)
		 * Inputs:   mixed:mRow - optional - if not present, then the full 2D array for the table 
		 *             if given then:
		 *               int: - return 1D array for aoData entry of this index
		 *               node(TR): - return 1D array for this TR element
		 * Inputs:   int:iRow - optional - if present then the array returned will be the data for
		 *             the row with the index 'iRow'
		 */
		this.fnGetData = function( mRow )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			
			if ( typeof mRow != 'undefined' )
			{
				var iRow = (typeof mRow == 'object') ? 
					_fnNodeToDataIndex(oSettings, mRow) : mRow;
				return oSettings.aoData[iRow]._aData;
			}
			return _fnGetDataMaster( oSettings );
		};
		
		/*
		 * Function: fnGetNodes
		 * Purpose:  Return an array with the TR nodes used for drawing the table
		 * Returns:  array node: TR elements
		 *           or
		 *           node (if iRow specified)
		 * Inputs:   int:iRow - optional - if present then the array returned will be the node for
		 *             the row with the index 'iRow'
		 */
		this.fnGetNodes = function( iRow )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			
			if ( typeof iRow != 'undefined' )
			{
				return oSettings.aoData[iRow].nTr;
			}
			return _fnGetTrNodes( oSettings );
		};
		
		/*
		 * Function: fnGetPosition
		 * Purpose:  Get the array indexes of a particular cell from it's DOM element
		 * Returns:  int: - row index, or array[ int, int, int ]: - row index, column index (visible)
		 *             and column index including hidden columns
		 * Inputs:   node:nNode - this can either be a TR or a TD in the table, the return is
		 *             dependent on this input
		 */
		this.fnGetPosition = function( nNode )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			var i;
			
			if ( nNode.nodeName.toUpperCase() == "TR" )
			{
				return _fnNodeToDataIndex(oSettings, nNode);
			}
			else if ( nNode.nodeName.toUpperCase() == "TD" )
			{
				var iDataIndex = _fnNodeToDataIndex(oSettings, nNode.parentNode);
				var iCorrector = 0;
				for ( var j=0 ; j<oSettings.aoColumns.length ; j++ )
				{
					if ( oSettings.aoColumns[j].bVisible )
					{
						if ( oSettings.aoData[iDataIndex].nTr.getElementsByTagName('td')[j-iCorrector] == nNode )
						{
							return [ iDataIndex, j-iCorrector, j ];
						}
					}
					else
					{
						iCorrector++;
					}
				}
			}
			return null;
		};
		
		/*
		 * Function: fnUpdate
		 * Purpose:  Update a table cell or row
		 * Returns:  int: 0 okay, 1 error
		 * Inputs:   array string 'or' string:mData - data to update the cell/row with
		 *           mixed:mRow - 
		 *             int: - index of aoData to be updated, or
		 *             node(TR): - TR element you want to update
		 *           int:iColumn - the column to update - optional (not used of mData is 2D)
		 *           bool:bRedraw - redraw the table or not - default true
		 *           bool:bAction - perform predraw actions or not (you will want this as 'true' if
		 *             you have bRedraw as true) - default true
		 */
		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			var iVisibleColumn;
			var sDisplay;
			var iRow = (typeof mRow == 'object') ? 
				_fnNodeToDataIndex(oSettings, mRow) : mRow;
			
			if ( typeof mData != 'object' )
			{
				sDisplay = mData;
				oSettings.aoData[iRow]._aData[iColumn] = sDisplay;
				
				if ( oSettings.aoColumns[iColumn].fnRender !== null )
				{
					sDisplay = oSettings.aoColumns[iColumn].fnRender( {
						"iDataRow": iRow,
						"iDataColumn": iColumn,
						"aData": oSettings.aoData[iRow]._aData,
						"oSettings": oSettings
					} );
					
					if ( oSettings.aoColumns[iColumn].bUseRendered )
					{
						oSettings.aoData[iRow]._aData[iColumn] = sDisplay;
					}
				}
				
				iVisibleColumn = _fnColumnIndexToVisible( oSettings, iColumn );
				if ( iVisibleColumn !== null )
				{
					oSettings.aoData[iRow].nTr.getElementsByTagName('td')[iVisibleColumn].innerHTML = 
						sDisplay;
				}
			}
			else
			{
				if ( mData.length != oSettings.aoColumns.length )
				{
					_fnLog( oSettings, 0, 'An array passed to fnUpdate must have the same number of '+
						'columns as the table in question - in this case '+oSettings.aoColumns.length );
					return 1;
				}
				
				for ( var i=0 ; i<mData.length ; i++ )
				{
					sDisplay = mData[i];
					oSettings.aoData[iRow]._aData[i] = sDisplay;
					
					if ( oSettings.aoColumns[i].fnRender !== null )
					{
						sDisplay = oSettings.aoColumns[i].fnRender( {
							"iDataRow": iRow,
							"iDataColumn": i,
							"aData": oSettings.aoData[iRow]._aData,
							"oSettings": oSettings
						} );
						
						if ( oSettings.aoColumns[i].bUseRendered )
						{
							oSettings.aoData[iRow]._aData[i] = sDisplay;
						}
					}
					
					iVisibleColumn = _fnColumnIndexToVisible( oSettings, i );
					if ( iVisibleColumn !== null )
					{
						oSettings.aoData[iRow].nTr.getElementsByTagName('td')[iVisibleColumn].innerHTML = 
							sDisplay;
					}
				}
			}
			
			/* Modify the search index for this row (strictly this is likely not needed, since fnReDraw
			 * will rebuild the search array - however, the redraw might be disabled by the user)
			 */
			var iDisplayIndex = $.inArray( iRow, oSettings.aiDisplay );
			oSettings.asDataSearch[iDisplayIndex] = _fnBuildSearchRow( oSettings, 
				oSettings.aoData[iRow]._aData );
			
			/* Perform pre-draw actions */
			if ( typeof bAction == 'undefined' || bAction )
			{
				_fnAjustColumnSizing( oSettings );
			}
			
			/* Redraw the table */
			if ( typeof bRedraw == 'undefined' || bRedraw )
			{
				_fnReDraw( oSettings );
			}
			return 0;
		};
		
		
		/*
		 * Function: fnShowColoumn
		 * Purpose:  Show a particular column
		 * Returns:  -
		 * Inputs:   int:iCol - the column whose display should be changed
		 *           bool:bShow - show (true) or hide (false) the column
		 *           bool:bRedraw - redraw the table or not - default true
		 */
		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			var i, iLen;
			var iColumns = oSettings.aoColumns.length;
			var nTd, anTds;
			
			/* No point in doing anything if we are requesting what is already true */
			if ( oSettings.aoColumns[iCol].bVisible == bShow )
			{
				return;
			}
			
			var nTrHead = $('>tr', oSettings.nTHead)[0];
			var nTrFoot = $('>tr', oSettings.nTFoot)[0];
			var anTheadTh = [];
			var anTfootTh = [];
			for ( i=0 ; i<iColumns ; i++ )
			{
				anTheadTh.push( oSettings.aoColumns[i].nTh );
				anTfootTh.push( oSettings.aoColumns[i].nTf );
			}
			
			/* Show the column */
			if ( bShow )
			{
				var iInsert = 0;
				for ( i=0 ; i<iCol ; i++ )
				{
					if ( oSettings.aoColumns[i].bVisible )
					{
						iInsert++;
					}
				}
				
				/* Need to decide if we should use appendChild or insertBefore */
				if ( iInsert >= _fnVisbleColumns( oSettings ) )
				{
					nTrHead.appendChild( anTheadTh[iCol] );
					if ( nTrFoot )
					{
						nTrFoot.appendChild( anTfootTh[iCol] );
					}
					
					for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
					{
						nTd = oSettings.aoData[i]._anHidden[iCol];
						oSettings.aoData[i].nTr.appendChild( nTd );
					}
				}
				else
				{
					/* Which coloumn should we be inserting before? */
					var iBefore;
					for ( i=iCol ; i<iColumns ; i++ )
					{
						iBefore = _fnColumnIndexToVisible( oSettings, i );
						if ( iBefore !== null )
						{
							break;
						}
					}
					
					nTrHead.insertBefore( anTheadTh[iCol], nTrHead.getElementsByTagName('th')[iBefore] );
					if ( nTrFoot )
					{
						nTrFoot.insertBefore( anTfootTh[iCol], nTrFoot.getElementsByTagName('th')[iBefore] );
					}
					
					anTds = _fnGetTdNodes( oSettings );
					for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
					{
						nTd = oSettings.aoData[i]._anHidden[iCol];
						oSettings.aoData[i].nTr.insertBefore( nTd, $('>td:eq('+iBefore+')', 
							oSettings.aoData[i].nTr)[0] );
					}
				}
				
				oSettings.aoColumns[iCol].bVisible = true;
			}
			else
			{
				/* Remove a column from display */
				nTrHead.removeChild( anTheadTh[iCol] );
				if ( nTrFoot )
				{
					nTrFoot.removeChild( anTfootTh[iCol] );
				}
				
				anTds = _fnGetTdNodes( oSettings );
				for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
				{
					nTd = anTds[ ( i*oSettings.aoColumns.length) + (iCol*1) ];
					oSettings.aoData[i]._anHidden[iCol] = nTd;
					nTd.parentNode.removeChild( nTd );
				}
				
				oSettings.aoColumns[iCol].bVisible = false;
			}
			
			/* If there are any 'open' rows, then we need to alter the colspan for this col change */
			for ( i=0, iLen=oSettings.aoOpenRows.length ; i<iLen ; i++ )
			{
				oSettings.aoOpenRows[i].nTr.colSpan = _fnVisbleColumns( oSettings );
			}
			
			/* Do a redraw incase anything depending on the table columns needs it 
			 * (built-in: scrolling) 
			 */
			if ( typeof bRedraw == 'undefined' || bRedraw )
			{
				_fnAjustColumnSizing( oSettings );
				_fnDraw( oSettings );
			}
			
			_fnSaveState( oSettings );
		};
		
		/*
		 * Function: fnPageChange
		 * Purpose:  Change the pagination
		 * Returns:  -
		 * Inputs:   string:sAction - paging action to take: "first", "previous", "next" or "last"
		 *           bool:bRedraw - redraw the table or not - optional - default true
		 */
		this.fnPageChange = function ( sAction, bRedraw )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			_fnPageChange( oSettings, sAction );
			_fnCalculateEnd( oSettings );
			
			if ( typeof bRedraw == 'undefined' || bRedraw )
			{
				_fnDraw( oSettings );
			}
		};
		
		/*
		 * Function: fnDestroy
		 * Purpose:  Destructor for the DataTable
		 * Returns:  -
		 * Inputs:   -
		 */
		this.fnDestroy = function ( )
		{
			var oSettings = _fnSettingsFromNode( this[_oExt.iApiIndex] );
			var nOrig = oSettings.nTableWrapper.parentNode;
			var nBody = oSettings.nTBody;
			var i, iLen;
			
			/* Flag to note that the table is currently being destoryed - no action should be taken */
			oSettings.bDestroying = true;
			
			/* Restore hidden columns */
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible === false )
				{
					this.fnSetColumnVis( i, true );
				}
			}
			
			/* If there is an 'empty' indicator row, remove it */
			$('tbody>tr>td.'+oSettings.oClasses.sRowEmpty, oSettings.nTable).parent().remove();
			
			/* When scrolling we had to break the table up - restore it */
			if ( oSettings.nTable != oSettings.nTHead.parentNode )
			{
				$('>thead', oSettings.nTable).remove();
				oSettings.nTable.appendChild( oSettings.nTHead );
			}
			
			if ( oSettings.nTFoot && oSettings.nTable != oSettings.nTFoot.parentNode )
			{
				$('>tfoot', oSettings.nTable).remove();
				oSettings.nTable.appendChild( oSettings.nTFoot );
			}
			
			/* Remove the DataTables generated nodes, events and classes */
			oSettings.nTable.parentNode.removeChild( oSettings.nTable );
			$(oSettings.nTableWrapper).remove();
			
			oSettings.aaSorting = [];
			oSettings.aaSortingFixed = [];
			_fnSortingClasses( oSettings );
			
			$(_fnGetTrNodes( oSettings )).removeClass( oSettings.asStripClasses.join(' ') );
			
			if ( !oSettings.bJUI )
			{
				$('th', oSettings.nTHead).removeClass( [ _oExt.oStdClasses.sSortable,
					_oExt.oStdClasses.sSortableAsc,
					_oExt.oStdClasses.sSortableDesc,
					_oExt.oStdClasses.sSortableNone ].join(' ')
				);
			}
			else
			{
				$('th', oSettings.nTHead).removeClass( [ _oExt.oStdClasses.sSortable,
					_oExt.oJUIClasses.sSortableAsc,
					_oExt.oJUIClasses.sSortableDesc,
					_oExt.oJUIClasses.sSortableNone ].join(' ')
				);
				$('th span', oSettings.nTHead).remove();
			}
			
			/* Add the TR elements back into the table in their original order */
			nOrig.appendChild( oSettings.nTable );
			for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
			{
				nBody.appendChild( oSettings.aoData[i].nTr );
			}
			
			/* Restore the width of the original table */
			oSettings.nTable.style.width = _fnStringToCss(oSettings.sDestroyWidth);
			
			/* If the were originally odd/even type classes - then we add them back here. Note
			 * this is not fool proof (for example if not all rows as odd/even classes - but 
			 * it's a good effort without getting carried away
			 */
			$('>tr:even', nBody).addClass( oSettings.asDestoryStrips[0] );
			$('>tr:odd', nBody).addClass( oSettings.asDestoryStrips[1] );
			
			/* Remove the settings object from the settings array */
			for ( i=0, iLen=_aoSettings.length ; i<iLen ; i++ )
			{
				if ( _aoSettings[i] == oSettings )
				{
					_aoSettings.splice( i, 1 );
				}
			}
			
			/* End it all */
			oSettings = null;
		};
		
		/*
		 * Function: _fnAjustColumnSizing
		 * Purpose:  Update tale sizing based on content. This would most likely be used for scrolling
		 *   and will typically need a redraw after it.
		 * Returns:  -
		 * Inputs:   bool:bRedraw - redraw the table or not, you will typically want to - default true
		 */
		this.fnAdjustColumnSizing = function ( bRedraw )
		{
			_fnAjustColumnSizing( _fnSettingsFromNode( this[_oExt.iApiIndex] ) );
			
			if ( typeof bRedraw == 'undefined' || bRedraw )
			{
				this.fnDraw( false );
			}
		};
		
		/*
		 * Plugin API functions
		 * 
		 * This call will add the functions which are defined in _oExt.oApi to the
		 * DataTables object, providing a rather nice way to allow plug-in API functions. Note that
		 * this is done here, so that API function can actually override the built in API functions if
		 * required for a particular purpose.
		 */
		
		/*
		 * Function: _fnExternApiFunc
		 * Purpose:  Create a wrapper function for exporting an internal func to an external API func
		 * Returns:  function: - wrapped function
		 * Inputs:   string:sFunc - API function name
		 */
		function _fnExternApiFunc (sFunc)
		{
			return function() {
					var aArgs = [_fnSettingsFromNode(this[_oExt.iApiIndex])].concat( 
						Array.prototype.slice.call(arguments) );
					return _oExt.oApi[sFunc].apply( this, aArgs );
				};
		}
		
		for ( var sFunc in _oExt.oApi )
		{
			if ( sFunc )
			{
				/*
				 * Function: anon
				 * Purpose:  Wrap the plug-in API functions in order to provide the settings as 1st arg 
				 *   and execute in this scope
				 * Returns:  -
				 * Inputs:   -
				 */
				this[sFunc] = _fnExternApiFunc(sFunc);
			}
		}
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Local functions
		 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Initalisation
		 */
		
		/*
		 * Function: _fnInitalise
		 * Purpose:  Draw the table for the first time, adding all required features
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnInitalise ( oSettings )
		{
			var i, iLen;
			
			/* Ensure that the table data is fully initialised */
			if ( oSettings.bInitialised === false )
			{
				setTimeout( function(){ _fnInitalise( oSettings ); }, 200 );
				return;
			}
			
			/* Show the display HTML options */
			_fnAddOptionsHtml( oSettings );
			
			/* Draw the headers for the table */
			_fnDrawHead( oSettings );
			
			/* Okay to show that something is going on now */
			_fnProcessingDisplay( oSettings, true );
			
			/* Calculate sizes for columns */
			if ( oSettings.oFeatures.bAutoWidth )
			{
				_fnCalculateColumnWidths( oSettings );
			}
			
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				if ( oSettings.aoColumns[i].sWidth !== null )
				{
					oSettings.aoColumns[i].nTh.style.width = _fnStringToCss( oSettings.aoColumns[i].sWidth );
				}
			}
			
			/* If there is default sorting required - let's do it. The sort function
			 * will do the drawing for us. Otherwise we draw the table
			 */
			if ( oSettings.oFeatures.bSort )
			{
				_fnSort( oSettings );
			}
			else
			{
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
			
			/* if there is an ajax source */
			if ( oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide )
			{
				oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, [], function(json) {
					/* Got the data - add it to the table */
					for ( i=0 ; i<json.aaData.length ; i++ )
					{
						_fnAddData( oSettings, json.aaData[i] );
					}
					
					/* Reset the init display for cookie saving. We've already done a filter, and
					 * therefore cleared it before. So we need to make it appear 'fresh'
					 */
					oSettings.iInitDisplayStart = oSettings._iDisplayStart;
					
					if ( oSettings.oFeatures.bSort )
					{
						_fnSort( oSettings );
					}
					else
					{
						oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
						_fnCalculateEnd( oSettings );
						_fnDraw( oSettings );
					}
					
					_fnProcessingDisplay( oSettings, false );
					
					/* Run the init callback if there is one - done here for ajax source for json obj */
					if ( typeof oSettings.fnInitComplete == 'function' )
					{
						oSettings.fnInitComplete.call( oSettings.oInstance, oSettings, json );
					}
				} );
				return;
			}
			
			if ( !oSettings.oFeatures.bServerSide )
			{
				_fnProcessingDisplay( oSettings, false );
			}
		}
		
		/*
		 * Function: _fnLanguageProcess
		 * Purpose:  Copy language variables from remote object to a local one
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           object:oLanguage - Language information
		 *           bool:bInit - init once complete
		 */
		function _fnLanguageProcess( oSettings, oLanguage, bInit )
		{
			_fnMap( oSettings.oLanguage, oLanguage, 'sProcessing' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sLengthMenu' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sEmptyTable' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sZeroRecords' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sInfo' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sInfoEmpty' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sInfoFiltered' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sInfoPostFix' );
			_fnMap( oSettings.oLanguage, oLanguage, 'sSearch' );
			
			if ( typeof oLanguage.oPaginate != 'undefined' )
			{
				_fnMap( oSettings.oLanguage.oPaginate, oLanguage.oPaginate, 'sFirst' );
				_fnMap( oSettings.oLanguage.oPaginate, oLanguage.oPaginate, 'sPrevious' );
				_fnMap( oSettings.oLanguage.oPaginate, oLanguage.oPaginate, 'sNext' );
				_fnMap( oSettings.oLanguage.oPaginate, oLanguage.oPaginate, 'sLast' );
			}
			
			/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
			 * sZeroRecords - assuming that is given.
			 */
			if ( typeof oLanguage.sEmptyTable == 'undefined' && 
			     typeof oLanguage.sZeroRecords != 'undefined' )
			{
				_fnMap( oSettings.oLanguage, oLanguage, 'sZeroRecords', 'sEmptyTable' );
			}
			
			if ( bInit )
			{
				_fnInitalise( oSettings );
			}
		}
		
		/*
		 * Function: _fnAddColumn
		 * Purpose:  Add a column to the list used for the table with default values
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           node:nTh - the th element for this column
		 */
		function _fnAddColumn( oSettings, nTh )
		{
			oSettings.aoColumns[ oSettings.aoColumns.length++ ] = {
				"sType": null,
				"_bAutoType": true,
				"bVisible": true,
				"bSearchable": true,
				"bSortable": true,
				"asSorting": [ 'asc', 'desc' ],
				"sSortingClass": oSettings.oClasses.sSortable,
				"sSortingClassJUI": oSettings.oClasses.sSortJUI,
				"sTitle": nTh ? nTh.innerHTML : '',
				"sName": '',
				"sWidth": null,
				"sWidthOrig": null,
				"sClass": null,
				"fnRender": null,
				"bUseRendered": true,
				"iDataSort": oSettings.aoColumns.length-1,
				"sSortDataType": 'std',
				"nTh": nTh ? nTh : document.createElement('th'),
				"nTf": null
			};
			
			var iCol = oSettings.aoColumns.length-1;
			var oCol = oSettings.aoColumns[ iCol ];
			
			/* Add a column specific filter */
			if ( typeof oSettings.aoPreSearchCols[ iCol ] == 'undefined' ||
			     oSettings.aoPreSearchCols[ iCol ] === null )
			{
				oSettings.aoPreSearchCols[ iCol ] = {
					"sSearch": "",
					"bRegex": false,
					"bSmart": true
				};
			}
			else
			{
				/* Don't require that the user must specify bRegex and / or bSmart */
				if ( typeof oSettings.aoPreSearchCols[ iCol ].bRegex == 'undefined' )
				{
					oSettings.aoPreSearchCols[ iCol ].bRegex = true;
				}
				
				if ( typeof oSettings.aoPreSearchCols[ iCol ].bSmart == 'undefined' )
				{
					oSettings.aoPreSearchCols[ iCol ].bSmart = true;
				}
			} 
			
			/* Use the column options function to initialise classes etc */
			_fnColumnOptions( oSettings, iCol, null );
		}
		
		/*
		 * Function: _fnColumnOptions
		 * Purpose:  Apply options for a column
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           int:iCol - column index to consider
		 *           object:oOptions - object with sType, bVisible and bSearchable
		 */
		function _fnColumnOptions( oSettings, iCol, oOptions )
		{
			var oCol = oSettings.aoColumns[ iCol ];
			
			/* User specified column options */
			if ( typeof oOptions != 'undefined' && oOptions !== null )
			{
				if ( typeof oOptions.sType != 'undefined' )
				{
					oCol.sType = oOptions.sType;
					oCol._bAutoType = false;
				}
				
				_fnMap( oCol, oOptions, "bVisible" );
				_fnMap( oCol, oOptions, "bSearchable" );
				_fnMap( oCol, oOptions, "bSortable" );
				_fnMap( oCol, oOptions, "sTitle" );
				_fnMap( oCol, oOptions, "sName" );
				_fnMap( oCol, oOptions, "sWidth" );
				_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
				_fnMap( oCol, oOptions, "sClass" );
				_fnMap( oCol, oOptions, "fnRender" );
				_fnMap( oCol, oOptions, "bUseRendered" );
				_fnMap( oCol, oOptions, "iDataSort" );
				_fnMap( oCol, oOptions, "asSorting" );
				_fnMap( oCol, oOptions, "sSortDataType" );
			}
			
			/* Feature sorting overrides column specific when off */
			if ( !oSettings.oFeatures.bSort )
			{
				oCol.bSortable = false;
			}
			
			/* Check that the class assignment is correct for sorting */
			if ( !oCol.bSortable ||
					 ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1) )
			{
				oCol.sSortingClass = oSettings.oClasses.sSortableNone;
				oCol.sSortingClassJUI = "";
			}
			else if ( $.inArray('asc', oCol.asSorting) != -1 && $.inArray('desc', oCol.asSorting) == -1 )
			{
				oCol.sSortingClass = oSettings.oClasses.sSortableAsc;
				oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIAscAllowed;
			}
			else if ( $.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) != -1 )
			{
				oCol.sSortingClass = oSettings.oClasses.sSortableDesc;
				oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIDescAllowed;
			}
		}
		
		/*
		 * Function: _fnAddData
		 * Purpose:  Add a data array to the table, creating DOM node etc
		 * Returns:  int: - >=0 if successful (index of new aoData entry), -1 if failed
		 * Inputs:   object:oSettings - dataTables settings object
		 *           array:aData - data array to be added
		 * Notes:    There are two basic methods for DataTables to get data to display - a JS array
		 *   (which is dealt with by this function), and the DOM, which has it's own optimised
		 *   function (_fnGatherData). Be careful to make the same changes here as there and vice-versa
		 */
		function _fnAddData ( oSettings, aDataSupplied )
		{
			/* Sanity check the length of the new array */
			if ( aDataSupplied.length != oSettings.aoColumns.length &&
				oSettings.iDrawError != oSettings.iDraw )
			{
				_fnLog( oSettings, 0, "Added data (size "+aDataSupplied.length+") does not match known "+
					"number of columns ("+oSettings.aoColumns.length+")" );
				oSettings.iDrawError = oSettings.iDraw;
				return -1;
			}
			
			
			/* Create the object for storing information about this new row */
			var aData = aDataSupplied.slice();
			var iThisIndex = oSettings.aoData.length;
			oSettings.aoData.push( {
				"nTr": document.createElement('tr'),
				"_iId": oSettings.iNextId++,
				"_aData": aData,
				"_anHidden": [],
				"_sRowStripe": ''
			} );
			
			/* Create the cells */
			var nTd, sThisType;
			for ( var i=0 ; i<aData.length ; i++ )
			{
				nTd = document.createElement('td');
				
				/* Allow null data (from a data array) - simply deal with it as a blank string */
				if ( aData[i] === null )
				{
					aData[i] = '';
				}
				
				if ( typeof oSettings.aoColumns[i].fnRender == 'function' )
				{
					var sRendered = oSettings.aoColumns[i].fnRender( {
							"iDataRow": iThisIndex,
							"iDataColumn": i,
							"aData": aData,
							"oSettings": oSettings
						} );
					nTd.innerHTML = sRendered;
					if ( oSettings.aoColumns[i].bUseRendered )
					{
						/* Use the rendered data for filtering/sorting */
						oSettings.aoData[iThisIndex]._aData[i] = sRendered;
					}
				}
				else
				{
					nTd.innerHTML = aData[i];
				}
				
				/* Cast everything as a string - so we can treat everything equally when sorting */
				if ( typeof aData[i] != 'string' )
				{
					aData[i] += "";
				}
				aData[i] = $.trim(aData[i]);
				
				/* Add user defined class */
				if ( oSettings.aoColumns[i].sClass !== null )
				{
					nTd.className = oSettings.aoColumns[i].sClass;
				}
				
				/* See if we should auto-detect the column type */
				if ( oSettings.aoColumns[i]._bAutoType && oSettings.aoColumns[i].sType != 'string' )
				{
					/* Attempt to auto detect the type - same as _fnGatherData() */
					sThisType = _fnDetectType( oSettings.aoData[iThisIndex]._aData[i] );
					if ( oSettings.aoColumns[i].sType === null )
					{
						oSettings.aoColumns[i].sType = sThisType;
					}
					else if ( oSettings.aoColumns[i].sType != sThisType )
					{
						/* String is always the 'fallback' option */
						oSettings.aoColumns[i].sType = 'string';
					}
				}
					
				if ( oSettings.aoColumns[i].bVisible )
				{
					oSettings.aoData[iThisIndex].nTr.appendChild( nTd );
					oSettings.aoData[iThisIndex]._anHidden[i] = null;
				}
				else
				{
					oSettings.aoData[iThisIndex]._anHidden[i] = nTd;
				}
			}
			
			/* Add to the display array */
			oSettings.aiDisplayMaster.push( iThisIndex );
			return iThisIndex;
		}
		
		/*
		 * Function: _fnGatherData
		 * Purpose:  Read in the data from the target table from the DOM
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 * Notes:    This is a optimised version of _fnAddData (more or less) for reading information
		 *   from the DOM. The basic actions must be identical in the two functions.
		 */
		function _fnGatherData( oSettings )
		{
			var iLoop, i, iLen, j, jLen, jInner,
			 	nTds, nTrs, nTd, aLocalData, iThisIndex,
				iRow, iRows, iColumn, iColumns;
			
			/*
			 * Process by row first
			 * Add the data object for the whole table - storing the tr node. Note - no point in getting
			 * DOM based data if we are going to go and replace it with Ajax source data.
			 */
			if ( oSettings.sAjaxSource === null )
			{
				nTrs = oSettings.nTBody.childNodes;
				for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
				{
					if ( nTrs[i].nodeName.toUpperCase() == "TR" )
					{
						iThisIndex = oSettings.aoData.length;
						oSettings.aoData.push( {
							"nTr": nTrs[i],
							"_iId": oSettings.iNextId++,
							"_aData": [],
							"_anHidden": [],
							"_sRowStripe": ''
						} );
						
						oSettings.aiDisplayMaster.push( iThisIndex );
						
						aLocalData = oSettings.aoData[iThisIndex]._aData;
						nTds = nTrs[i].childNodes;
						jInner = 0;
						
						for ( j=0, jLen=nTds.length ; j<jLen ; j++ )
						{
							if ( nTds[j].nodeName.toUpperCase() == "TD" )
							{
								aLocalData[jInner] = $.trim(nTds[j].innerHTML);
								jInner++;
							}
						}
					}
				}
			}
			
			/* Gather in the TD elements of the Table - note that this is basically the same as
			 * fnGetTdNodes, but that function takes account of hidden columns, which we haven't yet
			 * setup!
			 */
			nTrs = _fnGetTrNodes( oSettings );
			nTds = [];
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				for ( j=0, jLen=nTrs[i].childNodes.length ; j<jLen ; j++ )
				{
					nTd = nTrs[i].childNodes[j];
					if ( nTd.nodeName.toUpperCase() == "TD" )
					{
						nTds.push( nTd );
					}
				}
			}
			
			/* Sanity check */
			if ( nTds.length != nTrs.length * oSettings.aoColumns.length )
			{
				_fnLog( oSettings, 1, "Unexpected number of TD elements. Expected "+
					(nTrs.length * oSettings.aoColumns.length)+" and got "+nTds.length+". DataTables does "+
					"not support rowspan / colspan in the table body, and there must be one cell for each "+
					"row/column combination." );
			}
			
			/* Now process by column */
			for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
			{
				/* Get the title of the column - unless there is a user set one */
				if ( oSettings.aoColumns[iColumn].sTitle === null )
				{
					oSettings.aoColumns[iColumn].sTitle = oSettings.aoColumns[iColumn].nTh.innerHTML;
				}
				
				var
					bAutoType = oSettings.aoColumns[iColumn]._bAutoType,
					bRender = typeof oSettings.aoColumns[iColumn].fnRender == 'function',
					bClass = oSettings.aoColumns[iColumn].sClass !== null,
					bVisible = oSettings.aoColumns[iColumn].bVisible,
					nCell, sThisType, sRendered;
				
				/* A single loop to rule them all (and be more efficient) */
				if ( bAutoType || bRender || bClass || !bVisible )
				{
					for ( iRow=0, iRows=oSettings.aoData.length ; iRow<iRows ; iRow++ )
					{
						nCell = nTds[ (iRow*iColumns) + iColumn ];
						
						/* Type detection */
						if ( bAutoType )
						{
							if ( oSettings.aoColumns[iColumn].sType != 'string' )
							{
								sThisType = _fnDetectType( oSettings.aoData[iRow]._aData[iColumn] );
								if ( oSettings.aoColumns[iColumn].sType === null )
								{
									oSettings.aoColumns[iColumn].sType = sThisType;
								}
								else if ( oSettings.aoColumns[iColumn].sType != sThisType )
								{
									/* String is always the 'fallback' option */
									oSettings.aoColumns[iColumn].sType = 'string';
								}
							}
						}
						
						/* Rendering */
						if ( bRender )
						{
							sRendered = oSettings.aoColumns[iColumn].fnRender( {
									"iDataRow": iRow,
									"iDataColumn": iColumn,
									"aData": oSettings.aoData[iRow]._aData,
									"oSettings": oSettings
								} );
							nCell.innerHTML = sRendered;
							if ( oSettings.aoColumns[iColumn].bUseRendered )
							{
								/* Use the rendered data for filtering/sorting */
								oSettings.aoData[iRow]._aData[iColumn] = sRendered;
							}
						}
						
						/* Classes */
						if ( bClass )
						{
							nCell.className += ' '+oSettings.aoColumns[iColumn].sClass;
						}
						
						/* Column visability */
						if ( !bVisible )
						{
							oSettings.aoData[iRow]._anHidden[iColumn] = nCell;
							nCell.parentNode.removeChild( nCell );
						}
						else
						{
							oSettings.aoData[iRow]._anHidden[iColumn] = null;
						}
					}
				}
			}
		}
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Drawing functions
		 */
		
		/*
		 * Function: _fnDrawHead
		 * Purpose:  Create the HTML header for the table
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnDrawHead( oSettings )
		{
			var i, nTh, iLen, j, jLen;
			var iThs = oSettings.nTHead.getElementsByTagName('th').length;
			var iCorrector = 0;
			
			/* If there is a header in place - then use it - otherwise it's going to get nuked... */
			if ( iThs !== 0 )
			{
				/* We've got a thead from the DOM, so remove hidden columns and apply width to vis cols */
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					nTh = oSettings.aoColumns[i].nTh;
					
					if ( oSettings.aoColumns[i].bVisible )
					{
						/* Set the title of the column if it is user defined (not what was auto detected) */
						if ( oSettings.aoColumns[i].sTitle != nTh.innerHTML )
						{
							nTh.innerHTML = oSettings.aoColumns[i].sTitle;
						}
					}
					else
					{
						nTh.parentNode.removeChild( nTh );
						iCorrector++;
					}
				}
			}
			else
			{
				/* We don't have a header in the DOM - so we are going to have to create one */
				var nTr = document.createElement( "tr" );
				
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					nTh = oSettings.aoColumns[i].nTh;
					nTh.innerHTML = oSettings.aoColumns[i].sTitle;
					
					if ( oSettings.aoColumns[i].bVisible )
					{
						if ( oSettings.aoColumns[i].sClass !== null )
						{
							nTh.className = oSettings.aoColumns[i].sClass;
						}
						
						nTr.appendChild( nTh );
					}
				}
				$(oSettings.nTHead).html( '' )[0].appendChild( nTr );
			}
			
			/* Add the extra markup needed by jQuery UI's themes */
			if ( oSettings.bJUI )
			{
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					nTh = oSettings.aoColumns[i].nTh;
					
					var nDiv = document.createElement('div');
					nDiv.className = oSettings.oClasses.sSortJUIWrapper;
					$(nTh).contents().appendTo(nDiv);
					
					nDiv.appendChild( document.createElement('span') );
					nTh.appendChild( nDiv );
				}
			}
			
			/* Add sort listener */
			var fnNoSelect = function (e) {
				this.onselectstart = function() { return false; };
				return false;
			};
			
			if ( oSettings.oFeatures.bSort )
			{
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					if ( oSettings.aoColumns[i].bSortable !== false )
					{
						_fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );
						
						/* Take the brutal approach to cancelling text selection in header */
						$(oSettings.aoColumns[i].nTh).mousedown( fnNoSelect );
					}
					else
					{
						$(oSettings.aoColumns[i].nTh).addClass( oSettings.oClasses.sSortableNone );
					}
				}
			}
			
			/* Cache the footer elements */
			if ( oSettings.nTFoot !== null )
			{
				iCorrector = 0;
				var nTfs = oSettings.nTFoot.getElementsByTagName('th');
				for ( i=0, iLen=nTfs.length ; i<iLen ; i++ )
				{
					if ( typeof oSettings.aoColumns[i] != 'undefined' )
					{
						oSettings.aoColumns[i].nTf = nTfs[i-iCorrector];
						
						if ( oSettings.oClasses.sFooterTH !== "" )
						{
							oSettings.aoColumns[i].nTf.className += " "+oSettings.oClasses.sFooterTH;
						}
						
						if ( !oSettings.aoColumns[i].bVisible )
						{
							nTfs[i-iCorrector].parentNode.removeChild( nTfs[i-iCorrector] );
							iCorrector++;
						}
					}
				}
			}
		}
		
		/*
		 * Function: _fnDraw
		 * Purpose:  Insert the required TR nodes into the table for display
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnDraw( oSettings )
		{
			var i, iLen;
			var anRows = [];
			var iRowCount = 0;
			var bRowError = false;
			var iStrips = oSettings.asStripClasses.length;
			var iOpenRows = oSettings.aoOpenRows.length;
			
			oSettings.bDrawing = true;
			
			/* Check and see if we have an initial draw position from state saving */
			if ( typeof oSettings.iInitDisplayStart != 'undefined' && oSettings.iInitDisplayStart != -1 )
			{
				if ( oSettings.oFeatures.bServerSide )
				{
					oSettings._iDisplayStart = oSettings.iInitDisplayStart;
				}
				else
				{
					oSettings._iDisplayStart = (oSettings.iInitDisplayStart >= oSettings.fnRecordsDisplay()) ?
						0 : oSettings.iInitDisplayStart;
				}
				oSettings.iInitDisplayStart = -1;
				_fnCalculateEnd( oSettings );
			}
			
			/* If we are dealing with Ajax - do it here */
			if ( oSettings.oFeatures.bServerSide && 
			     !_fnAjaxUpdate( oSettings ) )
			{
				return;
			}
			else if ( !oSettings.oFeatures.bServerSide )
			{
				oSettings.iDraw++;
			}
			
			if ( oSettings.aiDisplay.length !== 0 )
			{
				var iStart = oSettings._iDisplayStart;
				var iEnd = oSettings._iDisplayEnd;
				
				if ( oSettings.oFeatures.bServerSide )
				{
					iStart = 0;
					iEnd = oSettings.aoData.length;
				}
				
				for ( var j=iStart ; j<iEnd ; j++ )
				{
					var aoData = oSettings.aoData[ oSettings.aiDisplay[j] ];
					var nRow = aoData.nTr;
					
					/* Remove the old stripping classes and then add the new one */
					if ( iStrips !== 0 )
					{
						var sStrip = oSettings.asStripClasses[ iRowCount % iStrips ];
						if ( aoData._sRowStripe != sStrip )
						{
							$(nRow).removeClass( aoData._sRowStripe ).addClass( sStrip );
							aoData._sRowStripe = sStrip;
						}
					}
					
					/* Custom row callback function - might want to manipule the row */
					if ( typeof oSettings.fnRowCallback == "function" )
					{
						nRow = oSettings.fnRowCallback.call( oSettings.oInstance, nRow, 
							oSettings.aoData[ oSettings.aiDisplay[j] ]._aData, iRowCount, j );
						if ( !nRow && !bRowError )
						{
							_fnLog( oSettings, 0, "A node was not returned by fnRowCallback" );
							bRowError = true;
						}
					}
					
					anRows.push( nRow );
					iRowCount++;
					
					/* If there is an open row - and it is attached to this parent - attach it on redraw */
					if ( iOpenRows !== 0 )
					{
						for ( var k=0 ; k<iOpenRows ; k++ )
						{
							if ( nRow == oSettings.aoOpenRows[k].nParent )
							{
								anRows.push( oSettings.aoOpenRows[k].nTr );
							}
						}
					}
				}
			}
			else
			{
				/* Table is empty - create a row with an empty message in it */
				anRows[ 0 ] = document.createElement( 'tr' );
				
				if ( typeof oSettings.asStripClasses[0] != 'undefined' )
				{
					anRows[ 0 ].className = oSettings.asStripClasses[0];
				}
				
				var nTd = document.createElement( 'td' );
				nTd.setAttribute( 'valign', "top" );
				nTd.colSpan = _fnVisbleColumns( oSettings );
				nTd.className = oSettings.oClasses.sRowEmpty;
				if ( typeof oSettings.oLanguage.sEmptyTable != 'undefined' &&
				     oSettings.fnRecordsTotal() === 0 )
				{
					nTd.innerHTML = oSettings.oLanguage.sEmptyTable;
				}
				else
				{
					nTd.innerHTML = oSettings.oLanguage.sZeroRecords.replace(
						'_MAX_', oSettings.fnFormatNumber(oSettings.fnRecordsTotal()) );
				}
				
				anRows[ iRowCount ].appendChild( nTd );
			}
			
			/* Callback the header and footer custom funcation if there is one */
			if ( typeof oSettings.fnHeaderCallback == 'function' )
			{
				oSettings.fnHeaderCallback.call( oSettings.oInstance, $('>tr', oSettings.nTHead)[0], 
					_fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(),
					oSettings.aiDisplay );
			}
			
			if ( typeof oSettings.fnFooterCallback == 'function' )
			{
				oSettings.fnFooterCallback.call( oSettings.oInstance, $('>tr', oSettings.nTFoot)[0], 
					_fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(),
					oSettings.aiDisplay );
			}
			
			/* 
			 * Need to remove any old row from the display - note we can't just empty the tbody using
			 * $().html('') since this will unbind the jQuery event handlers (even although the node 
			 * still exists!) - equally we can't use innerHTML, since IE throws an exception.
			 */
			var
				nAddFrag = document.createDocumentFragment(),
				nRemoveFrag = document.createDocumentFragment(),
				nBodyPar, nTrs;
			
			if ( oSettings.nTBody )
			{
				nBodyPar = oSettings.nTBody.parentNode;
				nRemoveFrag.appendChild( oSettings.nTBody );
				
				/* When doing infinite scrolling, only remove child rows when sorting, filtering or start
				 * up. When not infinite scroll, always do it.
				 */
				if ( !oSettings.oScroll.bInfinite || !oSettings._bInitComplete ||
				 	oSettings.bSorted || oSettings.bFiltered )
				{
					nTrs = oSettings.nTBody.childNodes;
					for ( i=nTrs.length-1 ; i>=0 ; i-- )
					{
						nTrs[i].parentNode.removeChild( nTrs[i] );
					}
				}
				
				/* Put the draw table into the dom */
				for ( i=0, iLen=anRows.length ; i<iLen ; i++ )
				{
					nAddFrag.appendChild( anRows[i] );
				}
				
				oSettings.nTBody.appendChild( nAddFrag );
				if ( nBodyPar !== null )
				{
					nBodyPar.appendChild( oSettings.nTBody );
				}
			}
			
			/* Call all required callback functions for the end of a draw */
			for ( i=0, iLen=oSettings.aoDrawCallback.length ; i<iLen ; i++ )
			{
				oSettings.aoDrawCallback[i].fn.call( oSettings.oInstance, oSettings );
			}
			
			/* Draw is complete, sorting and filtering must be as well */
			oSettings.bSorted = false;
			oSettings.bFiltered = false;
			oSettings.bDrawing = false;
				
			/* On first draw, initilaisation is now complete */
			if ( typeof oSettings._bInitComplete == "undefined" )
			{
				oSettings._bInitComplete = true;
				
				if ( typeof oSettings.fnInitComplete == 'function' &&
					   (oSettings.oFeatures.bServerSide || oSettings.sAjaxSource === null) )
				{
					oSettings.fnInitComplete.call( oSettings.oInstance, oSettings );
				}
			}
		}
		
		/*
		 * Function: _fnReDraw
		 * Purpose:  Redraw the table - taking account of the various features which are enabled
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnReDraw( oSettings )
		{
			if ( oSettings.oFeatures.bSort )
			{
				/* Sorting will refilter and draw for us */
				_fnSort( oSettings, oSettings.oPreviousSearch );
			}
			else if ( oSettings.oFeatures.bFilter )
			{
				/* Filtering will redraw for us */
				_fnFilterComplete( oSettings, oSettings.oPreviousSearch );
			}
			else
			{
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
		}
		
		/*
		 * Function: _fnAjaxUpdate
		 * Purpose:  Update the table using an Ajax call
		 * Returns:  bool: block the table drawing or not
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnAjaxUpdate( oSettings )
		{
			if ( oSettings.bAjaxDataGet )
			{
				_fnProcessingDisplay( oSettings, true );
				var iColumns = oSettings.aoColumns.length;
				var aoData = [];
				var i;
				
				/* Paging and general */
				oSettings.iDraw++;
				aoData.push( { "name": "sEcho",          "value": oSettings.iDraw } );
				aoData.push( { "name": "iColumns",       "value": iColumns } );
				aoData.push( { "name": "sColumns",       "value": _fnColumnOrdering(oSettings) } );
				aoData.push( { "name": "iDisplayStart",  "value": oSettings._iDisplayStart } );
				aoData.push( { "name": "iDisplayLength", "value": oSettings.oFeatures.bPaginate !== false ?
					oSettings._iDisplayLength : -1 } );
				
				/* Column names */
				var aNames = [];
				for ( i=0 ; i<iColumns ; i++ )
				{
					aNames.push( oSettings.aoColumns[i].sName );
				}
				aoData.push( { "name": "sNames", "value": aNames.join(',') } );
				
				/* Filtering */
				if ( oSettings.oFeatures.bFilter !== false )
				{
					aoData.push( { "name": "sSearch", "value": oSettings.oPreviousSearch.sSearch } );
					aoData.push( { "name": "bRegex",  "value": oSettings.oPreviousSearch.bRegex } );
					for ( i=0 ; i<iColumns ; i++ )
					{
						aoData.push( { "name": "sSearch_"+i,     "value": oSettings.aoPreSearchCols[i].sSearch } );
						aoData.push( { "name": "bRegex_"+i,      "value": oSettings.aoPreSearchCols[i].bRegex } );
						aoData.push( { "name": "bSearchable_"+i, "value": oSettings.aoColumns[i].bSearchable } );
					}
				}
				
				/* Sorting */
				if ( oSettings.oFeatures.bSort !== false )
				{
					var iFixed = oSettings.aaSortingFixed !== null ? oSettings.aaSortingFixed.length : 0;
					var iUser = oSettings.aaSorting.length;
					aoData.push( { "name": "iSortingCols",   "value": iFixed+iUser } );
					for ( i=0 ; i<iFixed ; i++ )
					{
						aoData.push( { "name": "iSortCol_"+i,  "value": oSettings.aaSortingFixed[i][0] } );
						aoData.push( { "name": "sSortDir_"+i,  "value": oSettings.aaSortingFixed[i][1] } );
					}
					
					for ( i=0 ; i<iUser ; i++ )
					{
						aoData.push( { "name": "iSortCol_"+(i+iFixed),  "value": oSettings.aaSorting[i][0] } );
						aoData.push( { "name": "sSortDir_"+(i+iFixed),  "value": oSettings.aaSorting[i][1] } );
					}
					
					for ( i=0 ; i<iColumns ; i++ )
					{
						aoData.push( { "name": "bSortable_"+i,  "value": oSettings.aoColumns[i].bSortable } );
					}
				}
				
				oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, aoData,
					function(json) {
						_fnAjaxUpdateDraw( oSettings, json );
					} );
				return false;
			}
			else
			{
				return true;
			}
		}
		
		/*
		 * Function: _fnAjaxUpdateDraw
		 * Purpose:  Data the data from the server (nuking the old) and redraw the table
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           object:json - json data return from the server.
		 *             The following must be defined:
		 *               iTotalRecords, iTotalDisplayRecords, aaData
		 *             The following may be defined:
		 *               sColumns
		 */
		function _fnAjaxUpdateDraw ( oSettings, json )
		{
			if ( typeof json.sEcho != 'undefined' )
			{
				/* Protect against old returns over-writing a new one. Possible when you get
				 * very fast interaction, and later queires are completed much faster
				 */
				if ( json.sEcho*1 < oSettings.iDraw )
				{
					return;
				}
				else
				{
					oSettings.iDraw = json.sEcho * 1;
				}
			}
			
			if ( !oSettings.oScroll.bInfinite ||
				   (oSettings.oScroll.bInfinite && (oSettings.bSorted || oSettings.bFiltered)) )
			{
				_fnClearTable( oSettings );
			}
			oSettings._iRecordsTotal = json.iTotalRecords;
			oSettings._iRecordsDisplay = json.iTotalDisplayRecords;
			
			/* Determine if reordering is required */
			var sOrdering = _fnColumnOrdering(oSettings);
			var bReOrder = (typeof json.sColumns != 'undefined' && sOrdering !== "" && json.sColumns != sOrdering );
			if ( bReOrder )
			{
				var aiIndex = _fnReOrderIndex( oSettings, json.sColumns );
			}
			
			for ( var i=0, iLen=json.aaData.length ; i<iLen ; i++ )
			{
				if ( bReOrder )
				{
					/* If we need to re-order, then create a new array with the correct order and add it */
					var aData = [];
					for ( var j=0, jLen=oSettings.aoColumns.length ; j<jLen ; j++ )
					{
						aData.push( json.aaData[i][ aiIndex[j] ] );
					}
					_fnAddData( oSettings, aData );
				}
				else
				{
					/* No re-order required, sever got it "right" - just straight add */
					_fnAddData( oSettings, json.aaData[i] );
				}
			}
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
			oSettings.bAjaxDataGet = false;
			_fnDraw( oSettings );
			oSettings.bAjaxDataGet = true;
			_fnProcessingDisplay( oSettings, false );
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Options (features) HTML
		 */
		
		/*
		 * Function: _fnAddOptionsHtml
		 * Purpose:  Add the options to the page HTML for the table
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnAddOptionsHtml ( oSettings )
		{
			/*
			 * Create a temporary, empty, div which we can later on replace with what we have generated
			 * we do it this way to rendering the 'options' html offline - speed :-)
			 */
			var nHolding = document.createElement( 'div' );
			oSettings.nTable.parentNode.insertBefore( nHolding, oSettings.nTable );
			
			/* 
			 * All DataTables are wrapped in a div - this is not currently optional - backwards 
			 * compatability. It can be removed if you don't want it.
			 */
			oSettings.nTableWrapper = document.createElement( 'div' );
			oSettings.nTableWrapper.className = oSettings.oClasses.sWrapper;
			if ( oSettings.sTableId !== '' )
			{
				oSettings.nTableWrapper.setAttribute( 'id', oSettings.sTableId+'_wrapper' );
			}
			
			/* Track where we want to insert the option */
			var nInsertNode = oSettings.nTableWrapper;
			
			/* Loop over the user set positioning and place the elements as needed */
			var aDom = oSettings.sDom.split('');
			var nTmp, iPushFeature, cOption, nNewNode, cNext, sAttr, j;
			for ( var i=0 ; i<aDom.length ; i++ )
			{
				iPushFeature = 0;
				cOption = aDom[i];
				
				if ( cOption == '<' )
				{
					/* New container div */
					nNewNode = document.createElement( 'div' );
					
					/* Check to see if we should append an id and/or a class name to the container */
					cNext = aDom[i+1];
					if ( cNext == "'" || cNext == '"' )
					{
						sAttr = "";
						j = 2;
						while ( aDom[i+j] != cNext )
						{
							sAttr += aDom[i+j];
							j++;
						}
						
						/* Replace jQuery UI constants */
						if ( sAttr == "H" )
						{
							sAttr = "fg-toolbar ui-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix";
						}
						else if ( sAttr == "F" )
						{
							sAttr = "fg-toolbar ui-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix";
						}
						
						/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
						 * breaks the string into parts and applies them as needed
						 */
						if ( sAttr.indexOf('.') != -1 )
						{
							var aSplit = sAttr.split('.');
							nNewNode.setAttribute('id', aSplit[0].substr(1, aSplit[0].length-1) );
							nNewNode.className = aSplit[1];
						}
						else if ( sAttr.charAt(0) == "#" )
						{
							nNewNode.setAttribute('id', sAttr.substr(1, sAttr.length-1) );
						}
						else
						{
							nNewNode.className = sAttr;
						}
						
						i += j; /* Move along the position array */
					}
					
					nInsertNode.appendChild( nNewNode );
					nInsertNode = nNewNode;
				}
				else if ( cOption == '>' )
				{
					/* End container div */
					nInsertNode = nInsertNode.parentNode;
				}
				else if ( cOption == 'l' && oSettings.oFeatures.bPaginate && oSettings.oFeatures.bLengthChange )
				{
					/* Length */
					nTmp = _fnFeatureHtmlLength( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 'f' && oSettings.oFeatures.bFilter )
				{
					/* Filter */
					nTmp = _fnFeatureHtmlFilter( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 'r' && oSettings.oFeatures.bProcessing )
				{
					/* pRocessing */
					nTmp = _fnFeatureHtmlProcessing( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 't' )
				{
					/* Table */
					nTmp = _fnFeatureHtmlTable( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption ==  'i' && oSettings.oFeatures.bInfo )
				{
					/* Info */
					nTmp = _fnFeatureHtmlInfo( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 'p' && oSettings.oFeatures.bPaginate )
				{
					/* Pagination */
					nTmp = _fnFeatureHtmlPaginate( oSettings );
					iPushFeature = 1;
				}
				else if ( _oExt.aoFeatures.length !== 0 )
				{
					/* Plug-in features */
					var aoFeatures = _oExt.aoFeatures;
					for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
					{
						if ( cOption == aoFeatures[k].cFeature )
						{
							nTmp = aoFeatures[k].fnInit( oSettings );
							if ( nTmp )
							{
								iPushFeature = 1;
							}
							break;
						}
					}
				}
				
				/* Add to the 2D features array */
				if ( iPushFeature == 1 && nTmp !== null )
				{
					if ( typeof oSettings.aanFeatures[cOption] != 'object' )
					{
						oSettings.aanFeatures[cOption] = [];
					}
					oSettings.aanFeatures[cOption].push( nTmp );
					nInsertNode.appendChild( nTmp );
				}
			}
			
			/* Built our DOM structure - replace the holding div with what we want */
			nHolding.parentNode.replaceChild( oSettings.nTableWrapper, nHolding );
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Feature: Filtering
		 */
		
		/*
		 * Function: _fnFeatureHtmlTable
		 * Purpose:  Add any control elements for the table - specifically scrolling
		 * Returns:  node: - Node to add to the DOM
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnFeatureHtmlTable ( oSettings )
		{
			/* Chack if scrolling is enabled or not - if not then leave the DOM unaltered */
			if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
			{
				return oSettings.nTable;
			}
			
			/*
			 * The HTML structure that we want to generate in this function is:
			 *  div - nScroller
			 *    div - nScrollHead
			 *      div - nScrollHeadInner
			 *        table - nScrollHeadTable
			 *          thead - nThead
			 *    div - nScrollBody
			 *      table - oSettings.nTable
			 *        thead - nTheadSize
			 *        tbody - nTbody
			 *    div - nScrollFoot
			 *      div - nScrollFootInner
			 *        table - nScrollFootTable
			 *          tfoot - nTfoot
			 */
			var
			 	nScroller = document.createElement('div'),
			 	nScrollHead = document.createElement('div'),
			 	nScrollHeadInner = document.createElement('div'),
			 	nScrollBody = document.createElement('div'),
			 	nScrollFoot = document.createElement('div'),
			 	nScrollFootInner = document.createElement('div'),
			 	nScrollHeadTable = oSettings.nTable.cloneNode(false),
			 	nScrollFootTable = oSettings.nTable.cloneNode(false),
				nThead = oSettings.nTable.getElementsByTagName('thead')[0],
			 	nTfoot = oSettings.nTable.getElementsByTagName('tfoot').length === 0 ? null : 
					oSettings.nTable.getElementsByTagName('tfoot')[0],
				oClasses = (typeof oInit.bJQueryUI != 'undefined' && oInit.bJQueryUI) ?
			 		_oExt.oJUIClasses : _oExt.oStdClasses;
			
			nScrollHead.appendChild( nScrollHeadInner );
			nScrollFoot.appendChild( nScrollFootInner );
			nScrollBody.appendChild( oSettings.nTable );
			nScroller.appendChild( nScrollHead );
			nScroller.appendChild( nScrollBody );
			nScrollHeadInner.appendChild( nScrollHeadTable );
			nScrollHeadTable.appendChild( nThead );
			if ( nTfoot !== null )
			{
				nScroller.appendChild( nScrollFoot );
				nScrollFootInner.appendChild( nScrollFootTable );
				nScrollFootTable.appendChild( nTfoot );
			}
			
			nScroller.className = oClasses.sScrollWrapper;
			nScrollHead.className = oClasses.sScrollHead;
			nScrollHeadInner.className = oClasses.sScrollHeadInner;
			nScrollBody.className = oClasses.sScrollBody;
			nScrollFoot.className = oClasses.sScrollFoot;
			nScrollFootInner.className = oClasses.sScrollFootInner;
			
			nScrollHead.style.overflow = "hidden";
			nScrollHead.style.position = "relative";
			nScrollFoot.style.overflow = "hidden";
			nScrollBody.style.overflow = "auto";
			nScrollHead.style.border = "0";
			nScrollFoot.style.border = "0";
			nScrollHeadInner.style.width = "150%"; /* will be overwritten */
			
			/* Modify attributes to respect the clones */
			nScrollHeadTable.removeAttribute('id');
			nScrollHeadTable.style.marginLeft = "0";
			oSettings.nTable.style.marginLeft = "0";
			if ( nTfoot !== null )
			{
				nScrollFootTable.removeAttribute('id');
				nScrollFootTable.style.marginLeft = "0";
			}
			
			/* Move any caption elements from the body to the header */
			var nCaptions = $('>caption', oSettings.nTable);
			for ( var i=0, iLen=nCaptions.length ; i<iLen ; i++ )
			{
				nScrollHeadTable.appendChild( nCaptions[i] );
			}
			
			/*
			 * Sizing
			 */
			/* When xscrolling add the width and a scroller to move the header with the body */
			if ( oSettings.oScroll.sX !== "" )
			{
				nScrollHead.style.width = _fnStringToCss( oSettings.oScroll.sX );
				nScrollBody.style.width = _fnStringToCss( oSettings.oScroll.sX );
				
				if ( nTfoot !== null )
				{
					nScrollFoot.style.width = _fnStringToCss( oSettings.oScroll.sX );	
				}
				
				/* When the body is scrolled, then we also want to scroll the headers */
				$(nScrollBody).scroll( function (e) {
					nScrollHead.scrollLeft = this.scrollLeft;
					
					if ( nTfoot !== null )
					{
						nScrollFoot.scrollLeft = this.scrollLeft;
					}
				} );
			}
			
			/* When yscrolling, add the height */
			if ( oSettings.oScroll.sY !== "" )
			{
				nScrollBody.style.height = _fnStringToCss( oSettings.oScroll.sY );
			}
			
			/* Redraw - align columns across the tables */
			oSettings.aoDrawCallback.push( {
				"fn": _fnScrollDraw,
				"sName": "scrolling"
			} );
			
			/* Infinite scrolling event handlers */
			if ( oSettings.oScroll.bInfinite )
			{
				$(nScrollBody).scroll( function() {
					/* Use a blocker to stop scrolling from loading more data while other data is still loading */
					if ( !oSettings.bDrawing )
					{
						/* Check if we should load the next data set */
						if ( $(this).scrollTop() + $(this).height() > 
							$(oSettings.nTable).height() - oSettings.oScroll.iLoadGap )
						{
							/* Only do the redraw if we have to - we might be at the end of the data */
							if ( oSettings.fnDisplayEnd() < oSettings.fnRecordsDisplay() )
							{
								_fnPageChange( oSettings, 'next' );
								_fnCalculateEnd( oSettings );
								_fnDraw( oSettings );
							}
						}
					}
				} );
			}
			
			oSettings.nScrollHead = nScrollHead;
			oSettings.nScrollFoot = nScrollFoot;
			
			return nScroller;
		}
		
		/*
		 * Function: _fnScrollDraw
		 * Purpose:  Update the various tables for resizing
		 * Returns:  node: - Node to add to the DOM
		 * Inputs:   object:o - dataTables settings object
		 * Notes:    It's a bit of a pig this function, but basically the idea to:
		 *   1. Re-create the table inside the scrolling div
		 *   2. Take live measurements from the DOM
		 *   3. Apply the measurements
		 *   4. Clean up
		 */
		function _fnScrollDraw ( o )
		{
			var
				nScrollHeadInner = o.nScrollHead.getElementsByTagName('div')[0],
				nScrollHeadTable = nScrollHeadInner.getElementsByTagName('table')[0],
				nScrollBody = o.nTable.parentNode,
				i, iLen, j, jLen, anHeadToSize, anHeadSizers, anFootSizers, anFootToSize, oStyle, iVis,
				iWidth, aApplied=[], iSanityWidth;
			
			/*
			 * 1. Re-create the table inside the scrolling div
			 */
			
			/* Remove the old minimised thead and tfoot elements in the inner table */
			var nTheadSize = o.nTable.getElementsByTagName('thead');
			if ( nTheadSize.length > 0 )
			{
				o.nTable.removeChild( nTheadSize[0] );
			}
			
			if ( o.nTFoot !== null )
			{
				/* Remove the old minimised footer element in the cloned header */
				var nTfootSize = o.nTable.getElementsByTagName('tfoot');
				if ( nTfootSize.length > 0 )
				{
					o.nTable.removeChild( nTfootSize[0] );
				}
			}
			
			/* Clone the current header and footer elements and then place it into the inner table */
			nTheadSize = o.nTHead.cloneNode(true);
			o.nTable.insertBefore( nTheadSize, o.nTable.childNodes[0] );
			
			if ( o.nTFoot !== null )
			{
				nTfootSize = o.nTFoot.cloneNode(true);
				o.nTable.insertBefore( nTfootSize, o.nTable.childNodes[1] );
			}
			
			/*
			 * 2. Take live measurements from the DOM - do not alter the DOM itself!
			 */
			
			/* Remove old sizing and apply the calculated column widths
			 * Get the unique column headers in the newly created (cloned) header. We want to apply the
			 * calclated sizes to this header
			 */
			var nThs = _fnGetUniqueThs( nTheadSize );
			for ( i=0, iLen=nThs.length ; i<iLen ; i++ )
			{
				iVis = _fnVisibleToColumnIndex( o, i );
				nThs[i].style.width = o.aoColumns[iVis].sWidth;
			}
			
			if ( o.nTFoot !== null )
			{
				_fnApplyToChildren( function(n) {
					n.style.width = "";
				}, nTfootSize.getElementsByTagName('tr') );
			}
			
			/* Size the table as a whole */
			iSanityWidth = $(o.nTable).outerWidth();
			if ( o.oScroll.sX === "" )
			{
				/* No x scrolling */
				o.nTable.style.width = "100%";
				
				/* I know this is rubbish - but IE7 will make the width of the table when 100% include
				 * the scrollbar - which is shouldn't. This needs feature detection in future - to do
				 */
				if ( $.browser.msie && $.browser.version <= 7 )
				{
					o.nTable.style.width = _fnStringToCss( $(o.nTable).outerWidth()-o.oScroll.iBarWidth );
				}
			}
			else
			{
				if ( o.oScroll.sXInner !== "" )
				{
					/* x scroll inner has been given - use it */
					o.nTable.style.width = _fnStringToCss(o.oScroll.sXInner);
				}
				else if ( iSanityWidth == $(nScrollBody).width() &&
				   $(nScrollBody).height() < $(o.nTable).height() )
				{
					/* There is y-scrolling - try to take account of the y scroll bar */
					o.nTable.style.width = _fnStringToCss( iSanityWidth-o.oScroll.iBarWidth );
					if ( $(o.nTable).outerWidth() > iSanityWidth-o.oScroll.iBarWidth )
					{
						/* Not possible to take account of it */
						o.nTable.style.width = _fnStringToCss( iSanityWidth );
					}
				}
				else
				{
					/* All else fails */
					o.nTable.style.width = _fnStringToCss( iSanityWidth );
				}
			}
			
			/* Recalculate the sanity width - now that we've applied the required width, before it was
			 * a temporary variable. This is required because the column width calculation is done
			 * before this table DOM is created.
			 */
			iSanityWidth = $(o.nTable).outerWidth();
			
			/* We want the hidden header to have zero height, so remove padding and borders. Then
			 * set the width based on the real headers
			 */
			anHeadToSize = o.nTHead.getElementsByTagName('tr');
			anHeadSizers = nTheadSize.getElementsByTagName('tr');
			
			_fnApplyToChildren( function(nSizer, nToSize) {
				oStyle = nSizer.style;
				oStyle.paddingTop = "0";
				oStyle.paddingBottom = "0";
				oStyle.borderTopWidth = "0";
				oStyle.borderBottomWidth = "0";
				oStyle.height = 0;
				
				iWidth = $(nSizer).width();
				nToSize.style.width = _fnStringToCss( iWidth );
				aApplied.push( iWidth );
			}, anHeadSizers, anHeadToSize );
			$(anHeadSizers).height(0);
			
			if ( o.nTFoot !== null )
			{
				/* Clone the current footer and then place it into the body table as a "hidden header" */
				anFootSizers = nTfootSize.getElementsByTagName('tr');
				anFootToSize = o.nTFoot.getElementsByTagName('tr');
				
				_fnApplyToChildren( function(nSizer, nToSize) {
					oStyle = nSizer.style;
					oStyle.paddingTop = "0";
					oStyle.paddingBottom = "0";
					oStyle.borderTopWidth = "0";
					oStyle.borderBottomWidth = "0";
					
					iWidth = $(nSizer).width();
					nToSize.style.width = _fnStringToCss( iWidth );
					aApplied.push( iWidth );
				}, anFootSizers, anFootToSize );
				$(anFootSizers).height(0);
			}
			
			/*
			 * 3. Apply the measurements
			 */
			
			/* "Hide" the header and footer that we used for the sizing. We want to also fix their width
			 * to what they currently are
			 */
			_fnApplyToChildren( function(nSizer) {
				nSizer.innerHTML = "";
				nSizer.style.width = _fnStringToCss( aApplied.shift() );
			}, anHeadSizers );
			
			if ( o.nTFoot !== null )
			{
				_fnApplyToChildren( function(nSizer) {
					nSizer.innerHTML = "";
					nSizer.style.width = _fnStringToCss( aApplied.shift() );
				}, anFootSizers );
			}
			
			/* Sanity check that the table is of a sensible width. If not then we are going to get
			 * misalignment
			 */
			if ( $(o.nTable).outerWidth() < iSanityWidth )
			{
				if ( o.oScroll.sX === "" )
				{
					_fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
						" misalignment. It is suggested that you enable x-scrolling or increase the width"+
						" the table has in which to be drawn" );
				}
				else if ( o.oScroll.sXInner !== "" )
				{
					_fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
						" misalignment. It is suggested that you increase the sScrollXInner property to"+
						" allow it to draw in a larger area, or simply remove that parameter to allow"+
						" automatic calculation" );
				}
			}
			
			
			/*
			 * 4. Clean up
			 */
			
			if ( o.oScroll.sY === "" )
			{
				/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
				 * the scrollbar height from the visible display, rather than adding it on. We need to
				 * set the height in order to sort this. Don't want to do it in any other browsers.
				 */
				if ( $.browser.msie && $.browser.version <= 7 )
				{
					nScrollBody.style.height = _fnStringToCss( o.nTable.offsetHeight+o.oScroll.iBarWidth );
				}
			}
			
			if ( o.oScroll.sY !== "" && o.oScroll.bCollapse )
			{
				nScrollBody.style.height = _fnStringToCss( o.oScroll.sY );
				
				var iExtra = (o.oScroll.sX !== "" && o.nTable.offsetWidth > nScrollBody.offsetWidth) ?
				 	o.oScroll.iBarWidth : 0;
				if ( o.nTable.offsetHeight < nScrollBody.offsetHeight )
				{
					nScrollBody.style.height = _fnStringToCss( $(o.nTable).height()+iExtra );
				}
			}
			
			/* Finally set the width's of the header and footer tables */
			var iOuterWidth = $(o.nTable).outerWidth();
			nScrollHeadTable.style.width = _fnStringToCss( iOuterWidth );
			nScrollHeadInner.style.width = _fnStringToCss( iOuterWidth+o.oScroll.iBarWidth );
			nScrollHeadInner.parentNode.style.width = _fnStringToCss( $(nScrollBody).width() );
			
			if ( o.nTFoot !== null )
			{
				var
					nScrollFootInner = o.nScrollFoot.getElementsByTagName('div')[0],
					nScrollFootTable = nScrollFootInner.getElementsByTagName('table')[0];
				
				nScrollFootInner.style.width = _fnStringToCss( o.nTable.offsetWidth+o.oScroll.iBarWidth );
				nScrollFootTable.style.width = _fnStringToCss( o.nTable.offsetWidth );
			}
			
			/* If sorting or filtering has occured, jump the scrolling back to the top */
			if ( o.bSorted || o.bFiltered )
			{
				nScrollBody.scrollTop = 0;
			}
		}
		
		/*
		 * Function: _fnAjustColumnSizing
		 * Purpose:  Ajust the table column widths for new data
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 * Notes:    You would probably want to do a redraw after calling this function!
		 */
		function _fnAjustColumnSizing ( oSettings )
		{
			/* Not interested in doing column width calculation if autowidth is disabled */
			if ( oSettings.oFeatures.bAutoWidth === false )
			{
				return false;
			}
			
			_fnCalculateColumnWidths( oSettings );
			for ( var i=0 , iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oSettings.aoColumns[i].nTh.style.width = oSettings.aoColumns[i].sWidth;
			}
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Feature: Filtering
		 */
		
		/*
		 * Function: _fnFeatureHtmlFilter
		 * Purpose:  Generate the node required for filtering text
		 * Returns:  node
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnFeatureHtmlFilter ( oSettings )
		{
			var nFilter = document.createElement( 'div' );
			if ( oSettings.sTableId !== '' && typeof oSettings.aanFeatures.f == "undefined" )
			{
				nFilter.setAttribute( 'id', oSettings.sTableId+'_filter' );
			}
			nFilter.className = oSettings.oClasses.sFilter;
			var sSpace = oSettings.oLanguage.sSearch==="" ? "" : " ";
			nFilter.innerHTML = oSettings.oLanguage.sSearch+sSpace+'<input type="text" />';
			
			var jqFilter = $("input", nFilter);
			jqFilter.val( oSettings.oPreviousSearch.sSearch.replace('"','&quot;') );
			jqFilter.keyup( function(e) {
				/* Update all other filter input elements for the new display */
				var n = oSettings.aanFeatures.f;
				for ( var i=0, iLen=n.length ; i<iLen ; i++ )
				{
					if ( n[i] != this.parentNode )
					{
						$('input', n[i]).val( this.value );
					}
				}
				
				/* Now do the filter */
				if ( this.value != oSettings.oPreviousSearch.sSearch )
				{
					_fnFilterComplete( oSettings, { 
						"sSearch": this.value, 
						"bRegex":  oSettings.oPreviousSearch.bRegex,
						"bSmart":  oSettings.oPreviousSearch.bSmart 
					} );
				}
			} );
			
			jqFilter.keypress( function(e) {
				/* Prevent default */
				if ( e.keyCode == 13 )
				{
					return false;
				}
			} );
			
			return nFilter;
		}
		
		/*
		 * Function: _fnFilterComplete
		 * Purpose:  Filter the table using both the global filter and column based filtering
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           object:oSearch: search information
		 *           int:iForce - optional - force a research of the master array (1) or not (undefined or 0)
		 */
		function _fnFilterComplete ( oSettings, oInput, iForce )
		{
			/* Filter on everything */
			_fnFilter( oSettings, oInput.sSearch, iForce, oInput.bRegex, oInput.bSmart );
			
			/* Now do the individual column filter */
			for ( var i=0 ; i<oSettings.aoPreSearchCols.length ; i++ )
			{
				_fnFilterColumn( oSettings, oSettings.aoPreSearchCols[i].sSearch, i, 
					oSettings.aoPreSearchCols[i].bRegex, oSettings.aoPreSearchCols[i].bSmart );
			}
			
			/* Custom filtering */
			if ( _oExt.afnFiltering.length !== 0 )
			{
				_fnFilterCustom( oSettings );
			}
			
			/* Tell the draw function we have been filtering */
			oSettings.bFiltered = true;
			
			/* Redraw the table */
			oSettings._iDisplayStart = 0;
			_fnCalculateEnd( oSettings );
			_fnDraw( oSettings );
			
			/* Rebuild search array 'offline' */
			_fnBuildSearchArray( oSettings, 0 );
		}
		
		/*
		 * Function: _fnFilterCustom
		 * Purpose:  Apply custom filtering functions
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnFilterCustom( oSettings )
		{
			var afnFilters = _oExt.afnFiltering;
			for ( var i=0, iLen=afnFilters.length ; i<iLen ; i++ )
			{
				var iCorrector = 0;
				for ( var j=0, jLen=oSettings.aiDisplay.length ; j<jLen ; j++ )
				{
					var iDisIndex = oSettings.aiDisplay[j-iCorrector];
					
					/* Check if we should use this row based on the filtering function */
					if ( !afnFilters[i]( oSettings, oSettings.aoData[iDisIndex]._aData, iDisIndex ) )
					{
						oSettings.aiDisplay.splice( j-iCorrector, 1 );
						iCorrector++;
					}
				}
			}
		}
		
		/*
		 * Function: _fnFilterColumn
		 * Purpose:  Filter the table on a per-column basis
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           string:sInput - string to filter on
		 *           int:iColumn - column to filter
		 *           bool:bRegex - treat search string as a regular expression or not
		 *           bool:bSmart - use smart filtering or not
		 */
		function _fnFilterColumn ( oSettings, sInput, iColumn, bRegex, bSmart )
		{
			if ( sInput === "" )
			{
				return;
			}
			
			var iIndexCorrector = 0;
			var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart );
			
			for ( var i=oSettings.aiDisplay.length-1 ; i>=0 ; i-- )
			{
				var sData = _fnDataToSearch( oSettings.aoData[ oSettings.aiDisplay[i] ]._aData[iColumn],
					oSettings.aoColumns[iColumn].sType );
				if ( ! rpSearch.test( sData ) )
				{
					oSettings.aiDisplay.splice( i, 1 );
					iIndexCorrector++;
				}
			}
		}
		
		/*
		 * Function: _fnFilter
		 * Purpose:  Filter the data table based on user input and draw the table
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           string:sInput - string to filter on
		 *           int:iForce - optional - force a research of the master array (1) or not (undefined or 0)
		 *           bool:bRegex - treat as a regular expression or not
		 *           bool:bSmart - perform smart filtering or not
		 */
		function _fnFilter( oSettings, sInput, iForce, bRegex, bSmart )
		{
			var i;
			var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart );
			
			/* Check if we are forcing or not - optional parameter */
			if ( typeof iForce == 'undefined' || iForce === null )
			{
				iForce = 0;
			}
			
			/* Need to take account of custom filtering functions - always filter */
			if ( _oExt.afnFiltering.length !== 0 )
			{
				iForce = 1;
			}
			
			/*
			 * If the input is blank - we want the full data set
			 */
			if ( sInput.length <= 0 )
			{
				oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			}
			else
			{
				/*
				 * We are starting a new search or the new search string is smaller 
				 * then the old one (i.e. delete). Search from the master array
			 	 */
				if ( oSettings.aiDisplay.length == oSettings.aiDisplayMaster.length ||
					   oSettings.oPreviousSearch.sSearch.length > sInput.length || iForce == 1 ||
					   sInput.indexOf(oSettings.oPreviousSearch.sSearch) !== 0 )
				{
					/* Nuke the old display array - we are going to rebuild it */
					oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);
					
					/* Force a rebuild of the search array */
					_fnBuildSearchArray( oSettings, 1 );
					
					/* Search through all records to populate the search array
					 * The the oSettings.aiDisplayMaster and asDataSearch arrays have 1 to 1 
					 * mapping
					 */
					for ( i=0 ; i<oSettings.aiDisplayMaster.length ; i++ )
					{
						if ( rpSearch.test(oSettings.asDataSearch[i]) )
						{
							oSettings.aiDisplay.push( oSettings.aiDisplayMaster[i] );
						}
					}
			  }
			  else
				{
			  	/* Using old search array - refine it - do it this way for speed
			  	 * Don't have to search the whole master array again
			 		 */
			  	var iIndexCorrector = 0;
			  	
			  	/* Search the current results */
			  	for ( i=0 ; i<oSettings.asDataSearch.length ; i++ )
					{
			  		if ( ! rpSearch.test(oSettings.asDataSearch[i]) )
						{
			  			oSettings.aiDisplay.splice( i-iIndexCorrector, 1 );
			  			iIndexCorrector++;
			  		}
			  	}
			  }
			}
			oSettings.oPreviousSearch.sSearch = sInput;
			oSettings.oPreviousSearch.bRegex = bRegex;
			oSettings.oPreviousSearch.bSmart = bSmart;
		}
		
		/*
		 * Function: _fnBuildSearchArray
		 * Purpose:  Create an array which can be quickly search through
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           int:iMaster - use the master data array - optional
		 */
		function _fnBuildSearchArray ( oSettings, iMaster )
		{
			/* Clear out the old data */
			oSettings.asDataSearch.splice( 0, oSettings.asDataSearch.length );
			
			var aArray = (typeof iMaster != 'undefined' && iMaster == 1) ?
			 	oSettings.aiDisplayMaster : oSettings.aiDisplay;
			
			for ( var i=0, iLen=aArray.length ; i<iLen ; i++ )
			{
				oSettings.asDataSearch[i] = _fnBuildSearchRow( oSettings, 
					oSettings.aoData[ aArray[i] ]._aData );
			}
		}
		
		/*
		 * Function: _fnBuildSearchRow
		 * Purpose:  Create a searchable string from a single data row
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           array:aData - aoData[]._aData array to use for the data to search
		 */
		function _fnBuildSearchRow( oSettings, aData )
		{
			var sSearch = '';
			var nTmp = document.createElement('div');
			
			for ( var j=0, jLen=oSettings.aoColumns.length ; j<jLen ; j++ )
			{
				if ( oSettings.aoColumns[j].bSearchable )
				{
					var sData = aData[j];
					sSearch += _fnDataToSearch( sData, oSettings.aoColumns[j].sType )+'  ';
				}
			}
			
			/* If it looks like there is an HTML entity in the string, attempt to decode it */
			if ( sSearch.indexOf('&') !== -1 )
			{
				nTmp.innerHTML = sSearch;
				sSearch = nTmp.textContent ? nTmp.textContent : nTmp.innerText;
				
				/* IE and Opera appear to put an newline where there is a <br> tag - remove it */
				sSearch = sSearch.replace(/\n/g," ").replace(/\r/g,"");
			}
			
			return sSearch;
		}
		
		/*
		 * Function: _fnFilterCreateSearch
		 * Purpose:  Build a regular expression object suitable for searching a table
		 * Returns:  RegExp: - constructed object
		 * Inputs:   string:sSearch - string to search for
		 *           bool:bRegex - treat as a regular expression or not
		 *           bool:bSmart - perform smart filtering or not
		 */
		function _fnFilterCreateSearch( sSearch, bRegex, bSmart )
		{
			var asSearch, sRegExpString;
			
			if ( bSmart )
			{
				/* Generate the regular expression to use. Something along the lines of:
				 * ^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).*$
				 */
				asSearch = bRegex ? sSearch.split( ' ' ) : _fnEscapeRegex( sSearch ).split( ' ' );
				sRegExpString = '^(?=.*?'+asSearch.join( ')(?=.*?' )+').*$';
				return new RegExp( sRegExpString, "i" );
			}
			else
			{
				sSearch = bRegex ? sSearch : _fnEscapeRegex( sSearch );
				return new RegExp( sSearch, "i" );
			}
		}
		
		/*
		 * Function: _fnDataToSearch
		 * Purpose:  Convert raw data into something that the user can search on
		 * Returns:  string: - search string
		 * Inputs:   string:sData - data to be modified
		 *           string:sType - data type
		 */
		function _fnDataToSearch ( sData, sType )
		{
			if ( typeof _oExt.ofnSearch[sType] == "function" )
			{
				return _oExt.ofnSearch[sType]( sData );
			}
			else if ( sType == "html" )
			{
				return sData.replace(/\n/g," ").replace( /<.*?>/g, "" );
			}
			else if ( typeof sData == "string" )
			{
				return sData.replace(/\n/g," ");
			}
			return sData;
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Feature: Sorting
		 */
		
		/*
	 	 * Function: _fnSort
		 * Purpose:  Change the order of the table
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           bool:bApplyClasses - optional - should we apply classes or not
		 * Notes:    We always sort the master array and then apply a filter again
		 *   if it is needed. This probably isn't optimal - but atm I can't think
		 *   of any other way which is (each has disadvantages). we want to sort aiDisplayMaster - 
		 *   but according to aoData[]._aData
		 */
		function _fnSort ( oSettings, bApplyClasses )
		{
			var aaSort = [];
			var oSort = _oExt.oSort;
			var aoData = oSettings.aoData;
			var iDataSort;
			var iDataType;
			var i, j, jLen;
			
			/* No sorting required if server-side or no sorting array */
			if ( !oSettings.oFeatures.bServerSide && 
				(oSettings.aaSorting.length !== 0 || oSettings.aaSortingFixed !== null) )
			{
				if ( oSettings.aaSortingFixed !== null )
				{
					aaSort = oSettings.aaSortingFixed.concat( oSettings.aaSorting );
				}
				else
				{
					aaSort = oSettings.aaSorting.slice();
				}
				
				/* If there is a sorting data type, and a fuction belonging to it, then we need to
				 * get the data from the developer's function and apply it for this column
				 */
				for ( i=0 ; i<aaSort.length ; i++ )
				{
					var iColumn = aaSort[i][0];
					var iVisColumn = _fnColumnIndexToVisible( oSettings, iColumn );
					var sDataType = oSettings.aoColumns[ iColumn ].sSortDataType;
					if ( typeof _oExt.afnSortData[sDataType] != 'undefined' )
					{
						var aData = _oExt.afnSortData[sDataType]( oSettings, iColumn, iVisColumn );
						for ( j=0, jLen=aoData.length ; j<jLen ; j++ )
						{
							aoData[j]._aData[iColumn] = aData[j];
						}
					}
				}
				
				/* DataTables offers two different methods for doing the 2D array sorting over multiple
				 * columns. The first is to construct a function dynamically, and then evaluate and run
				 * the function, while the second has no need for evalulation, but is a little bit slower.
				 * This is used for environments which do not allow eval() for code execuation such as AIR
				 */
				if ( !window.runtime )
				{
					/* Dynamically created sorting function. Based on the information that we have, we can
					 * create a sorting function as if it were specifically written for this sort. Here we
					 * want to build a function something like (for two column sorting):
					 *  fnLocalSorting = function(a,b){
					 *  	var iTest;
					 *  	iTest = oSort['string-asc']('data11', 'data12');
					 *  	if (iTest === 0)
					 *  		iTest = oSort['numeric-desc']('data21', 'data22');
					 *  		if (iTest === 0)
					 *  			return oSort['numeric-desc'](1,2);
					 *  	return iTest;
					 *  }
					 * So basically we have a test for each column, and if that column matches, test the
					 * next one. If all columns match, then we use a numeric sort on the position the two
					 * row have in the original data array in order to provide a stable sort. In order to
					 * get the position for the numeric stablisation, we need to take a clone of the current
					 * display array and then get the position of the sorting value from that during the
					 * sort.
					 *
					 * Note that for use with the Closure compiler, we need to be very careful how we deal 
					 * with this eval. Closure will rename all of our local variables, resutling in breakage
					 * if the variables in the eval don't also reflect this. For this reason, we need to use
					 * 'this' to store the variables we need in the eval, so we can control them. A little
					 * nasty, but well worth it for using Closure.
					 */
					this.ClosureDataTables = {
						"fn": function(){},
						"data": aoData,
						"sort": _oExt.oSort,
						"master": oSettings.aiDisplayMaster.slice()
					};
					var sDynamicSort = "this.ClosureDataTables.fn = function(a,b){"+
						"var iTest, oSort=this.ClosureDataTables.sort, "+
						"aoData=this.ClosureDataTables.data, "+
						"aiOrig=this.ClosureDataTables.master;";
					
					for ( i=0 ; i<aaSort.length-1 ; i++ )
					{
						iDataSort = oSettings.aoColumns[ aaSort[i][0] ].iDataSort;
						iDataType = oSettings.aoColumns[ iDataSort ].sType;
						sDynamicSort += "iTest = oSort['"+iDataType+"-"+aaSort[i][1]+"']"+
							"( aoData[a]._aData["+iDataSort+"], aoData[b]._aData["+iDataSort+"] ); if ( iTest === 0 )";
					}
					
					if ( aaSort.length > 0 )
					{
						iDataSort = oSettings.aoColumns[ aaSort[aaSort.length-1][0] ].iDataSort;
						iDataType = oSettings.aoColumns[ iDataSort ].sType;
						sDynamicSort += "iTest = oSort['"+iDataType+"-"+aaSort[aaSort.length-1][1]+"']"+
							"( aoData[a]._aData["+iDataSort+"], aoData[b]._aData["+iDataSort+"] );"+
							"if (iTest===0) "+
								"return oSort['numeric-asc'](jQuery.inArray(a,aiOrig), jQuery.inArray(b,aiOrig)); "+
							"return iTest;}";
						
						/* The eval has to be done to a variable for IE */
						eval( sDynamicSort );
						oSettings.aiDisplayMaster.sort( this.ClosureDataTables.fn );
					}
					this.ClosureDataTables = undefined;
				}
				else
				{
					/*
					 * Non-eval() sorting (AIR and other environments which doesn't allow code in eval()
					 * Note that for reasonable sized data sets this method is around 1.5 times slower than
					 * the eval above (hence why it is not used all the time). Oddly enough, it is ever so
					 * slightly faster for very small sets (presumably the eval has overhead).
					 *   Single column (1083 records) - eval: 32mS   AIR: 38mS
					 *   Two columns (1083 records) -   eval: 55mS   AIR: 66mS
					 */
					
					/* Build a cached array so the sort doesn't have to process this stuff on every call */
					var aAirSort = [];
					var iLen = aaSort.length;
					for ( i=0 ; i<iLen ; i++ )
					{
						iDataSort = oSettings.aoColumns[ aaSort[i][0] ].iDataSort;
						aAirSort.push( [
							iDataSort,
							oSettings.aoColumns[ iDataSort ].sType+'-'+aaSort[i][1]
						] );
					}
					
					oSettings.aiDisplayMaster.sort( function (a,b) {
						var iTest;
						for ( var i=0 ; i<iLen ; i++ )
						{
							iTest = oSort[ aAirSort[i][1] ]( aoData[a]._aData[aAirSort[i][0]], aoData[b]._aData[aAirSort[i][0]] );
							if ( iTest !== 0 )
							{
								return iTest;
							}
						}
						return 0;
					} );
				}
			}
			
			/* Alter the sorting classes to take account of the changes */
			if ( typeof bApplyClasses == 'undefined' || bApplyClasses )
			{
				_fnSortingClasses( oSettings );
			}
			
			/* Tell the draw function that we have sorted the data */
			oSettings.bSorted = true;
			
			/* Copy the master data into the draw array and re-draw */
			if ( oSettings.oFeatures.bFilter )
			{
				/* _fnFilter() will redraw the table for us */
				_fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
			}
			else
			{
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				oSettings._iDisplayStart = 0; /* reset display back to page 0 */
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
		}
		
		/*
		 * Function: _fnSortAttachListener
		 * Purpose:  Attach a sort handler (click) to a node
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           node:nNode - node to attach the handler to
		 *           int:iDataIndex - column sorting index
		 *           function:fnCallback - callback function - optional
		 */
		function _fnSortAttachListener ( oSettings, nNode, iDataIndex, fnCallback )
		{
			$(nNode).click( function (e) {
				/* If the column is not sortable - don't to anything */
				if ( oSettings.aoColumns[iDataIndex].bSortable === false )
				{
					return;
				}
				
				/*
				 * This is a little bit odd I admit... I declare a temporary function inside the scope of
				 * _fnDrawHead and the click handler in order that the code presented here can be used 
				 * twice - once for when bProcessing is enabled, and another time for when it is 
				 * disabled, as we need to perform slightly different actions.
				 *   Basically the issue here is that the Javascript engine in modern browsers don't 
				 * appear to allow the rendering engine to update the display while it is still excuting
				 * it's thread (well - it does but only after long intervals). This means that the 
				 * 'processing' display doesn't appear for a table sort. To break the js thread up a bit
				 * I force an execution break by using setTimeout - but this breaks the expected 
				 * thread continuation for the end-developer's point of view (their code would execute
				 * too early), so we on;y do it when we absolutely have to.
				 */
				var fnInnerSorting = function () {
					var iColumn, iNextSort;
					
					/* If the shift key is pressed then we are multipe column sorting */
					if ( e.shiftKey )
					{
						/* Are we already doing some kind of sort on this column? */
						var bFound = false;
						for ( var i=0 ; i<oSettings.aaSorting.length ; i++ )
						{
							if ( oSettings.aaSorting[i][0] == iDataIndex )
							{
								bFound = true;
								iColumn = oSettings.aaSorting[i][0];
								iNextSort = oSettings.aaSorting[i][2]+1;
								
								if ( typeof oSettings.aoColumns[iColumn].asSorting[iNextSort] == 'undefined' )
								{
									/* Reached the end of the sorting options, remove from multi-col sort */
									oSettings.aaSorting.splice( i, 1 );
								}
								else
								{
									/* Move onto next sorting direction */
									oSettings.aaSorting[i][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
									oSettings.aaSorting[i][2] = iNextSort;
								}
								break;
							}
						}
						
						/* No sort yet - add it in */
						if ( bFound === false )
						{
							oSettings.aaSorting.push( [ iDataIndex, 
								oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
						}
					}
					else
					{
						/* If no shift key then single column sort */
						if ( oSettings.aaSorting.length == 1 && oSettings.aaSorting[0][0] == iDataIndex )
						{
							iColumn = oSettings.aaSorting[0][0];
							iNextSort = oSettings.aaSorting[0][2]+1;
							if ( typeof oSettings.aoColumns[iColumn].asSorting[iNextSort] == 'undefined' )
							{
								iNextSort = 0;
							}
							oSettings.aaSorting[0][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
							oSettings.aaSorting[0][2] = iNextSort;
						}
						else
						{
							oSettings.aaSorting.splice( 0, oSettings.aaSorting.length );
							oSettings.aaSorting.push( [ iDataIndex, 
								oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
						}
					}
					
					/* Run the sort */
					_fnSort( oSettings );
				}; /* /fnInnerSorting */
				
				if ( !oSettings.oFeatures.bProcessing )
				{
					fnInnerSorting();
				}
				else
				{
					_fnProcessingDisplay( oSettings, true );
					setTimeout( function() {
						fnInnerSorting();
						if ( !oSettings.oFeatures.bServerSide )
						{
							_fnProcessingDisplay( oSettings, false );
						}
					}, 0 );
				}
				
				/* Call the user specified callback function - used for async user interaction */
				if ( typeof fnCallback == 'function' )
				{
					fnCallback( oSettings );
				}
			} );
		}
		
		/*
		 * Function: _fnSortingClasses
		 * Purpose:  Set the sortting classes on the header
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 * Notes:    It is safe to call this function when bSort and bSortClasses are false
		 */
		function _fnSortingClasses( oSettings )
		{
			var i, iLen, j, jLen, iFound;
			var aaSort, sClass;
			var iColumns = oSettings.aoColumns.length;
			var oClasses = oSettings.oClasses;
			
			for ( i=0 ; i<iColumns ; i++ )
			{
				if ( oSettings.aoColumns[i].bSortable )
				{
					$(oSettings.aoColumns[i].nTh).removeClass( oClasses.sSortAsc +" "+ oClasses.sSortDesc +
				 		" "+ oSettings.aoColumns[i].sSortingClass );
				}
			}
			
			if ( oSettings.aaSortingFixed !== null )
			{
				aaSort = oSettings.aaSortingFixed.concat( oSettings.aaSorting );
			}
			else
			{
				aaSort = oSettings.aaSorting.slice();
			}
			
			/* Apply the required classes to the header */
			for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
			{
				if ( oSettings.aoColumns[i].bSortable )
				{
					sClass = oSettings.aoColumns[i].sSortingClass;
					iFound = -1;
					for ( j=0 ; j<aaSort.length ; j++ )
					{
						if ( aaSort[j][0] == i )
						{
							sClass = ( aaSort[j][1] == "asc" ) ?
								oClasses.sSortAsc : oClasses.sSortDesc;
							iFound = j;
							break;
						}
					}
					$(oSettings.aoColumns[i].nTh).addClass( sClass );
					
					if ( oSettings.bJUI )
					{
						/* jQuery UI uses extra markup */
						var jqSpan = $("span", oSettings.aoColumns[i].nTh);
						jqSpan.removeClass(oClasses.sSortJUIAsc +" "+ oClasses.sSortJUIDesc +" "+ 
							oClasses.sSortJUI +" "+ oClasses.sSortJUIAscAllowed +" "+ oClasses.sSortJUIDescAllowed );
						
						var sSpanClass;
						if ( iFound == -1 )
						{
						 	sSpanClass = oSettings.aoColumns[i].sSortingClassJUI;
						}
						else if ( aaSort[iFound][1] == "asc" )
						{
							sSpanClass = oClasses.sSortJUIAsc;
						}
						else
						{
							sSpanClass = oClasses.sSortJUIDesc;
						}
						
						jqSpan.addClass( sSpanClass );
					}
				}
				else
				{
					/* No sorting on this column, so add the base class. This will have been assigned by
					 * _fnAddColumn
					 */
					$(oSettings.aoColumns[i].nTh).addClass( oSettings.aoColumns[i].sSortingClass );
				}
			}
			
			/* 
			 * Apply the required classes to the table body
			 * Note that this is given as a feature switch since it can significantly slow down a sort
			 * on large data sets (adding and removing of classes is always slow at the best of times..)
			 * Further to this, note that this code is admitadly fairly ugly. It could be made a lot 
			 * simpiler using jQuery selectors and add/removeClass, but that is significantly slower
			 * (on the order of 5 times slower) - hence the direct DOM manipulation here.
			 */
			sClass = oClasses.sSortColumn;
			
			if ( oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses )
			{
				var nTds = _fnGetTdNodes( oSettings );
				
				/* Remove the old classes */
				if ( nTds.length >= iColumns )
				{
					for ( i=0 ; i<iColumns ; i++ )
					{
						if ( nTds[i].className.indexOf(sClass+"1") != -1 )
						{
							for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
							{
								nTds[(iColumns*j)+i].className = 
									$.trim( nTds[(iColumns*j)+i].className.replace( sClass+"1", "" ) );
							}
						}
						else if ( nTds[i].className.indexOf(sClass+"2") != -1 )
						{
							for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
							{
								nTds[(iColumns*j)+i].className = 
									$.trim( nTds[(iColumns*j)+i].className.replace( sClass+"2", "" ) );
							}
						}
						else if ( nTds[i].className.indexOf(sClass+"3") != -1 )
						{
							for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
							{
								nTds[(iColumns*j)+i].className = 
									$.trim( nTds[(iColumns*j)+i].className.replace( " "+sClass+"3", "" ) );
							}
						}
					}
				}
				
				/* Add the new classes to the table */
				var iClass = 1, iTargetCol;
				for ( i=0 ; i<aaSort.length ; i++ )
				{
					iTargetCol = parseInt( aaSort[i][0], 10 );
					for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
					{
						nTds[(iColumns*j)+iTargetCol].className += " "+sClass+iClass;
					}
					
					if ( iClass < 3 )
					{
						iClass++;
					}
				}
			}
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Feature: Pagination. Note that most of the paging logic is done in 
		 * _oExt.oPagination
		 */
		
		/*
		 * Function: _fnFeatureHtmlPaginate
		 * Purpose:  Generate the node required for default pagination
		 * Returns:  node
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnFeatureHtmlPaginate ( oSettings )
		{
			if ( oSettings.oScroll.bInfinite )
			{
				return null;
			}
			
			var nPaginate = document.createElement( 'div' );
			nPaginate.className = oSettings.oClasses.sPaging+oSettings.sPaginationType;
			
			_oExt.oPagination[ oSettings.sPaginationType ].fnInit( oSettings, nPaginate, 
				function( oSettings ) {
					_fnCalculateEnd( oSettings );
					_fnDraw( oSettings );
				}
			);
			
			/* Add a draw callback for the pagination on first instance, to update the paging display */
			if ( typeof oSettings.aanFeatures.p == "undefined" )
			{
				oSettings.aoDrawCallback.push( {
					"fn": function( oSettings ) {
						_oExt.oPagination[ oSettings.sPaginationType ].fnUpdate( oSettings, function( oSettings ) {
							_fnCalculateEnd( oSettings );
							_fnDraw( oSettings );
						} );
					},
					"sName": "pagination"
				} );
			}
			return nPaginate;
		}
		
		/*
		 * Function: _fnPageChange
		 * Purpose:  Alter the display settings to change the page
		 * Returns:  bool:true - page has changed, false - no change (no effect) eg 'first' on page 1
		 * Inputs:   object:oSettings - dataTables settings object
		 *           string:sAction - paging action to take: "first", "previous", "next" or "last"
		 */
		function _fnPageChange ( oSettings, sAction )
		{
			var iOldStart = oSettings._iDisplayStart;
			
			if ( sAction == "first" )
			{
				oSettings._iDisplayStart = 0;
			}
			else if ( sAction == "previous" )
			{
				oSettings._iDisplayStart = oSettings._iDisplayLength>=0 ?
					oSettings._iDisplayStart - oSettings._iDisplayLength :
					0;
				
				/* Correct for underrun */
				if ( oSettings._iDisplayStart < 0 )
				{
				  oSettings._iDisplayStart = 0;
				}
			}
			else if ( sAction == "next" )
			{
				if ( oSettings._iDisplayLength >= 0 )
				{
					/* Make sure we are not over running the display array */
					if ( oSettings._iDisplayStart + oSettings._iDisplayLength < oSettings.fnRecordsDisplay() )
					{
						oSettings._iDisplayStart += oSettings._iDisplayLength;
					}
				}
				else
				{
					oSettings._iDisplayStart = 0;
				}
			}
			else if ( sAction == "last" )
			{
				if ( oSettings._iDisplayLength >= 0 )
				{
					var iPages = parseInt( (oSettings.fnRecordsDisplay()-1) / oSettings._iDisplayLength, 10 ) + 1;
					oSettings._iDisplayStart = (iPages-1) * oSettings._iDisplayLength;
				}
				else
				{
					oSettings._iDisplayStart = 0;
				}
			}
			else
			{
				_fnLog( oSettings, 0, "Unknown paging action: "+sAction );
			}
			
			return iOldStart != oSettings._iDisplayStart;
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Feature: HTML info
		 */
		
		/*
		 * Function: _fnFeatureHtmlInfo
		 * Purpose:  Generate the node required for the info display
		 * Returns:  node
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnFeatureHtmlInfo ( oSettings )
		{
			var nInfo = document.createElement( 'div' );
			nInfo.className = oSettings.oClasses.sInfo;
			
			/* Actions that are to be taken once only for this feature */
			if ( typeof oSettings.aanFeatures.i == "undefined" )
			{
				/* Add draw callback */
				oSettings.aoDrawCallback.push( {
					"fn": _fnUpdateInfo,
					"sName": "information"
				} );
				
				/* Add id */
				if ( oSettings.sTableId !== '' )
				{
					nInfo.setAttribute( 'id', oSettings.sTableId+'_info' );
				}
			}
			
			return nInfo;
		}
		
		/*
		 * Function: _fnUpdateInfo
		 * Purpose:  Update the information elements in the display
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnUpdateInfo ( oSettings )
		{
			/* Show information about the table */
			if ( !oSettings.oFeatures.bInfo || oSettings.aanFeatures.i.length === 0 )
			{
				return;
			}
			
			var
				iStart = oSettings._iDisplayStart+1, iEnd = oSettings.fnDisplayEnd(),
				iMax = oSettings.fnRecordsTotal(), iTotal = oSettings.fnRecordsDisplay(),
				sStart = oSettings.fnFormatNumber( iStart ), sEnd = oSettings.fnFormatNumber( iEnd ),
				sMax = oSettings.fnFormatNumber( iMax ), sTotal = oSettings.fnFormatNumber( iTotal ),
				sOut;
			
			/* When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
			 * internally
			 */
			if ( oSettings.oScroll.bInfinite )
			{
				sStart = oSettings.fnFormatNumber( 1 );
			}
			
			if ( oSettings.fnRecordsDisplay() === 0 && 
				   oSettings.fnRecordsDisplay() == oSettings.fnRecordsTotal() )
			{
				/* Empty record set */
				sOut = oSettings.oLanguage.sInfoEmpty+ oSettings.oLanguage.sInfoPostFix;
			}
			else if ( oSettings.fnRecordsDisplay() === 0 )
			{
				/* Rmpty record set after filtering */
				sOut = oSettings.oLanguage.sInfoEmpty +' '+ 
					oSettings.oLanguage.sInfoFiltered.replace('_MAX_', sMax)+
						oSettings.oLanguage.sInfoPostFix;
			}
			else if ( oSettings.fnRecordsDisplay() == oSettings.fnRecordsTotal() )
			{
				/* Normal record set */
				sOut = oSettings.oLanguage.sInfo.
						replace('_START_', sStart).
						replace('_END_',   sEnd).
						replace('_TOTAL_', sTotal)+ 
					oSettings.oLanguage.sInfoPostFix;
			}
			else
			{
				/* Record set after filtering */
				sOut = oSettings.oLanguage.sInfo.
						replace('_START_', sStart).
						replace('_END_',   sEnd).
						replace('_TOTAL_', sTotal) +' '+ 
					oSettings.oLanguage.sInfoFiltered.replace('_MAX_', 
						oSettings.fnFormatNumber(oSettings.fnRecordsTotal()))+ 
					oSettings.oLanguage.sInfoPostFix;
			}
			
			if ( oSettings.oLanguage.fnInfoCallback !== null )
			{
				sOut = oSettings.oLanguage.fnInfoCallback( oSettings, iStart, iEnd, iMax, iTotal, sOut );
			}
			
			var n = oSettings.aanFeatures.i;
			for ( var i=0, iLen=n.length ; i<iLen ; i++ )
			{
				$(n[i]).html( sOut );
			}
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Feature: Length change
		 */
		
		/*
		 * Function: _fnFeatureHtmlLength
		 * Purpose:  Generate the node required for user display length changing
		 * Returns:  node
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnFeatureHtmlLength ( oSettings )
		{
			if ( oSettings.oScroll.bInfinite )
			{
				return null;
			}
			
			/* This can be overruled by not using the _MENU_ var/macro in the language variable */
			var sName = (oSettings.sTableId === "") ? "" : 'name="'+oSettings.sTableId+'_length"';
			var sStdMenu = '<select size="1" '+sName+'>';
			var i, iLen;
			
			if ( oSettings.aLengthMenu.length == 2 && typeof oSettings.aLengthMenu[0] == 'object' && 
					typeof oSettings.aLengthMenu[1] == 'object' )
			{
				for ( i=0, iLen=oSettings.aLengthMenu[0].length ; i<iLen ; i++ )
				{
					sStdMenu += '<option value="'+oSettings.aLengthMenu[0][i]+'">'+
						oSettings.aLengthMenu[1][i]+'</option>';
				}
			}
			else
			{
				for ( i=0, iLen=oSettings.aLengthMenu.length ; i<iLen ; i++ )
				{
					sStdMenu += '<option value="'+oSettings.aLengthMenu[i]+'">'+
						oSettings.aLengthMenu[i]+'</option>';
				}
			}
			sStdMenu += '</select>';
			
			var nLength = document.createElement( 'div' );
			if ( oSettings.sTableId !== '' && typeof oSettings.aanFeatures.l == "undefined" )
			{
				nLength.setAttribute( 'id', oSettings.sTableId+'_length' );
			}
			nLength.className = oSettings.oClasses.sLength;
			nLength.innerHTML = oSettings.oLanguage.sLengthMenu.replace( '_MENU_', sStdMenu );
			
			/*
			 * Set the length to the current display length - thanks to Andrea Pavlovic for this fix,
			 * and Stefan Skopnik for fixing the fix!
			 */
			$('select option[value="'+oSettings._iDisplayLength+'"]',nLength).attr("selected",true);
			
			$('select', nLength).change( function(e) {
				var iVal = $(this).val();
				
				/* Update all other length options for the new display */
				var n = oSettings.aanFeatures.l;
				for ( i=0, iLen=n.length ; i<iLen ; i++ )
				{
					if ( n[i] != this.parentNode )
					{
						$('select', n[i]).val( iVal );
					}
				}
				
				/* Redraw the table */
				oSettings._iDisplayLength = parseInt(iVal, 10);
				_fnCalculateEnd( oSettings );
				
				/* If we have space to show extra rows (backing up from the end point - then do so */
				if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() )
				{
					oSettings._iDisplayStart = oSettings.fnDisplayEnd() - oSettings._iDisplayLength;
					if ( oSettings._iDisplayStart < 0 )
					{
						oSettings._iDisplayStart = 0;
					}
				}
				
				if ( oSettings._iDisplayLength == -1 )
				{
					oSettings._iDisplayStart = 0;
				}
				
				_fnDraw( oSettings );
			} );
			
			return nLength;
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Feature: Processing incidator
		 */
		
		/*
		 * Function: _fnFeatureHtmlProcessing
		 * Purpose:  Generate the node required for the processing node
		 * Returns:  node
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnFeatureHtmlProcessing ( oSettings )
		{
			var nProcessing = document.createElement( 'div' );
			
			if ( oSettings.sTableId !== '' && typeof oSettings.aanFeatures.r == "undefined" )
			{
				nProcessing.setAttribute( 'id', oSettings.sTableId+'_processing' );
			}
			nProcessing.innerHTML = oSettings.oLanguage.sProcessing;
			nProcessing.className = oSettings.oClasses.sProcessing;
			oSettings.nTable.parentNode.insertBefore( nProcessing, oSettings.nTable );
			
			return nProcessing;
		}
		
		/*
		 * Function: _fnProcessingDisplay
		 * Purpose:  Display or hide the processing indicator
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           bool:
		 *   true - show the processing indicator
		 *   false - don't show
		 */
		function _fnProcessingDisplay ( oSettings, bShow )
		{
			if ( oSettings.oFeatures.bProcessing )
			{
				var an = oSettings.aanFeatures.r;
				for ( var i=0, iLen=an.length ; i<iLen ; i++ )
				{
					an[i].style.visibility = bShow ? "visible" : "hidden";
				}
			}
		}
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Support functions
		 */
		
		/*
		 * Function: _fnVisibleToColumnIndex
		 * Purpose:  Covert the index of a visible column to the index in the data array (take account
		 *   of hidden columns)
		 * Returns:  int:i - the data index
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnVisibleToColumnIndex( oSettings, iMatch )
		{
			var iColumn = -1;
			
			for ( var i=0 ; i<oSettings.aoColumns.length ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible === true )
				{
					iColumn++;
				}
				
				if ( iColumn == iMatch )
				{
					return i;
				}
			}
			
			return null;
		}
		
		/*
		 * Function: _fnColumnIndexToVisible
		 * Purpose:  Covert the index of an index in the data array and convert it to the visible
		 *   column index (take account of hidden columns)
		 * Returns:  int:i - the data index
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnColumnIndexToVisible( oSettings, iMatch )
		{
			var iVisible = -1;
			for ( var i=0 ; i<oSettings.aoColumns.length ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible === true )
				{
					iVisible++;
				}
				
				if ( i == iMatch )
				{
					return oSettings.aoColumns[i].bVisible === true ? iVisible : null;
				}
			}
			
			return null;
		}
		
		
		/*
		 * Function: _fnNodeToDataIndex
		 * Purpose:  Take a TR element and convert it to an index in aoData
		 * Returns:  int:i - index if found, null if not
		 * Inputs:   object:s - dataTables settings object
		 *           node:n - the TR element to find
		 */
		function _fnNodeToDataIndex( s, n )
		{
			var i, iLen;
			
			/* Optimisation - see if the nodes which are currently visible match, since that is
			 * the most likely node to be asked for (a selector or event for example)
			 */
			for ( i=s._iDisplayStart, iLen=s._iDisplayEnd ; i<iLen ; i++ )
			{
				if ( s.aoData[ s.aiDisplay[i] ].nTr == n )
				{
					return s.aiDisplay[i];
				}
			}
			
			/* Otherwise we are in for a slog through the whole data cache */
			for ( i=0, iLen=s.aoData.length ; i<iLen ; i++ )
			{
				if ( s.aoData[i].nTr == n )
				{
					return i;
				}
			}
			return null;
		}
		
		/*
		 * Function: _fnVisbleColumns
		 * Purpose:  Get the number of visible columns
		 * Returns:  int:i - the number of visible columns
		 * Inputs:   object:oS - dataTables settings object
		 */
		function _fnVisbleColumns( oS )
		{
			var iVis = 0;
			for ( var i=0 ; i<oS.aoColumns.length ; i++ )
			{
				if ( oS.aoColumns[i].bVisible === true )
				{
					iVis++;
				}
			}
			return iVis;
		}
		
		/*
		 * Function: _fnCalculateEnd
		 * Purpose:  Rcalculate the end point based on the start point
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnCalculateEnd( oSettings )
		{
			if ( oSettings.oFeatures.bPaginate === false )
			{
				oSettings._iDisplayEnd = oSettings.aiDisplay.length;
			}
			else
			{
				/* Set the end point of the display - based on how many elements there are
				 * still to display
				 */
				if ( oSettings._iDisplayStart + oSettings._iDisplayLength > oSettings.aiDisplay.length ||
					   oSettings._iDisplayLength == -1 )
				{
					oSettings._iDisplayEnd = oSettings.aiDisplay.length;
				}
				else
				{
					oSettings._iDisplayEnd = oSettings._iDisplayStart + oSettings._iDisplayLength;
				}
			}
		}
		
		/*
		 * Function: _fnConvertToWidth
		 * Purpose:  Convert a CSS unit width to pixels (e.g. 2em)
		 * Returns:  int:iWidth - width in pixels
		 * Inputs:   string:sWidth - width to be converted
		 *           node:nParent - parent to get the with for (required for
		 *             relative widths) - optional
		 */
		function _fnConvertToWidth ( sWidth, nParent )
		{
			if ( !sWidth || sWidth === null || sWidth === '' )
			{
				return 0;
			}
			
			if ( typeof nParent == "undefined" )
			{
				nParent = document.getElementsByTagName('body')[0];
			}
			
			var iWidth;
			var nTmp = document.createElement( "div" );
			nTmp.style.width = sWidth;
			
			nParent.appendChild( nTmp );
			iWidth = nTmp.offsetWidth;
			nParent.removeChild( nTmp );
			
			return ( iWidth );
		}
		
		/*
		 * Function: _fnCalculateColumnWidths
		 * Purpose:  Calculate the width of columns for the table
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnCalculateColumnWidths ( oSettings )
		{
			var iTableWidth = oSettings.nTable.offsetWidth;
			var iUserInputs = 0;
			var iTmpWidth;
			var iVisibleColumns = 0;
			var iColums = oSettings.aoColumns.length;
			var i;
			var oHeaders = $('th', oSettings.nTHead);
			
			/* Convert any user input sizes into pixel sizes */
			for ( i=0 ; i<iColums ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible )
				{
					iVisibleColumns++;
					
					if ( oSettings.aoColumns[i].sWidth !== null )
					{
						iTmpWidth = _fnConvertToWidth( oSettings.aoColumns[i].sWidthOrig, 
							oSettings.nTable.parentNode );
						if ( iTmpWidth !== null )
						{
							oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
						}
							
						iUserInputs++;
					}
				}
			}
			
			/* If the number of columns in the DOM equals the number that we have to process in 
			 * DataTables, then we can use the offsets that are created by the web-browser. No custom 
			 * sizes can be set in order for this to happen, nor scrolling used
			 */
			if ( iColums == oHeaders.length && iUserInputs === 0 && iVisibleColumns == iColums &&
				oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
			{
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					iTmpWidth = $(oHeaders[i]).width();
					if ( iTmpWidth !== null )
					{
						oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
					}
				}
			}
			else
			{
				/* Otherwise we are going to have to do some calculations to get the width of each column.
				 * Construct a 1 row table with the widest node in the data, and any user defined widths,
				 * then insert it into the DOM and allow the browser to do all the hard work of
				 * calculating table widths.
				 */
				var
					nCalcTmp = oSettings.nTable.cloneNode( false ),
					nBody = document.createElement( 'tbody' ),
					nTr = document.createElement( 'tr' ),
					nDivSizing;
				
				nCalcTmp.removeAttribute( "id" );
				nCalcTmp.appendChild( oSettings.nTHead.cloneNode(true) );
				if ( oSettings.nTFoot !== null )
				{
					nCalcTmp.appendChild( oSettings.nTFoot.cloneNode(true) );
					_fnApplyToChildren( function(n) {
						n.style.width = "";
					}, nCalcTmp.getElementsByTagName('tr') );
				}
				
				nCalcTmp.appendChild( nBody );
				nBody.appendChild( nTr );
				
				/* Remove any sizing that was previously applied by the styles */
				var jqColSizing = $('thead th', nCalcTmp);
				if ( jqColSizing.length === 0 )
				{
					jqColSizing = $('tbody tr:eq(0)>td', nCalcTmp);
				}
				jqColSizing.each( function (i) {
					this.style.width = "";
					
					var iIndex = _fnVisibleToColumnIndex( oSettings, i );
					if ( iIndex !== null && oSettings.aoColumns[iIndex].sWidthOrig !== "" )
					{
						this.style.width = oSettings.aoColumns[iIndex].sWidthOrig;
					}
				} );
				
				/* Find the biggest td for each column and put it into the table */
				for ( i=0 ; i<iColums ; i++ )
				{
					if ( oSettings.aoColumns[i].bVisible )
					{
						var nTd = _fnGetWidestNode( oSettings, i );
						if ( nTd !== null )
						{
							nTd = nTd.cloneNode(true);
							nTr.appendChild( nTd );
						}
					}
				}
				
				/* Build the table and 'display' it */
				var nWrapper = oSettings.nTable.parentNode;
				nWrapper.appendChild( nCalcTmp );
				
				/* When scrolling (X or Y) we want to set the width of the table as appropriate. However,
				 * when not scrolling leave the table width as it is. This results in slightly different,
				 * but I think correct behaviour
				 */
				if ( oSettings.oScroll.sX !== "" && oSettings.oScroll.sXInner !== "" )
				{
					nCalcTmp.style.width = _fnStringToCss(oSettings.oScroll.sXInner);
				}
				else if ( oSettings.oScroll.sX !== "" )
				{
					nCalcTmp.style.width = "";
					if ( $(nCalcTmp).width() < nWrapper.offsetWidth )
					{
						nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
					}
				}
				else if ( oSettings.oScroll.sY !== "" )
				{
					nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
				}
				nCalcTmp.style.visibility = "hidden";
				
				/* Scrolling considerations */
				_fnScrollingWidthAdjust( oSettings, nCalcTmp );
				
				/* Read the width's calculated by the browser and store them for use by the caller. We
				 * first of all try to use the elements in the body, but it is possible that there are
				 * no elements there, under which circumstances we use the header elements
				 */
				var oNodes = $("tbody tr:eq(0)>td", nCalcTmp);
				if ( oNodes.length === 0 )
				{
					oNodes = $("thead tr:eq(0)>th", nCalcTmp);
				}
				
				var iIndex, iCorrector = 0, iWidth;
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					if ( oSettings.aoColumns[i].bVisible )
					{
						iWidth = $(oNodes[iCorrector]).width();
						if ( iWidth !== null && iWidth > 0 )
						{
							oSettings.aoColumns[i].sWidth = _fnStringToCss( iWidth );
						}
						iCorrector++;
					}
				}
				
				oSettings.nTable.style.width = _fnStringToCss( $(nCalcTmp).outerWidth() );
				nCalcTmp.parentNode.removeChild( nCalcTmp );
			}
		}
		
		/*
		 * Function: _fnScrollingWidthAdjust
		 * Purpose:  Adjust a table's width to take account of scrolling
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           node:n - table node
		 */
		function _fnScrollingWidthAdjust ( oSettings, n )
		{
			if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY !== "" )
			{
				/* When y-scrolling only, we want to remove the width of the scroll bar so the table
				 * + scroll bar will fit into the area avaialble.
				 */
				var iOrigWidth = $(n).width();
				n.style.width = _fnStringToCss( $(n).outerWidth()-oSettings.oScroll.iBarWidth );
			}
			else if ( oSettings.oScroll.sX !== "" )
			{
				/* When x-scrolling both ways, fix the table at it's current size, without adjusting */
				n.style.width = _fnStringToCss( $(n).outerWidth() );
			}
		}
		
		/*
		 * Function: _fnGetWidestNode
		 * Purpose:  Get the widest node
		 * Returns:  string: - max strlens for each column
		 * Inputs:   object:oSettings - dataTables settings object
		 *           int:iCol - column of interest
		 *           boolean:bFast - Should we use fast (but non-accurate) calculation - optional,
		 *             default true
		 * Notes:    This operation is _expensive_ (!!!). It requires a lot of DOM interaction, but
		 *   this is the only way to reliably get the widest string. For example 'mmm' would be wider
		 *   than 'iiii' so we can't just ocunt characters. If this can be optimised it would be good
		 *   to do so!
		 */
		function _fnGetWidestNode( oSettings, iCol, bFast )
		{
			/* Use fast not non-accurate calculate based on the strlen */
			if ( typeof bFast == 'undefined' || bFast )
			{
				var iMaxLen = _fnGetMaxLenString( oSettings, iCol );
				var iFastVis = _fnColumnIndexToVisible( oSettings, iCol);
				if ( iMaxLen < 0 )
				{
					return null;
				}
				return oSettings.aoData[iMaxLen].nTr.getElementsByTagName('td')[iFastVis];
			}
			
			/* Use the slow approach, but get high quality answers - note that this code is not actually
			 * used by DataTables by default. If you want to use it you can alter the call to 
			 * _fnGetWidestNode to pass 'false' as the third argument
			 */
			var
				iMax = -1, i, iLen,
				iMaxIndex = -1,
				n = document.createElement('div');
			
			n.style.visibility = "hidden";
			n.style.position = "absolute";
			document.body.appendChild( n );
			
			for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
			{
				n.innerHTML = oSettings.aoData[i]._aData[iCol];
				if ( n.offsetWidth > iMax )
				{
					iMax = n.offsetWidth;
					iMaxIndex = i;
				}
			}
			document.body.removeChild( n );
			
			if ( iMaxIndex >= 0 )
			{
				var iVis = _fnColumnIndexToVisible( oSettings, iCol);
				var nRet = oSettings.aoData[iMaxIndex].nTr.getElementsByTagName('td')[iVis];
				if ( nRet )
				{
					return nRet;
				}
			}
			return null;
		}
		
		/*
		 * Function: _fnGetMaxLenString
		 * Purpose:  Get the maximum strlen for each data column
		 * Returns:  string: - max strlens for each column
		 * Inputs:   object:oSettings - dataTables settings object
		 *           int:iCol - column of interest
		 */
		function _fnGetMaxLenString( oSettings, iCol )
		{
			var iMax = -1;
			var iMaxIndex = -1;
			
			for ( var i=0 ; i<oSettings.aoData.length ; i++ )
			{
				var s = oSettings.aoData[i]._aData[iCol];
				if ( s.length > iMax )
				{
					iMax = s.length;
					iMaxIndex = i;
				}
			}
			
			return iMaxIndex;
		}
		
		/*
		 * Function: _fnStringToCss
		 * Purpose:  Append a CSS unit (only if required) to a string
		 * Returns:  0 if match, 1 if length is different, 2 if no match
		 * Inputs:   array:aArray1 - first array
		 *           array:aArray2 - second array
		 */
		function _fnStringToCss( s )
		{
			if ( s === null )
			{
				return "0px";
			}
			
			if ( typeof s == 'number' )
			{
				if ( s < 0 )
				{
					return "0px";
				}
				return s+"px";
			}
			
			/* Check if the last character is not 0-9 */
			var c = s.charCodeAt( s.length-1 );
			if (c < 0x30 || c > 0x39)
			{
				return s;
			}
			return s+"px";
		}
		
		/*
		 * Function: _fnArrayCmp
		 * Purpose:  Compare two arrays
		 * Returns:  0 if match, 1 if length is different, 2 if no match
		 * Inputs:   array:aArray1 - first array
		 *           array:aArray2 - second array
		 */
		function _fnArrayCmp( aArray1, aArray2 )
		{
			if ( aArray1.length != aArray2.length )
			{
				return 1;
			}
			
			for ( var i=0 ; i<aArray1.length ; i++ )
			{
				if ( aArray1[i] != aArray2[i] )
				{
					return 2;
				}
			}
			
			return 0;
		}
		
		/*
		 * Function: _fnDetectType
		 * Purpose:  Get the sort type based on an input string
		 * Returns:  string: - type (defaults to 'string' if no type can be detected)
		 * Inputs:   string:sData - data we wish to know the type of
		 * Notes:    This function makes use of the DataTables plugin objct _oExt 
		 *   (.aTypes) such that new types can easily be added.
		 */
		function _fnDetectType( sData )
		{
			var aTypes = _oExt.aTypes;
			var iLen = aTypes.length;
			
			for ( var i=0 ; i<iLen ; i++ )
			{
				var sType = aTypes[i]( sData );
				if ( sType !== null )
				{
					return sType;
				}
			}
			
			return 'string';
		}
		
		/*
		 * Function: _fnSettingsFromNode
		 * Purpose:  Return the settings object for a particular table
		 * Returns:  object: Settings object - or null if not found
		 * Inputs:   node:nTable - table we are using as a dataTable
		 */
		function _fnSettingsFromNode ( nTable )
		{
			for ( var i=0 ; i<_aoSettings.length ; i++ )
			{
				if ( _aoSettings[i].nTable == nTable )
				{
					return _aoSettings[i];
				}
			}
			
			return null;
		}
		
		/*
		 * Function: _fnGetDataMaster
		 * Purpose:  Return an array with the full table data
		 * Returns:  array array:aData - Master data array
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnGetDataMaster ( oSettings )
		{
			var aData = [];
			var iLen = oSettings.aoData.length;
			for ( var i=0 ; i<iLen; i++ )
			{
				aData.push( oSettings.aoData[i]._aData );
			}
			return aData;
		}
		
		/*
		 * Function: _fnGetTrNodes
		 * Purpose:  Return an array with the TR nodes for the table
		 * Returns:  array: - TR array
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnGetTrNodes ( oSettings )
		{
			var aNodes = [];
			var iLen = oSettings.aoData.length;
			for ( var i=0 ; i<iLen ; i++ )
			{
				aNodes.push( oSettings.aoData[i].nTr );
			}
			return aNodes;
		}
		
		/*
		 * Function: _fnGetTdNodes
		 * Purpose:  Return an array with the TD nodes for the table
		 * Returns:  array: - TD array
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnGetTdNodes ( oSettings )
		{
			var nTrs = _fnGetTrNodes( oSettings );
			var nTds = [], nTd;
			var anReturn = [];
			var iCorrector;
			var iRow, iRows, iColumn, iColumns;
			
			for ( iRow=0, iRows=nTrs.length ; iRow<iRows ; iRow++ )
			{
				nTds = [];
				for ( iColumn=0, iColumns=nTrs[iRow].childNodes.length ; iColumn<iColumns ; iColumn++ )
				{
					nTd = nTrs[iRow].childNodes[iColumn];
					if ( nTd.nodeName.toUpperCase() == "TD" )
					{
						nTds.push( nTd );
					}
				}
				
				iCorrector = 0;
				for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
				{
					if ( oSettings.aoColumns[iColumn].bVisible )
					{
						anReturn.push( nTds[iColumn-iCorrector] );
					}
					else
					{
						anReturn.push( oSettings.aoData[iRow]._anHidden[iColumn] );
						iCorrector++;
					}
				}
			}
			return anReturn;
		}
		
		/*
		 * Function: _fnEscapeRegex
		 * Purpose:  scape a string stuch that it can be used in a regular expression
		 * Returns:  string: - escaped string
		 * Inputs:   string:sVal - string to escape
		 */
		function _fnEscapeRegex ( sVal )
		{
			var acEscape = [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^' ];
		  var reReplace = new RegExp( '(\\' + acEscape.join('|\\') + ')', 'g' );
		  return sVal.replace(reReplace, '\\$1');
		}
		
		/*
		 * Function: _fnDeleteIndex
		 * Purpose:  Take an array of integers (index array) and remove a target integer (value - not 
		 *             the key!)
		 * Returns:  -
		 * Inputs:   a:array int - Index array to target
		 *           int:iTarget - value to find
		 */
		function _fnDeleteIndex( a, iTarget )
		{
			var iTargetIndex = -1;
			
			for ( var i=0, iLen=a.length ; i<iLen ; i++ )
			{
				if ( a[i] == iTarget )
				{
					iTargetIndex = i;
				}
				else if ( a[i] > iTarget )
				{
					a[i]--;
				}
			}
			
			if ( iTargetIndex != -1 )
			{
				a.splice( iTargetIndex, 1 );
			}
		}
		
		/*
		 * Function: _fnReOrderIndex
		 * Purpose:  Figure out how to reorder a display list
		 * Returns:  array int:aiReturn - index list for reordering
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnReOrderIndex ( oSettings, sColumns )
		{
			var aColumns = sColumns.split(',');
			var aiReturn = [];
			
			for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				for ( var j=0 ; j<iLen ; j++ )
				{
					if ( oSettings.aoColumns[i].sName == aColumns[j] )
					{
						aiReturn.push( j );
						break;
					}
				}
			}
			
			return aiReturn;
		}
		
		/*
		 * Function: _fnColumnOrdering
		 * Purpose:  Get the column ordering that DataTables expects
		 * Returns:  string: - comma separated list of names
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnColumnOrdering ( oSettings )
		{
			var sNames = '';
			for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				sNames += oSettings.aoColumns[i].sName+',';
			}
			if ( sNames.length == iLen )
			{
				return "";
			}
			return sNames.slice(0, -1);
		}
		
		/*
		 * Function: _fnLog
		 * Purpose:  Log an error message
		 * Returns:  -
		 * Inputs:   int:iLevel - log error messages, or display them to the user
		 *           string:sMesg - error message
		 */
		function _fnLog( oSettings, iLevel, sMesg )
		{
			var sAlert = oSettings.sTableId === "" ?
			 	"DataTables warning: " +sMesg :
			 	"DataTables warning (table id = '"+oSettings.sTableId+"'): " +sMesg;
			
			if ( iLevel === 0 )
			{
				if ( _oExt.sErrMode == 'alert' )
				{
					alert( sAlert );
				}
				else
				{
					throw sAlert;
				}
				return;
			}
			else if ( typeof console != 'undefined' && typeof console.log != 'undefined' )
			{
				console.log( sAlert );
			}
		}
		
		/*
		 * Function: _fnClearTable
		 * Purpose:  Nuke the table
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnClearTable( oSettings )
		{
			oSettings.aoData.splice( 0, oSettings.aoData.length );
			oSettings.aiDisplayMaster.splice( 0, oSettings.aiDisplayMaster.length );
			oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length );
			_fnCalculateEnd( oSettings );
		}
		
		/*
		 * Function: _fnSaveState
		 * Purpose:  Save the state of a table in a cookie such that the page can be reloaded
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 */
		function _fnSaveState ( oSettings )
		{
			if ( !oSettings.oFeatures.bStateSave || typeof oSettings.bDestroying != 'undefined' )
			{
				return;
			}
			
			/* Store the interesting variables */
			var i, iLen, sTmp;
			var sValue = "{";
			sValue += '"iCreate":'+ new Date().getTime()+',';
			sValue += '"iStart":'+ oSettings._iDisplayStart+',';
			sValue += '"iEnd":'+ oSettings._iDisplayEnd+',';
			sValue += '"iLength":'+ oSettings._iDisplayLength+',';
			sValue += '"sFilter":"'+ encodeURIComponent(oSettings.oPreviousSearch.sSearch)+'",';
			sValue += '"sFilterEsc":'+ !oSettings.oPreviousSearch.bRegex+',';
			
			sValue += '"aaSorting":[ ';
			for ( i=0 ; i<oSettings.aaSorting.length ; i++ )
			{
				sValue += '['+oSettings.aaSorting[i][0]+',"'+oSettings.aaSorting[i][1]+'"],';
			}
			sValue = sValue.substring(0, sValue.length-1);
			sValue += "],";
			
			sValue += '"aaSearchCols":[ ';
			for ( i=0 ; i<oSettings.aoPreSearchCols.length ; i++ )
			{
				sValue += '["'+encodeURIComponent(oSettings.aoPreSearchCols[i].sSearch)+
					'",'+!oSettings.aoPreSearchCols[i].bRegex+'],';
			}
			sValue = sValue.substring(0, sValue.length-1);
			sValue += "],";
			
			sValue += '"abVisCols":[ ';
			for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
			{
				sValue += oSettings.aoColumns[i].bVisible+",";
			}
			sValue = sValue.substring(0, sValue.length-1);
			sValue += "]";
			
			/* Save state from any plug-ins */
			for ( i=0, iLen=oSettings.aoStateSave.length ; i<iLen ; i++ )
			{
				sTmp = oSettings.aoStateSave[i].fn( oSettings, sValue );
				if ( sTmp !== "" )
				{
					sValue = sTmp;
				}
			}
			
			sValue += "}";
			
			_fnCreateCookie( oSettings.sCookiePrefix+oSettings.sInstance, sValue, 
				oSettings.iCookieDuration, oSettings.sCookiePrefix, oSettings.fnCookieCallback );
		}
		
		/*
		 * Function: _fnLoadState
		 * Purpose:  Attempt to load a saved table state from a cookie
		 * Returns:  -
		 * Inputs:   object:oSettings - dataTables settings object
		 *           object:oInit - DataTables init object so we can override settings
		 */
		function _fnLoadState ( oSettings, oInit )
		{
			if ( !oSettings.oFeatures.bStateSave )
			{
				return;
			}
			
			var oData, i, iLen;
			var sData = _fnReadCookie( oSettings.sCookiePrefix+oSettings.sInstance );
			if ( sData !== null && sData !== '' )
			{
				/* Try/catch the JSON eval - if it is bad then we ignore it - note that 1.7.0 and before
				 * incorrectly used single quotes for some strings - hence the replace below
				 */
				try
				{
					oData = (typeof $.parseJSON == 'function') ? 
						$.parseJSON( sData.replace(/'/g, '"') ) : eval( '('+sData+')' );
				}
				catch( e )
				{
					return;
				}
				
				/* Allow custom and plug-in manipulation functions to alter the data set which was
				 * saved, and also reject any saved state by returning false
				 */
				for ( i=0, iLen=oSettings.aoStateLoad.length ; i<iLen ; i++ )
				{
					if ( !oSettings.aoStateLoad[i].fn( oSettings, oData ) )
					{
						return;
					}
				}
				
				/* Store the saved state so it might be accessed at any time (particualrly a plug-in */
				oSettings.oLoadedState = $.extend( true, {}, oData );
				
				/* Restore key features */
				oSettings._iDisplayStart = oData.iStart;
				oSettings.iInitDisplayStart = oData.iStart;
				oSettings._iDisplayEnd = oData.iEnd;
				oSettings._iDisplayLength = oData.iLength;
				oSettings.oPreviousSearch.sSearch = decodeURIComponent(oData.sFilter);
				oSettings.aaSorting = oData.aaSorting.slice();
				oSettings.saved_aaSorting = oData.aaSorting.slice();
				
				/*
				 * Search filtering - global reference added in 1.4.1
				 * Note that we use a 'not' for the value of the regular expression indicator to maintain
				 * compatibility with pre 1.7 versions, where this was basically inverted. Added in 1.7.0
				 */
				if ( typeof oData.sFilterEsc != 'undefined' )
				{
					oSettings.oPreviousSearch.bRegex = !oData.sFilterEsc;
				}
				
				/* Column filtering - added in 1.5.0 beta 6 */
				if ( typeof oData.aaSearchCols != 'undefined' )
				{
					for ( i=0 ; i<oData.aaSearchCols.length ; i++ )
					{
						oSettings.aoPreSearchCols[i] = {
							"sSearch": decodeURIComponent(oData.aaSearchCols[i][0]),
							"bRegex": !oData.aaSearchCols[i][1]
						};
					}
				}
				
				/* Column visibility state - added in 1.5.0 beta 10 */
				if ( typeof oData.abVisCols != 'undefined' )
				{
					/* Pass back visibiliy settings to the init handler, but to do not here override
					 * the init object that the user might have passed in
					 */
					oInit.saved_aoColumns = [];
					for ( i=0 ; i<oData.abVisCols.length ; i++ )
					{
						oInit.saved_aoColumns[i] = {};
						oInit.saved_aoColumns[i].bVisible = oData.abVisCols[i];
					}
				}
			}
		}
		
		/*
		 * Function: _fnCreateCookie
		 * Purpose:  Create a new cookie with a value to store the state of a table
		 * Returns:  -
		 * Inputs:   string:sName - name of the cookie to create
		 *           string:sValue - the value the cookie should take
		 *           int:iSecs - duration of the cookie
		 *           string:sBaseName - sName is made up of the base + file name - this is the base
		 *           function:fnCallback - User definable function to modify the cookie
		 */
		function _fnCreateCookie ( sName, sValue, iSecs, sBaseName, fnCallback )
		{
			var date = new Date();
			date.setTime( date.getTime()+(iSecs*1000) );
			
			/* 
			 * Shocking but true - it would appear IE has major issues with having the path not having
			 * a trailing slash on it. We need the cookie to be available based on the path, so we
			 * have to append the file name to the cookie name. Appalling. Thanks to vex for adding the
			 * patch to use at least some of the path
			 */
			var aParts = window.location.pathname.split('/');
			var sNameFile = sName + '_' + aParts.pop().replace(/[\/:]/g,"").toLowerCase();
			var sFullCookie, oData;
			
			if ( fnCallback !== null )
			{
				oData = (typeof $.parseJSON == 'function') ? 
					$.parseJSON( sValue ) : eval( '('+sValue+')' );
				sFullCookie = fnCallback( sNameFile, oData, date.toGMTString(),
					aParts.join('/')+"/" );
			}
			else
			{
				sFullCookie = sNameFile + "=" + encodeURIComponent(sValue) +
					"; expires=" + date.toGMTString() +"; path=" + aParts.join('/')+"/";
			}
			
			/* Are we going to go over the cookie limit of 4KiB? If so, try to delete a cookies
			 * belonging to DataTables. This is FAR from bullet proof
			 */
			var sOldName="", iOldTime=9999999999999;
			var iLength = _fnReadCookie( sNameFile )!==null ? document.cookie.length : 
				sFullCookie.length + document.cookie.length;
			
			if ( iLength+10 > 4096 ) /* Magic 10 for padding */
			{
				var aCookies =document.cookie.split(';');
				for ( var i=0, iLen=aCookies.length ; i<iLen ; i++ )
				{
					if ( aCookies[i].indexOf( sBaseName ) != -1 )
					{
						/* It's a DataTables cookie, so eval it and check the time stamp */
						var aSplitCookie = aCookies[i].split('=');
						try { oData = eval( '('+decodeURIComponent(aSplitCookie[1])+')' ); }
						catch( e ) { continue; }
						
						if ( typeof oData.iCreate != 'undefined' && oData.iCreate < iOldTime )
						{
							sOldName = aSplitCookie[0];
							iOldTime = oData.iCreate;
						}
					}
				}
				
				if ( sOldName !== "" )
				{
					document.cookie = sOldName+"=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path="+
						aParts.join('/') + "/";
				}
			}
			
			document.cookie = sFullCookie;
		}
		
		/*
		 * Function: _fnReadCookie
		 * Purpose:  Read an old cookie to get a cookie with an old table state
		 * Returns:  string: - contents of the cookie - or null if no cookie with that name found
		 * Inputs:   string:sName - name of the cookie to read
		 */
		function _fnReadCookie ( sName )
		{
			var
				aParts = window.location.pathname.split('/'),
				sNameEQ = sName + '_' + aParts[aParts.length-1].replace(/[\/:]/g,"").toLowerCase() + '=',
			 	sCookieContents = document.cookie.split(';');
			
			for( var i=0 ; i<sCookieContents.length ; i++ )
			{
				var c = sCookieContents[i];
				
				while (c.charAt(0)==' ')
				{
					c = c.substring(1,c.length);
				}
				
				if (c.indexOf(sNameEQ) === 0)
				{
					return decodeURIComponent( c.substring(sNameEQ.length,c.length) );
				}
			}
			return null;
		}
		
		/*
		 * Function: _fnGetUniqueThs
		 * Purpose:  Get an array of unique th elements, one for each column
		 * Returns:  array node:aReturn - list of unique ths
		 * Inputs:   node:nThead - The thead element for the table
		 */
		function _fnGetUniqueThs ( nThead )
		{
			var nTrs = nThead.getElementsByTagName('tr');
			
			/* Nice simple case */
			if ( nTrs.length == 1 )
			{
				return nTrs[0].getElementsByTagName('th');
			}
			
			/* Otherwise we need to figure out the layout array to get the nodes */
			var aLayout = [], aReturn = [];
			var ROWSPAN = 2, COLSPAN = 3, TDELEM = 4;
			var i, j, k, iLen, jLen, iColumnShifted;
			var fnShiftCol = function ( a, i, j ) {
				while ( typeof a[i][j] != 'undefined' ) {
					j++;
				}
				return j;
			};
			var fnAddRow = function ( i ) {
				if ( typeof aLayout[i] == 'undefined' ) {
					aLayout[i] = [];
				}
			};
			
			/* Calculate a layout array */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				fnAddRow( i );
				var iColumn = 0;
				var nTds = [];
				
				for ( j=0, jLen=nTrs[i].childNodes.length ; j<jLen ; j++ )
				{
					if ( nTrs[i].childNodes[j].nodeName.toUpperCase() == "TD" ||
					     nTrs[i].childNodes[j].nodeName.toUpperCase() == "TH" )
					{
						nTds.push( nTrs[i].childNodes[j] );
					}
				}
				
				for ( j=0, jLen=nTds.length ; j<jLen ; j++ )
				{
					var iColspan = nTds[j].getAttribute('colspan') * 1;
					var iRowspan = nTds[j].getAttribute('rowspan') * 1;
					
					if ( !iColspan || iColspan===0 || iColspan===1 )
					{
						iColumnShifted = fnShiftCol( aLayout, i, iColumn );
						aLayout[i][iColumnShifted] = (nTds[j].nodeName.toUpperCase()=="TD") ? TDELEM : nTds[j];
						if ( iRowspan || iRowspan===0 || iRowspan===1 )
						{
							for ( k=1 ; k<iRowspan ; k++ )
							{
								fnAddRow( i+k );
								aLayout[i+k][iColumnShifted] = ROWSPAN;
							}
						}
						iColumn++;
					}
					else
					{
						iColumnShifted = fnShiftCol( aLayout, i, iColumn );
						for ( k=0 ; k<iColspan ; k++ )
						{
							aLayout[i][iColumnShifted+k] = COLSPAN;
						}
						iColumn += iColspan;
					}
				}
			}
			
			/* Convert the layout array into a node array */
			for ( i=0, iLen=aLayout.length ; i<iLen ; i++ )
			{
				for ( j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
				{
					if ( typeof aLayout[i][j] == 'object' )
					{
						aReturn[j] = aLayout[i][j];
					}
				}
			}
			
			return aReturn;
		}
		
		/*
		 * Function: _fnScrollBarWidth
		 * Purpose:  Get the width of a scroll bar in this browser being used
		 * Returns:  int: - width in pixels
		 * Inputs:   -
		 * Notes:    All credit for this function belongs to Alexandre Gomes. Thanks for sharing!
		 *   http://www.alexandre-gomes.com/?p=115
		 */
		function _fnScrollBarWidth ()
		{  
			var inner = document.createElement('p');  
			var style = inner.style;
			style.width = "100%";  
			style.height = "200px";  
			
			var outer = document.createElement('div');  
			style = outer.style;
			style.position = "absolute";  
			style.top = "0px";  
			style.left = "0px";  
			style.visibility = "hidden";  
			style.width = "200px";  
			style.height = "150px";  
			style.overflow = "hidden";  
			outer.appendChild(inner);  
			
			document.body.appendChild(outer);  
			var w1 = inner.offsetWidth;  
			outer.style.overflow = 'scroll';  
			var w2 = inner.offsetWidth;  
			if ( w1 == w2 )
			{
				w2 = outer.clientWidth;  
			}
			
			document.body.removeChild(outer); 
			return (w1 - w2);  
		}
		
		/*
		 * Function: _fnApplyToChildren
		 * Purpose:  Apply a given function to the display child nodes of an element array (typically
		 *   TD children of TR rows
		 * Returns:  - (done by reference)
		 * Inputs:   function:fn - Method to apply to the objects
		 *           array nodes:an1 - List of elements to look through for display children
		 *           array nodes:an2 - Another list (identical structure to the first) - optional
		 */
		function _fnApplyToChildren( fn, an1, an2 )
		{
			for ( var i=0, iLen=an1.length ; i<iLen ; i++ )
			{
				for ( var j=0, jLen=an1[i].childNodes.length ; j<jLen ; j++ )
				{
					if ( an1[i].childNodes[j].nodeType == 1 )
					{
						if ( typeof an2 != 'undefined' )
						{
							fn( an1[i].childNodes[j], an2[i].childNodes[j] );
						}
						else
						{
							fn( an1[i].childNodes[j] );
						}
					}
				}
			}
		}
		
		/*
		 * Function: _fnMap
		 * Purpose:  See if a property is defined on one object, if so assign it to the other object
		 * Returns:  - (done by reference)
		 * Inputs:   object:oRet - target object
		 *           object:oSrc - source object
		 *           string:sName - property
		 *           string:sMappedName - name to map too - optional, sName used if not given
		 */
		function _fnMap( oRet, oSrc, sName, sMappedName )
		{
			if ( typeof sMappedName == 'undefined' )
			{
				sMappedName = sName;
			}
			if ( typeof oSrc[sName] != 'undefined' )
			{
				oRet[sMappedName] = oSrc[sName];
			}
		}
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - API
		 * 
		 * I'm not overly happy with this solution - I'd much rather that there was a way of getting
		 * a list of all the private functions and do what we need to dynamically - but that doesn't
		 * appear to be possible. Bonkers. A better solution would be to provide a 'bind' type object
		 * To do - bind type method in DTs 2.x.
		 */
		this.oApi._fnExternApiFunc = _fnExternApiFunc;
		this.oApi._fnInitalise = _fnInitalise;
		this.oApi._fnLanguageProcess = _fnLanguageProcess;
		this.oApi._fnAddColumn = _fnAddColumn;
		this.oApi._fnColumnOptions = _fnColumnOptions;
		this.oApi._fnAddData = _fnAddData;
		this.oApi._fnGatherData = _fnGatherData;
		this.oApi._fnDrawHead = _fnDrawHead;
		this.oApi._fnDraw = _fnDraw;
		this.oApi._fnReDraw = _fnReDraw;
		this.oApi._fnAjaxUpdate = _fnAjaxUpdate;
		this.oApi._fnAjaxUpdateDraw = _fnAjaxUpdateDraw;
		this.oApi._fnAddOptionsHtml = _fnAddOptionsHtml;
		this.oApi._fnFeatureHtmlTable = _fnFeatureHtmlTable;
		this.oApi._fnScrollDraw = _fnScrollDraw;
		this.oApi._fnAjustColumnSizing = _fnAjustColumnSizing;
		this.oApi._fnFeatureHtmlFilter = _fnFeatureHtmlFilter;
		this.oApi._fnFilterComplete = _fnFilterComplete;
		this.oApi._fnFilterCustom = _fnFilterCustom;
		this.oApi._fnFilterColumn = _fnFilterColumn;
		this.oApi._fnFilter = _fnFilter;
		this.oApi._fnBuildSearchArray = _fnBuildSearchArray;
		this.oApi._fnBuildSearchRow = _fnBuildSearchRow;
		this.oApi._fnFilterCreateSearch = _fnFilterCreateSearch;
		this.oApi._fnDataToSearch = _fnDataToSearch;
		this.oApi._fnSort = _fnSort;
		this.oApi._fnSortAttachListener = _fnSortAttachListener;
		this.oApi._fnSortingClasses = _fnSortingClasses;
		this.oApi._fnFeatureHtmlPaginate = _fnFeatureHtmlPaginate;
		this.oApi._fnPageChange = _fnPageChange;
		this.oApi._fnFeatureHtmlInfo = _fnFeatureHtmlInfo;
		this.oApi._fnUpdateInfo = _fnUpdateInfo;
		this.oApi._fnFeatureHtmlLength = _fnFeatureHtmlLength;
		this.oApi._fnFeatureHtmlProcessing = _fnFeatureHtmlProcessing;
		this.oApi._fnProcessingDisplay = _fnProcessingDisplay;
		this.oApi._fnVisibleToColumnIndex = _fnVisibleToColumnIndex;
		this.oApi._fnColumnIndexToVisible = _fnColumnIndexToVisible;
		this.oApi._fnNodeToDataIndex = _fnNodeToDataIndex;
		this.oApi._fnVisbleColumns = _fnVisbleColumns;
		this.oApi._fnCalculateEnd = _fnCalculateEnd;
		this.oApi._fnConvertToWidth = _fnConvertToWidth;
		this.oApi._fnCalculateColumnWidths = _fnCalculateColumnWidths;
		this.oApi._fnScrollingWidthAdjust = _fnScrollingWidthAdjust;
		this.oApi._fnGetWidestNode = _fnGetWidestNode;
		this.oApi._fnGetMaxLenString = _fnGetMaxLenString;
		this.oApi._fnStringToCss = _fnStringToCss;
		this.oApi._fnArrayCmp = _fnArrayCmp;
		this.oApi._fnDetectType = _fnDetectType;
		this.oApi._fnSettingsFromNode = _fnSettingsFromNode;
		this.oApi._fnGetDataMaster = _fnGetDataMaster;
		this.oApi._fnGetTrNodes = _fnGetTrNodes;
		this.oApi._fnGetTdNodes = _fnGetTdNodes;
		this.oApi._fnEscapeRegex = _fnEscapeRegex;
		this.oApi._fnDeleteIndex = _fnDeleteIndex;
		this.oApi._fnReOrderIndex = _fnReOrderIndex;
		this.oApi._fnColumnOrdering = _fnColumnOrdering;
		this.oApi._fnLog = _fnLog;
		this.oApi._fnClearTable = _fnClearTable;
		this.oApi._fnSaveState = _fnSaveState;
		this.oApi._fnLoadState = _fnLoadState;
		this.oApi._fnCreateCookie = _fnCreateCookie;
		this.oApi._fnReadCookie = _fnReadCookie;
		this.oApi._fnGetUniqueThs = _fnGetUniqueThs;
		this.oApi._fnScrollBarWidth = _fnScrollBarWidth;
		this.oApi._fnApplyToChildren = _fnApplyToChildren;
		this.oApi._fnMap = _fnMap;
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Section - Constructor
		 */
		
		/* Want to be able to reference "this" inside the this.each function */
		var _that = this;
		return this.each(function()
		{
			var i=0, iLen, j, jLen, k, kLen;
			
			/* Check to see if we are re-initalising a table */
			for ( i=0, iLen=_aoSettings.length ; i<iLen ; i++ )
			{
				/* Base check on table node */
				if ( _aoSettings[i].nTable == this )
				{
					if ( typeof oInit == 'undefined' || 
					   ( typeof oInit.bRetrieve != 'undefined' && oInit.bRetrieve === true ) )
					{
						return _aoSettings[i].oInstance;
					}
					else if ( typeof oInit.bDestroy != 'undefined' && oInit.bDestroy === true )
					{
						_aoSettings[i].oInstance.fnDestroy();
						break;
					}
					else
					{
						_fnLog( _aoSettings[i], 0, "Cannot reinitialise DataTable.\n\n"+
							"To retrieve the DataTables object for this table, please pass either no arguments "+
							"to the dataTable() function, or set bRetrieve to true. Alternatively, to destory "+
							"the old table and create a new one, set bDestroy to true (note that a lot of "+
							"changes to the configuration can be made through the API which is usually much "+
							"faster)." );
						return;
					}
				}
				
				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destory the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if ( _aoSettings[i].sTableId !== "" && _aoSettings[i].sTableId == this.getAttribute('id') )
				{
					_aoSettings.splice( i, 1 );
					break;
				}
			}
			
			/* Make a complete and independent copy of the settings object */
			var oSettings = new classSettings();
			_aoSettings.push( oSettings );
			
			var bInitHandedOff = false;
			var bUsePassedData = false;
			
			/* Set the id */
			var sId = this.getAttribute( 'id' );
			if ( sId !== null )
			{
				oSettings.sTableId = sId;
				oSettings.sInstance = sId;
			}
			else
			{
				oSettings.sInstance = _oExt._oExternConfig.iNextUnique ++;
			}
			
			/* Sanity check */
			if ( this.nodeName.toLowerCase() != 'table' )
			{
				_fnLog( oSettings, 0, "Attempted to initialise DataTables on a node which is not a "+
					"table: "+this.nodeName );
				return;
			}
			
			/* Store 'this' in the settings object for later retrieval */
			oSettings.oInstance = _that;
			
			/* Set the table node */
			oSettings.nTable = this;
			
			/* Bind the API functions to the settings, so we can perform actions whenever oSettings is
			 * available
			 */
			oSettings.oApi = _that.oApi;
			
			/* State the table's width for if a destroy is called at a later time */
			oSettings.sDestroyWidth = $(this).width();
			
			/* Store the features that we have available */
			if ( typeof oInit != 'undefined' && oInit !== null )
			{
				oSettings.oInit = oInit;
				_fnMap( oSettings.oFeatures, oInit, "bPaginate" );
				_fnMap( oSettings.oFeatures, oInit, "bLengthChange" );
				_fnMap( oSettings.oFeatures, oInit, "bFilter" );
				_fnMap( oSettings.oFeatures, oInit, "bSort" );
				_fnMap( oSettings.oFeatures, oInit, "bInfo" );
				_fnMap( oSettings.oFeatures, oInit, "bProcessing" );
				_fnMap( oSettings.oFeatures, oInit, "bAutoWidth" );
				_fnMap( oSettings.oFeatures, oInit, "bSortClasses" );
				_fnMap( oSettings.oFeatures, oInit, "bServerSide" );
				_fnMap( oSettings.oScroll, oInit, "sScrollX", "sX" );
				_fnMap( oSettings.oScroll, oInit, "sScrollXInner", "sXInner" );
				_fnMap( oSettings.oScroll, oInit, "sScrollY", "sY" );
				_fnMap( oSettings.oScroll, oInit, "bScrollCollapse", "bCollapse" );
				_fnMap( oSettings.oScroll, oInit, "bScrollInfinite", "bInfinite" );
				_fnMap( oSettings.oScroll, oInit, "iScrollLoadGap", "iLoadGap" );
				_fnMap( oSettings, oInit, "asStripClasses" );
				_fnMap( oSettings, oInit, "fnRowCallback" );
				_fnMap( oSettings, oInit, "fnHeaderCallback" );
				_fnMap( oSettings, oInit, "fnFooterCallback" );
				_fnMap( oSettings, oInit, "fnCookieCallback" );
				_fnMap( oSettings, oInit, "fnInitComplete" );
				_fnMap( oSettings, oInit, "fnServerData" );
				_fnMap( oSettings, oInit, "fnFormatNumber" );
				_fnMap( oSettings, oInit, "aaSorting" );
				_fnMap( oSettings, oInit, "aaSortingFixed" );
				_fnMap( oSettings, oInit, "aLengthMenu" );
				_fnMap( oSettings, oInit, "sPaginationType" );
				_fnMap( oSettings, oInit, "sAjaxSource" );
				_fnMap( oSettings, oInit, "iCookieDuration" );
				_fnMap( oSettings, oInit, "sCookiePrefix" );
				_fnMap( oSettings, oInit, "sDom" );
				_fnMap( oSettings, oInit, "oSearch", "oPreviousSearch" );
				_fnMap( oSettings, oInit, "aoSearchCols", "aoPreSearchCols" );
				_fnMap( oSettings, oInit, "iDisplayLength", "_iDisplayLength" );
				_fnMap( oSettings, oInit, "bJQueryUI", "bJUI" );
				_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
				
				/* Callback functions which are array driven */
				if ( typeof oInit.fnDrawCallback == 'function' )
				{
					oSettings.aoDrawCallback.push( {
						"fn": oInit.fnDrawCallback,
						"sName": "user"
					} );
				}
				
				if ( typeof oInit.fnStateSaveCallback == 'function' )
				{
					oSettings.aoStateSave.push( {
						"fn": oInit.fnStateSaveCallback,
						"sName": "user"
					} );
				}
				
				if ( typeof oInit.fnStateLoadCallback == 'function' )
				{
					oSettings.aoStateLoad.push( {
						"fn": oInit.fnStateLoadCallback,
						"sName": "user"
					} );
				}
				
				if ( oSettings.oFeatures.bServerSide && oSettings.oFeatures.bSort &&
					   oSettings.oFeatures.bSortClasses )
				{
					/* Enable sort classes for server-side processing. Safe to do it here, since server-side
					 * processing must be enabled by the developer
					 */
					oSettings.aoDrawCallback.push( {
						"fn": _fnSortingClasses,
						"sName": "server_side_sort_classes"
					} );
				}
				
				if ( typeof oInit.bJQueryUI != 'undefined' && oInit.bJQueryUI )
				{
					/* Use the JUI classes object for display. You could clone the oStdClasses object if 
					 * you want to have multiple tables with multiple independent classes 
					 */
					oSettings.oClasses = _oExt.oJUIClasses;
					
					if ( typeof oInit.sDom == 'undefined' )
					{
						/* Set the DOM to use a layout suitable for jQuery UI's theming */
						oSettings.sDom = '<"H"lfr>t<"F"ip>';
					}
				}
				
				/* Calculate the scroll bar width and cache it for use later on */
				if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
				{
					oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
				}
				
				if ( typeof oInit.iDisplayStart != 'undefined' && 
				     typeof oSettings.iInitDisplayStart == 'undefined' )
				{
					/* Display start point, taking into account the save saving */
					oSettings.iInitDisplayStart = oInit.iDisplayStart;
					oSettings._iDisplayStart = oInit.iDisplayStart;
				}
				
				/* Must be done after everything which can be overridden by a cookie! */
				if ( typeof oInit.bStateSave != 'undefined' )
				{
					oSettings.oFeatures.bStateSave = oInit.bStateSave;
					_fnLoadState( oSettings, oInit );
					oSettings.aoDrawCallback.push( {
						"fn": _fnSaveState,
						"sName": "state_save"
					} );
				}
				
				if ( typeof oInit.aaData != 'undefined' )
				{
					bUsePassedData = true;
				}
				
				/* Backwards compatability */
				/* aoColumns / aoData - remove at some point... */
				if ( typeof oInit != 'undefined' && typeof oInit.aoData != 'undefined' )
				{
					oInit.aoColumns = oInit.aoData;
				}
				
				/* Language definitions */
				if ( typeof oInit.oLanguage != 'undefined' )
				{
					if ( typeof oInit.oLanguage.sUrl != 'undefined' && oInit.oLanguage.sUrl !== "" )
					{
						/* Get the language definitions from a file */
						oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
						$.getJSON( oSettings.oLanguage.sUrl, null, function( json ) { 
							_fnLanguageProcess( oSettings, json, true ); } );
						bInitHandedOff = true;
					}
					else
					{
						_fnLanguageProcess( oSettings, oInit.oLanguage, false );
					}
				}
				/* Warning: The _fnLanguageProcess function is async to the remainder of this function due
				 * to the XHR. We use _bInitialised in _fnLanguageProcess() to check this the processing 
				 * below is complete. The reason for spliting it like this is optimisation - we can fire
				 * off the XHR (if needed) and then continue processing the data.
				 */
			}
			else
			{
				/* Create a dummy object for quick manipulation later on. */
				oInit = {};
			}
			
			/*
			 * Stripes
			 * Add the strip classes now that we know which classes to apply - unless overruled
			 */
			if ( typeof oInit.asStripClasses == 'undefined' )
			{
				oSettings.asStripClasses.push( oSettings.oClasses.sStripOdd );
				oSettings.asStripClasses.push( oSettings.oClasses.sStripEven );
			}
			
			/* Remove row stripe classes if they are already on the table row */
			var bStripeRemove = false;
			var anRows = $('tbody>tr', this);
			for ( i=0, iLen=oSettings.asStripClasses.length ; i<iLen ; i++ )
			{
				if ( anRows.filter(":lt(2)").hasClass( oSettings.asStripClasses[i]) )
				{
					bStripeRemove = true;
					break;
				}
			}
					
			if ( bStripeRemove )
			{
				/* Store the classes which we are about to remove so they can be readded on destory */
				oSettings.asDestoryStrips = [ '', '' ];
				if ( $(anRows[0]).hasClass(oSettings.oClasses.sStripOdd) )
				{
					oSettings.asDestoryStrips[0] += oSettings.oClasses.sStripOdd+" ";
				}
				if ( $(anRows[0]).hasClass(oSettings.oClasses.sStripEven) )
				{
					oSettings.asDestoryStrips[0] += oSettings.oClasses.sStripEven;
				}
				if ( $(anRows[1]).hasClass(oSettings.oClasses.sStripOdd) )
				{
					oSettings.asDestoryStrips[1] += oSettings.oClasses.sStripOdd+" ";
				}
				if ( $(anRows[1]).hasClass(oSettings.oClasses.sStripEven) )
				{
					oSettings.asDestoryStrips[1] += oSettings.oClasses.sStripEven;
				}
				
				anRows.removeClass( oSettings.asStripClasses.join(' ') );
			}
			
			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var nThead = this.getElementsByTagName('thead');
			var anThs = nThead.length===0 ? [] : _fnGetUniqueThs( nThead[0] );
			var aoColumnsInit;
			
			/* If not given a column array, generate one with nulls */
			if ( typeof oInit.aoColumns == 'undefined' )
			{
				aoColumnsInit = [];
				for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
				{
					aoColumnsInit.push( null );
				}
			}
			else
			{
				aoColumnsInit = oInit.aoColumns;
			}
			
			/* Add the columns */
			for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
			{
				/* Check if we have column visibilty state to restore */
				if ( typeof oInit.saved_aoColumns != 'undefined' && oInit.saved_aoColumns.length == iLen )
				{
					if ( aoColumnsInit[i] === null )
					{
						aoColumnsInit[i] = {};
					}
					aoColumnsInit[i].bVisible = oInit.saved_aoColumns[i].bVisible;
				}
				
				_fnAddColumn( oSettings, anThs ? anThs[i] : null );
			}
			
			/* Add options from column definations */
			if ( typeof oInit.aoColumnDefs != 'undefined' )
			{
				/* Loop over the column defs array - loop in reverse so first instace has priority */
				for ( i=oInit.aoColumnDefs.length-1 ; i>=0 ; i-- )
				{
					/* Each column def can target multiple columns, as it is an array */
					var aTargets = oInit.aoColumnDefs[i].aTargets;
					if ( !$.isArray( aTargets ) )
					{
						_fnLog( oSettings, 1, 'aTargets must be an array of targets, not a '+(typeof aTargets) );
					}
					for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
					{
						if ( typeof aTargets[j] == 'number' && aTargets[j] >= 0 )
						{
							/* 0+ integer, left to right column counting. We add columns which are unknown
							 * automatically. Is this the right behaviour for this? We should at least
							 * log it in future. We cannot do this for the negative or class targets, only here.
							 */
							while( oSettings.aoColumns.length <= aTargets[j] )
							{
								_fnAddColumn( oSettings );
							}
							_fnColumnOptions( oSettings, aTargets[j], oInit.aoColumnDefs[i] );
						}
						else if ( typeof aTargets[j] == 'number' && aTargets[j] < 0 )
						{
							/* Negative integer, right to left column counting */
							_fnColumnOptions( oSettings, oSettings.aoColumns.length+aTargets[j], 
								oInit.aoColumnDefs[i] );
						}
						else if ( typeof aTargets[j] == 'string' )
						{
							/* Class name matching on TH element */
							for ( k=0, kLen=oSettings.aoColumns.length ; k<kLen ; k++ )
							{
								if ( aTargets[j] == "_all" ||
								     oSettings.aoColumns[k].nTh.className.indexOf( aTargets[j] ) != -1 )
								{
									_fnColumnOptions( oSettings, k, oInit.aoColumnDefs[i] );
								}
							}
						}
					}
				}
			}
			
			/* Add options from column array - after the defs array so this has priority */
			if ( typeof aoColumnsInit != 'undefined' )
			{
				for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
				{
					_fnColumnOptions( oSettings, i, aoColumnsInit[i] );
				}
			}
			
			/*
			 * Sorting
			 * Check the aaSorting array
			 */
			for ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )
			{
				if ( oSettings.aaSorting[i][0] >= oSettings.aoColumns.length )
				{
					oSettings.aaSorting[i][0] = 0;
				}
				var oColumn = oSettings.aoColumns[ oSettings.aaSorting[i][0] ];
				
				/* Add a default sorting index */
				if ( typeof oSettings.aaSorting[i][2] == 'undefined' )
				{
					oSettings.aaSorting[i][2] = 0;
				}
				
				/* If aaSorting is not defined, then we use the first indicator in asSorting */
				if ( typeof oInit.aaSorting == "undefined" && 
						 typeof oSettings.saved_aaSorting == "undefined" )
				{
					oSettings.aaSorting[i][1] = oColumn.asSorting[0];
				}
				
				/* Set the current sorting index based on aoColumns.asSorting */
				for ( j=0, jLen=oColumn.asSorting.length ; j<jLen ; j++ )
				{
					if ( oSettings.aaSorting[i][1] == oColumn.asSorting[j] )
					{
						oSettings.aaSorting[i][2] = j;
						break;
					}
				}
			}
				
			/* Do a first pass on the sorting classes (allows any size changes to be taken into
			 * account, and also will apply sorting disabled classes if disabled
			 */
			_fnSortingClasses( oSettings );
			
			/*
			 * Final init
			 * Sanity check that there is a thead and tbody. If not let's just create them
			 */
			if ( this.getElementsByTagName('thead').length === 0 )
			{
				this.appendChild( document.createElement( 'thead' ) );
			}
			
			if ( this.getElementsByTagName('tbody').length === 0 )
			{
				this.appendChild( document.createElement( 'tbody' ) );
			}
			
			oSettings.nTHead = this.getElementsByTagName('thead')[0];
			oSettings.nTBody = this.getElementsByTagName('tbody')[0];
			if ( this.getElementsByTagName('tfoot').length > 0 )
			{
				oSettings.nTFoot = this.getElementsByTagName('tfoot')[0];
			}
			
			/* Check if there is data passing into the constructor */
			if ( bUsePassedData )
			{
				for ( i=0 ; i<oInit.aaData.length ; i++ )
				{
					_fnAddData( oSettings, oInit.aaData[ i ] );
				}
			}
			else
			{
				/* Grab the data from the page */
				_fnGatherData( oSettings );
			}
			
			/* Copy the data index array */
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
			/* Initialisation complete - table can be drawn */
			oSettings.bInitialised = true;
			
			/* Check if we need to initialise the table (it might not have been handed off to the
			 * language processor)
			 */
			if ( bInitHandedOff === false )
			{
				_fnInitalise( oSettings );
			}
		});
	};
})(jQuery, window, document);
; /* ************************ new file ************************ */
/*==================================================
 *  String Utility Functions and Constants
 *==================================================
 */

String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, '');
};

String.prototype.startsWith = function(prefix) {
    return this.length >= prefix.length && this.substr(0, prefix.length) == prefix;
};

String.prototype.endsWith = function(suffix) {
    return this.length >= suffix.length && this.substr(this.length - suffix.length) == suffix;
};

String.substitute = function(s, objects) {
    var result = "";
    var start = 0;
    while (start < s.length - 1) {
        var percent = s.indexOf("%", start);
        if (percent < 0 || percent == s.length - 1) {
            break;
        } else if (percent > start && s.charAt(percent - 1) == "\\") {
            result += s.substring(start, percent - 1) + "%";
            start = percent + 1;
        } else {
            var n = parseInt(s.charAt(percent + 1));
            if (isNaN(n) || n >= objects.length) {
                result += s.substring(start, percent + 2);
            } else {
                result += s.substring(start, percent) + objects[n].toString();
            }
            start = percent + 2;
        }
    }
    
    if (start < s.length) {
        result += s.substring(start);
    }
    return result;
};
; /* ************************ new file ************************ */
/*
	Base.js, version 1.1a
	Copyright 2006-2010, Dean Edwards
	License: http://www.opensource.org/licenses/mit-license.php
*/

var Base = function() {
	// dummy
};

Base.extend = function(_instance, _static) { // subclass
	var extend = Base.prototype.extend;

	// build the prototype
	Base._prototyping = true;
	var proto = new this;
	extend.call(proto, _instance);
  proto.base = function() {
    // call this method from any other method to invoke that method's ancestor
  };
	delete Base._prototyping;

	// create the wrapper for the constructor function
	//var constructor = proto.constructor.valueOf(); //-dean
	var constructor = proto.constructor;
	var klass = proto.constructor = function() {
		if (!Base._prototyping) {
			if (this._constructing || this.constructor == klass) { // instantiation
				this._constructing = true;
				constructor.apply(this, arguments);
				delete this._constructing;
			} else if (arguments[0] != null) { // casting
				return (arguments[0].extend || extend).call(arguments[0], proto);
			}
		}
	};

	// build the class interface
	klass.ancestor = this;
	klass.extend = this.extend;
	klass.forEach = this.forEach;
	klass.implement = this.implement;
	klass.prototype = proto;
	klass.toString = this.toString;
	klass.valueOf = function(type) {
		//return (type == "object") ? klass : constructor; //-dean
		return (type == "object") ? klass : constructor.valueOf();
	};
	extend.call(klass, _static);
	// class initialisation
	if (typeof klass.init == "function") klass.init();
	return klass;
};

Base.prototype = {
	extend: function(source, value) {
		if (arguments.length > 1) { // extending with a name/value pair
			var ancestor = this[source];
			if (ancestor && (typeof value == "function") && // overriding a method?
				// the valueOf() comparison is to avoid circular references
				(!ancestor.valueOf || ancestor.valueOf() != value.valueOf()) &&
				/\bbase\b/.test(value)) {
				// get the underlying method
				var method = value.valueOf();
				// override
				value = function() {
					var previous = this.base || Base.prototype.base;
					this.base = ancestor;
					var returnValue = method.apply(this, arguments);
					this.base = previous;
					return returnValue;
				};
				// point to the underlying method
				value.valueOf = function(type) {
					return (type == "object") ? value : method;
				};
				value.toString = Base.toString;
			}
			this[source] = value;
		} else if (source) { // extending with an object literal
			var extend = Base.prototype.extend;
			// if this object has a customised extend method then use it
			if (!Base._prototyping && typeof this != "function") {
				extend = this.extend || extend;
			}
			var proto = {toSource: null};
			// do the "toString" and other methods manually
			var hidden = ["constructor", "toString", "valueOf"];
			// if we are prototyping then include the constructor
			var i = Base._prototyping ? 0 : 1;
			while (key = hidden[i++]) {
				if (source[key] != proto[key]) {
					extend.call(this, key, source[key]);

				}
			}
			// copy each of the source object's properties to this object
			for (var key in source) {
				if (!proto[key]) extend.call(this, key, source[key]);
			}
		}
		return this;
	}
};

// initialise
Base = Base.extend({
	constructor: function() {
		this.extend(arguments[0]);
	}
}, {
	ancestor: Object,
	version: "1.1",

	forEach: function(object, block, context) {
		for (var key in object) {
			if (this.prototype[key] === undefined) {
				block.call(context, object[key], key, object);
			}
		}
	},

	implement: function() {
		for (var i = 0; i < arguments.length; i++) {
			if (typeof arguments[i] == "function") {
				// if it's a function, call it
				arguments[i](this.prototype);
			} else {
				// add the interface using the extend method
				this.prototype.extend(arguments[i]);
			}
		}
		return this;
	},

	toString: function() {
		return String(this.valueOf());
	}
});
; /* ************************ new file ************************ */

 $.ajaxSetup({
    type: "POST",
    async: false,
    traditional: true,
    scriptCharset: "utf-8",
    contentType: "application/x-www-form-urlencoded;charset=UTF-8",

    dataFilter: function(data, dtype) {
        // just tagging date
        
        Dashboards.lastServerResponse = Date.now();
        return data;
    }
});

var pathArray = window.location.pathname.split( '/' );
var webAppPath;
if (!(typeof(CONTEXT_PATH) == 'undefined')){
    webAppPath = CONTEXT_PATH;
}
if(webAppPath == undefined){
    webAppPath = "/" + pathArray[1];
}

if(webAppPath.endsWith("/")) {
    webAppPath = webAppPath.substr(0, webAppPath.length-1);
}

var GB_ANIMATION = true;
var CDF_CHILDREN = 1;
var CDF_SELF = 2;
var ERROR_IMAGE = webAppPath + "/content/pentaho-cdf/resources/style/images/error.png";
var CDF_ERROR_DIV = 'cdfErrorDiv';


if($.blockUI){
    $.blockUI.defaults.fadeIn = 0;
    $.blockUI.defaults.message = '<div style="padding: 0px;"><img src="' + webAppPath + '/content/pentaho-cdf/resources/style/images/processing_transparent.gif" />';
    $.blockUI.defaults.css.left = '50%';
    $.blockUI.defaults.css.top = '40%';
    $.blockUI.defaults.css.marginLeft = '-16px';
    $.blockUI.defaults.css.width = '32px';
    $.blockUI.defaults.css.background = 'none';
    $.blockUI.defaults.overlayCSS = { backgroundColor: "#FFFFFF", opacity: 0.8, cursor: "wait"};
    $.blockUI.defaults.css.border = "none";
}



if (typeof $.SetImpromptuDefaults == 'function')
    $.SetImpromptuDefaults({
        prefix: 'colsJqi',
        show: 'slideDown'
    });

var Dashboards = {

    ERROR_CODES:{
        'QUERY_TIMEOUT' : {
            msg: "Query timeout reached"
        },
        "COMPONENT_ERROR" : {
            msg: "Error processing component"
        }
    },
    CDF_BASE_PATH: webAppPath + "/content/pentaho-cdf/",
    parameterModel: new Backbone.Model(),
    TRAFFIC_RED: webAppPath + "/content/pentaho-cdf/resources/style/images/traffic_red.png",
    TRAFFIC_YELLOW: webAppPath + "/content/pentaho-cdf/resources/style/images/traffic_yellow.png",
    TRAFFIC_GREEN: webAppPath + "/content/pentaho-cdf/resources/style/images/traffic_green.png",
    viewFlags: {
        UNUSED: "unused",
        UNBOUND: "unbound",
        VIEW: "view"
    },
    /* globalContext determines if components and params are retrieved
     * from the current window's object or from the Dashboards singleton
     */
    globalContext: true,
    escapeParameterValues : true,
    /* Used to control progress indicator for async mode */
    runningCalls: 0,
    components: [],
    /* Holds the dashboard parameters if globalContext = false */
    parameters: [],

    // Holder for context
    context:{},


    /*
     * Legacy dashboards don't have priority, so we'll assign a very low priority
     * to them.
     * */

    legacyPriority: -1000,

    /* Log lifecycle events? */
    logLifecycle: true,

    args: [],
    monthNames : ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],

    lastServerResponse: Date.now(),
    serverCheckResponseTimeout: 1800000, //ms, will be overridden at init
    /* Reference to current language code . Used in every place where jquery
     * plugins used in CDF hasm native internationalization support (ex: Datepicker)
     */
    i18nCurrentLanguageCode : null,
    i18nSupport : null  // Reference to i18n objects
};

_.extend(Dashboards, Backbone.Events);

// Log
Dashboards.log = function(m,type){
    if (typeof console != "undefined" ){
        if (type && console[type]) {
            console[type]("CDF: " + m);
        }else if (type === 'exception' &&
            !console.exception) {
            console.error(m.stack);
        }
        else {
            console.log("CDF: " + m);
        }
    }
};

Dashboards.error = function(m){
    this.log(m, 'error');
}


Dashboards.getWebAppPath = function (){
    return webAppPath
}

// REFRESH ENGINE begin

Dashboards.RefreshEngine = function(){// Manages periodic refresh of components

    var NO_REFRESH = 0;//currently no distinction between explicitly disabled or not set
    var refreshQueue = new Array();//component refresh queue
    var activeTimer = null;//timer for individual component refresh

    var globalRefreshPeriod = NO_REFRESH;
    var globalTimer = null;

    Dashboards.RefreshEngine.QueueItem = function() {
        return {
            nextRefresh : 0,
            component : null
        };
    };

    //set global refresh and (re)start interval
    var startGlobalRefresh = function(refreshPeriod){
        if (globalTimer != null) {
            clearInterval(globalTimer);
            globalTimer = null;
        }
        globalRefreshPeriod = (refreshPeriod >0)? refreshPeriod : NO_REFRESH;
        if(globalRefreshPeriod != NO_REFRESH){
            globalTimer = setInterval("Dashboards.refreshEngine.fireGlobalRefresh()",globalRefreshPeriod * 1000);//ToDo: cleaner way to call
        }
    };

    var clearFromQueue = function(component){
        for (var i = 0; i < refreshQueue.length; i++) {
            if (refreshQueue[i].component == component) {
                refreshQueue.splice(i,1);
                i--;
            }
        }
    };

    var clearQueue = function(){
        if(refreshQueue.length > 0) refreshQueue.splice(0,refreshQueue.length);
    };

    //binary search for elem's position in coll (nextRefresh asc order)
    var getSortedInsertPosition = function(coll, elem){
        var high = coll.length - 1;
        var low = 0;
        var mid;

        while (low <= high) {
            mid = parseInt((low + high) / 2)
            if (coll[mid].nextRefresh > elem.nextRefresh) {
                high = mid - 1;
            } else if (coll[mid].nextRefresh < elem.nextRefresh) {
                low = mid + 1;
            } else {//==
                return mid;
            }
        }
        return low;
    };
    var sortedInsert = function(rtArray,rtInfo){
        var pos = getSortedInsertPosition(rtArray,rtInfo);
        rtArray.splice(pos,0,rtInfo);
    };

    var stopTimer = function(){
        if (activeTimer != null) {
            clearTimeout(activeTimer);
            activeTimer = null;
        }
    };

    var restartTimer = function(){
        stopTimer();
        Dashboards.refreshEngine.fireRefresh();
    };

    var getCurrentTime = function (){
        var date = new Date();
        return date.getTime();
    };

    var isFirstInQueue = function(component){
        return refreshQueue.length > 0 && refreshQueue[0].component == component;
    };

    var refreshComponent = function(component){
        //if refresh period is too short, progress indicator will stay in user's face
        //    let(Dashboards.runningCalls = 0){
        Dashboards.update(component);
    //      Dashboards.runningCalls = 0;
    //      Dashboards.hideProgressIndicator()
    //    }
    };

    var insertInQueue = function(component){
        var time = getCurrentTime();
        // normalize invalid refresh
        if (!(component.refreshPeriod > 0)) {
            component.refreshPeriod = NO_REFRESH;
        }
        if (component.refreshPeriod != NO_REFRESH) {
            //get next refresh time for component
            var info = new Dashboards.RefreshEngine.QueueItem();
            info.nextRefresh = time + (component.refreshPeriod * 1000);
            info.component = component;
            sortedInsert(refreshQueue, info);
        }
    };
    return {

        //set a component's refresh period and clears it from the queue if there;
        //processComponent must be called to activate the refresh timer for the component
        registerComponent : function(component, refreshPeriod){
            if(!component) return false;

            component.refreshPeriod = (refreshPeriod > 0)? refreshPeriod : NO_REFRESH;
            var wasFirst =  isFirstInQueue(component);
            clearFromQueue(component);
            if(wasFirst) restartTimer();

            return true;
        },

        getRefreshPeriod : function(component){
            if(component && component.refreshPeriod > 0) return component.refreshPeriod;
            else return NO_REFRESH;
        },

        //sets next refresh for given component and inserts it in refreshQueue, restarts timer if needed
        processComponent : function(component){
            clearFromQueue(component);
            insertInQueue(component);
            if(isFirstInQueue(component)) restartTimer();
            return true;//dbg
        },

        //clears queue, sets next refresh for all components, restarts timer
        processComponents : function(){
            clearQueue();
            for(var i=0; i<Dashboards.components.length;i++){
                insertInQueue(Dashboards.components[i]);
            }
            restartTimer();
            return true;//dbg
        },

        //pop due items from queue, refresh components and set next timeout
        fireRefresh : function(){
            activeTimer = null;
            var currentTime = getCurrentTime();

            while(refreshQueue.length > 0 &&
                refreshQueue[0].nextRefresh <= currentTime){
                var info = refreshQueue.shift();//pop first
                //call update, which calls processComponent
                refreshComponent(info.component);
            }
            if(refreshQueue.length > 0){
                activeTimer = setTimeout("Dashboards.refreshEngine.fireRefresh()", refreshQueue[0].nextRefresh - currentTime );//ToDo: cleaner way to call
            //activeTimer = setTimeout(this.fireRefresh, refreshQueue[0].nextRefresh - currentTime );
            }
        },

        // called when a valid globalRefreshPeriod exists
        // updates all components without their own refresh period
        fireGlobalRefresh: function(){
            for(i=0;i<Dashboards.components.length;i++){
                var comp = Dashboards.components[i];
                if (!(comp.refreshPeriod > 0) //only update those without refresh
                    && comp.type != "select") { //and that are not pov widgets
                    refreshComponent(comp);
                }
            }
        },

        setGlobalRefresh : function(refreshPeriod){
            startGlobalRefresh(refreshPeriod);
        },

        getQueue : function(){
            return refreshQueue;
        }
    };
};

Dashboards.refreshEngine = new Dashboards.RefreshEngine();

//REFRESH ENGINE end

Dashboards.setGlobalContext = function(globalContext) {
    this.globalContext = globalContext;
};

Dashboards.showProgressIndicator = function() {
    this.blockUIwithDrag();
};

Dashboards.hideProgressIndicator = function() {
    $.unblockUI();
    this.showErrorTooltip();
};

Dashboards.resetRunningCalls = function(){
    this.runningCalls = 0;
    setTimeout(_.bind(function(){
        this.hideProgressIndicator();
    },this),10);
};

Dashboards.getRunningCalls = function (){
    return this.runningCalls;
};

Dashboards.incrementRunningCalls = function() {
    this.runningCalls++ ;
    this.showProgressIndicator();
//Dashboards.log("+Running calls incremented to: " + Dashboards.getRunningCalls());
};

Dashboards.decrementRunningCalls = function() {
    this.runningCalls-- ;
    //Dashboards.log("-Running calls decremented to: " + Dashboards.getRunningCalls());
    setTimeout(_.bind(function(){
        if(this.runningCalls<=0){
            this.hideProgressIndicator();
            this.runningCalls = 0; // Just in case
        }
    },this),10);
};

Dashboards.bindControl = function(control) {
    var Class = this._getControlClass(control);
    if(!Class) {
        this.log("Object type " + control["type"] + " can't be mapped to a valid class", "error");
    } else {
        this._castControlToClass(control, Class);
    }

    this.bindExistingControl(control, Class);
};

Dashboards.bindExistingControl = function(control, Class) {
    if(!control.dashboard) {
        control.dashboard = this;

        // Ensure BaseComponent's methods
        this._castControlToComponent(control, Class);

        // Make sure we clean all events in the case we're redefining the control.
        if(typeof control.off === "function") { control.off("all"); }

        // Endow it with the Backbone event system.
        $.extend(control, Backbone.Events);

        // Add logging lifeCycle
        this._addLogLifecycleToControl(control);

        // For legacy dashboards, we'll automatically assign some priority for component execution.
        if(control.priority == null || control.priority === "") {
                control.priority = this.legacyPriority++;
        }
    }

    return control;
};

Dashboards._castControlToClass = function(control, Class) {
    if(!(control instanceof Class)) {
        var controlImpl = this._makeInstance(Class);

        // Copy implementation into control
        $.extend(control, controlImpl);
    }
};

Dashboards._getControlClass = function(control) {
    // see if there is a class defined for this control
    var typeName = control.type;
    if(typeof typeName === 'function') { typeName = typeName.call(control); } // <=> control.type() ; the _this_ in the call is _control_

    var TypeName = typeName.substring(0,1).toUpperCase() + typeName.substring(1);

    // try _TypeComponent_, _type_ and _Type_ as class names
    var typeNames = [TypeName + 'Component', typeName, TypeName];

    for (var i = 0, N = typeNames.length ; i < N ; i++) {
        // TODO: window represents access to the JS global object.
        // This, or a special object on which to eval types, should be provided by some FWK.

        // If the value of a name is not a function, keep on trying.
        var Class = window[typeNames[i]];
        if(Class && typeof Class === 'function') { return Class; }
    }
    // return undefined;
};

Dashboards._makeInstance = function(Class, args) {
    var o = Object.create(Class.prototype);
    if(args) { Class.apply(o, args); } else { Class.apply(o); }
    return o;
};

Dashboards._castControlToComponent = function(control, Class) {
    // Extend control with BaseComponent methods, if it's not an instance of it.
    // Also, avoid extending if _Class_ was already applied
    // and it is a subclass of BaseComponent.
    if(!(control instanceof BaseComponent) &&
         (!Class || !(Class.prototype instanceof BaseComponent))) {

        var baseProto = BaseComponent.prototype;
        for(var p in baseProto) {
            if(baseProto.hasOwnProperty(p) &&
                 (control[p] === undefined) &&
                 (typeof baseProto[p] === 'function')) {
                switch(p) {
                    // Exceptions
                    case 'base': break;

                    // Copy
                    default: control[p] = baseProto[p]; break;
                }
            }
        }
    }
};

Dashboards._addLogLifecycleToControl = function(control) {
    // TODO: Could the _typeof console !== "undefined"_ test be made beforehand,
    // to avoid always installing the catch-all handler?
    // The same could be said for the _this.logLifecycle_ test.
    // To still allow changing the value dynamically, a Dashboards.setLogLifecycle(.) method could be provided.

    // Add logging lifeCycle
    control.on("all", function(e) {
        var dashs = this.dashboard;
        if(dashs && dashs.logLifecycle && e !== "cdf" && this.name !== "PostInitMarker" && typeof console !== "undefined") {
            var eventStr;
            var eventName = e.substr(4);
            switch(eventName) {
                case "preExecution":  eventStr = ">Start"; break;
                case "postExecution": eventStr = "<End  "; break;
                case "error":         eventStr = "!Error"; break;
                default:              eventStr = "      "; break;
            }
            
            var timeInfo = Mustache.render("Timing: {{elapsedSinceStartDesc}} since start, {{elapsedSinceStartDesc}} since last event", this.splitTimer());
            console.log("%c          [Lifecycle " + eventStr + "] " + this.name + " [" + this.type + "]"  + " (P: "+ this.priority +" ): " +
                    e.substr(4) + " " + timeInfo +" (Running: "+ this.dashboard.runningCalls  +")","color: " + this.getLogColor());
        }
    });
};

Dashboards.getErrorObj = function (errorCode){
    return Dashboards.ERROR_CODES[errorCode] || {};
};

Dashboards.parseServerError = function (resp, txtStatus, error){
    var out = {};
    var regexs = [
        { match: /Query timeout/ , msg: Dashboards.getErrorObj('QUERY_TIMEOUT').msg  }
    ];

    out.error = error;
    out.msg = Dashboards.getErrorObj('COMPONENT_ERROR').msg;
    var str = $('<div/>').html(resp.responseText).find('h1').text();
    _.find( regexs, function (el){
        if ( str.match( el.match )){
            out.msg = el.msg ;
            return true
        } else {
            return false
        }
    });
    out.errorStatus = txtStatus;

    return out
};

Dashboards.handleServerError = function() {
    var err = Dashboards.parseServerError.apply( this, arguments );

    Dashboards.errorNotification( err );
    Dashboards.trigger('cdf cdf:serverError', this);
    Dashboards.resetRunningCalls();
};

Dashboards.errorNotification = function (err, ph) {
    if (ph){
        wd.cdf.notifications.component.render(
            $(ph), {
                title: err.msg,
                desc: ""
        });
    } else {
        wd.cdf.notifications.growl.render({
            title: err.msg,
            desc: ''
        });
    }
};

/**
 * Default impl when not logged in
 */
Dashboards.loginAlert = function(newOpts) {
    var opts = {
        header: "Warning",
        desc: "You are no longer logged in or the connection to the server timed out",
        button: "Click to reload this page",
        callback: function(){
            window.location.reload(true);
        }
    };
    opts = _.extend( {} , opts, newOpts );

    wd.cdf.popups.okPopup.show(opts);
    this.trigger('cdf cdf:loginError', this);
};

/**
 *
 */
Dashboards.checkServer = function() {
    //check if is connecting to server ok
    //use post to avoid cache
    var retVal = false;
    $.ajax({
        type: 'POST',
        async: false,
        dataType: 'json',
        url: Dashboards.CDF_BASE_PATH + 'ping',
        success: function(result) {
            if(result && result.ping == 'ok') {
                retVal = true;
            }
            else {
                retVal = false;
            }
        },
        error: function() {
            retVal = false;
        }
        
    });
    return retVal;
};


Dashboards.restoreDuplicates = function() {
    /*
     * We mark duplicates by appending an _nn suffix to their names.
     * This means that, when we read the parameters from bookmarks,
     * we can look for the _nn suffixes, and infer from those suffixes
     * what duplications were triggered, allowing us to reproduce that
     * state as well.
     */
    var dupes = this.components.filter(function(c){return c.type == 'duplicate'}),
            suffixes = {},
            params = this.getBookmarkState().params || {};
    /*
     * First step is to go over the bookmarked parameters and find
     * all of those that end with the _nn suffix (possibly several
     * such suffixes piled up, like _1_2, as we can re-duplicate
     * existing duplicates).
     *
     * The suffixes object then maps those suffixes to a mapping of
     * the root parameter names to their respective values.
     * E.g. a parameter 'foo_1 = 1' yields '{_1: {foo: 1}}'
     */
    Object.keys(params).filter(function(e){
            return /(_[0-9]+)+$/.test(e);
    }).map(function(e){
            var parts = e.match(/(.*?)((_[0-9]+)+)$/),
                    name = parts[1],
                    suffix = parts[2];
            if(!suffixes[suffix]){
                    suffixes[suffix] = {}
            }
            suffixes[suffix][name] = params[e];
            return e;
    });


    /*
     * Once we have the suffix list, we'll check each suffix's
     * parameter list against each of the DuplicateComponents
     * in the dashboard. We consider that a suffix matches a
     * DuplicateComponent if the suffix contains all of the
     * Component's Bookmarkable parameters. If we're satisfied
     * that such a match was found, then we tell the Component
     * to trigger a duplication with the provided values.
     */
    var myself = this;
    for (var s in suffixes) if (suffixes.hasOwnProperty(s)) {
        var params = suffixes[s];
        $.each(dupes,function(i,e){
            var p;
            for (p = 0; p < e.parameters.length;p++) {
                if (!params.hasOwnProperty(e.parameters[p]) && myself.isBookmarkable(e.parameters[p])) {
                    return;
                }
            }
            e.duplicate(params);
        });
    }
}
Dashboards.blockUIwithDrag = function() {
    if (typeof this.i18nSupport !== "undefined" && this.i18nSupport != null) {
        // If i18n support is enabled process the message accordingly
        $.blockUI.defaults.message = '<div style="padding: 0px;"><img src="' + this.getWebAppPath() + '/content/pentaho-cdf/resources/style/images/processing_transparent.gif" /></div>';
    }

    $.blockUI();
    var handle = $('<div id="blockUIDragHandle"></div>')
    $("div.blockUI.blockMsg").prepend(handle);
    $("div.blockUI.blockMsg").draggable({
        handle: "#blockUIDragHandle"
    });
};

Dashboards.updateLifecycle = function(object) {
        var silent = object.lifecycle ? !!object.lifecycle.silent : false;

        if( object.disabled ){
            return;
        }
        if(!silent) {
            this.incrementRunningCalls();
        }
        var handler = _.bind(function() {
            try {
                var shouldExecute;
                if(!(typeof(object.preExecution)=='undefined')){
                    shouldExecute = object.preExecution.apply(object);
                }
                /*
                 * If `preExecution` returns anything, we should use its truth value to
                 * determine whether the component should execute. If it doesn't return
                 * anything (or returns `undefined`), then by default the component
                 * should update.
                 */
                shouldExecute = typeof shouldExecute != "undefined"? !!shouldExecute : true;
                object.trigger('cdf cdf:preExecution', object, shouldExecute);
                if (!shouldExecute) {
                    return; // if preExecution returns false, we'll skip the update
                }
                if (object.tooltip != undefined){
                    object._tooltip = typeof object["tooltip"]=='function'?object.tooltip():object.tooltip;
                }
                // first see if there is an objectImpl
                if ((object.update != undefined) &&
                    (typeof object['update'] == 'function')) {
                    object.update();

                    // check if component has periodic refresh and schedule next update
                    this.refreshEngine.processComponent(object);

                } else {
                // unsupported update call
                }

                if(!(typeof(object.postExecution)=='undefined')){
                    object.postExecution.apply(object);
                }
                // if we have a tooltip component, how is the time.
                if (object._tooltip != undefined){
                    $("#" + object.htmlObject).attr("title",object._tooltip).tooltip({
                        delay:0,
                        track: true,
                        fade: 250
                    });
                }
            } catch (e) {
                var ph = (object.htmlObject) ? $('#' + object.htmlObject) : undefined,
                        msg = Dashboards.getErrorObj('COMPONENT_ERROR').msg
                                    + ' (' + object.name.replace('render_', '') + ')';
                this.errorNotification( { msg: msg  } , ph );
                this.log("Error updating " + object.name +":",'error');
                this.log(e,'exception');
            } finally {
                if(!silent) {
                    this.decrementRunningCalls();
                }
            }

            // Triggering the event for the rest of the process
            object.trigger('cdf cdf:postExecution', object);

    },this);
    setTimeout(handler,1);
};

Dashboards.update = function(component) {
    /*
     * It's not unusual to have several consecutive calls to `update` -- it can
     * happen, e.g, as a result of using `DuplicateComponent` to clone a number
     * of components. If we pass each update individually to `updateAll`, the
     * first call will pass through directly, while the remaining calls will
     * result in the components being queued up for update only after the first
     * finished. To prevent this, we build a list of components waiting to be
     * updated, and only pass those forward to `updateAll` if we haven't had any
     * more calls within 5 miliseconds of the last.
     */
    if(!this.updateQueue){
        this.updateQueue = [];
    }
    this.updateQueue.push(component);
    if(this.updateTimeout) {
        clearTimeout(this.updateTimeout);
    }

    var handler = _.bind(function(){
        this.updateAll(this.updateQueue);
        delete this.updateQueue;
    },this);
    this.updateTimeout = setTimeout(handler,5);
};

Dashboards.updateComponent = function(object) {
    if(Date.now() - Dashboards.lastServerResponse > Dashboards.serverCheckResponseTimeout) {
        //too long in between ajax communications
        if(!Dashboards.checkServer()) {
            Dashboards.hideProgressIndicator();
            Dashboards.loginAlert();
            throw "not logged in";
        }
    }

    if(object.isManaged === false && object.update) {
        object.update();
    // check if component has periodic refresh and schedule next update
        this.refreshEngine.processComponent(object);
    } else {
        this.updateLifecycle(object);
    }
};

Dashboards.createAndCleanErrorDiv = function(){
    if ($("#"+CDF_ERROR_DIV).length == 0){
        $("body").append("<div id='" +  CDF_ERROR_DIV + "'></div>");
    }
    $("#"+CDF_ERROR_DIV).empty();
};

Dashboards.showErrorTooltip = function(){
    $(function(){
        $(".cdf_error").tooltip({
            delay:0,
            track: true,
            fade: 250,
            showBody: " -- "
        })
    });
};

Dashboards.getComponent = function(name){
    for (var i in this.components){
        if (this.components[i].name == name)
            return this.components[i];
    }
};

Dashboards.getComponentByName = function(name) {
    if (this.globalContext) {
        return eval(name);
    } else {
        return this.getComponent(name);
    }
};

Dashboards.addComponents = function(components) {
    components.forEach(function(component) {
        this.bindControl(component);
        this.components.push(component);
    }, this);
};

Dashboards.addComponent = function(component, options) {
    this.removeComponent(component);

    // Attempt to convert over to component implementation
    this.bindControl(component);

    var index = options && options.index;
    var L = this.components.length;
    if(index == null || index < 0 || index > L) { index = L; } // <=> push
    this.components[index] = component;
};

Dashboards.getComponentIndex = function(compOrNameOrIndex) {
    if(compOrNameOrIndex != null) {
        switch(typeof compOrNameOrIndex) {
            case 'string':
            for(var i = 0, cs = this.components, L = cs.length ; i < L ; i++) {
                    if(cs[i].name === compOrNameOrIndex) { return i; }
            }
                break;
            case 'number':
                if(compOrNameOrIndex >= 0 && compOrNameOrIndex < this.components.length) {
                    return compOrNameOrIndex;
                }
                break;

            default: return this.components.indexOf(compOrNameOrIndex);
        }
    }
    return -1;
};

Dashboards.removeComponent = function(compOrNameOrIndex) {
    var index = this.getComponentIndex(compOrNameOrIndex);
    var comp = null;
    if(index >= 0) {
        var cs = this.components;
        comp = cs[index];
        cs.splice(index, 1);
        comp.dashboard = null;
        
        comp.off('cdf:postExecution');
        comp.off('cdf:preExecution');
        comp.off('cdf:error');
        comp.off('all');
    }

    return comp;
};

Dashboards.registerEvent = function (ev, callback) {
    if (typeof this.events == 'undefined') {
        this.events = {};
    }
    this.events[ev] = callback;
};

Dashboards.addArgs = function(url){
    if(url != undefined)
        this.args = getURLParameters(url);
};

Dashboards.setI18nSupport = function(lc, i18nRef) {
    // Update global reference to i18n objects if needed
    if (i18nRef !== "undefined" && lc !== "undefined") {
        this.i18nCurrentLanguageCode = lc;
        this.i18nSupport = i18nRef;
    }

};

Dashboards.init = function(components){
    var myself =this;
    if(this.initialStorage) {
        _.extend(this.storage, this.initialStorage);
    } else {
        this.loadStorage();
    }
    if(this.context != null && this.context.sessionTimeout != null ) {
        //defaulting to 90% of ms value of sessionTimeout
        Dashboards.serverCheckResponseTimeout = this.context.sessionTimeout * 900;
    }
    this.restoreBookmarkables();
    this.restoreView();
    this.syncParametersInit();
    if ($.isArray(components)) {
        this.addComponents(components);
    }
    $(function() {
        myself.initEngine();
    });
};


/* Keep parameters master and slave in sync. The master parameter's
 * initial value takes precedence over the slave parameter's when
 * initializing the dashboard.
 */
Dashboards.syncParameters = function(master, slave) {
    this.setParameter(slave, this.getParameterValue(master));
    this.parameterModel.change();
    this.parameterModel.on("change:" + master,function(m,v){this.fireChange(slave,v)},this);
    this.parameterModel.on("change:" + slave,function(m,v){this.fireChange(master,v)},this);
}

Dashboards.chains = [];
Dashboards.syncedParameters = {};
/* Register parameter pairs that will be synced on dashboard init. We'll store
 * the dependency pairings in Dashboards.syncedParameters,as an object mapping
 * master parameters to an array of all its slaves (so {a: [b,c]} means that
 * both *b* and *c* are subordinate to *a*), and in Dashboards.chains wel'll
 * store an array of arrays representing a list of separate dependency trees.
 * An entry of the form [a, b, c] means that *a* doesn't depend on either *b*
 * or *c*, and that *b* doesn't depend on *c*. Inversely, *b* depends on *a*,
 * and *c* depends on either *a* or *b*. You can have multiple such entries,
 * each representing a completely isolated set of dependencies.
 *
 * Note that we make no effort to detect circular dependencies. Behaviour is
 * undetermined should you provide such a case.
 */
Dashboards.syncParametersOnInit = function (master, slave){
    var parameters = this.syncedParameters,
            currChain,
            masterChain,
            slaveChain, slaveChainIdx, i;
    if(!parameters[master]) parameters[master] = [];
    parameters[master].push(slave);

    /* When inserting an entry into Dashboards.chains, we need to check whether
     * any of the master or the slave are already in one of the chains.
     */
    for (i = 0; i < this.chains.length;i++) {
        currChain = this.chains[i];
        if (currChain.indexOf(master) > -1) {
            masterChain = currChain;
        }
        if (currChain.indexOf(slave) > -1) {
            slaveChain = currChain;
            slaveChainIdx = i;
        }
    }
    /* If both slave and master are present in different chains, we merge the
     * chains.
     *
     * If only one of the two is present, we insert the slave at the end
     * of the master's chain, or the master at the head of the slave's chain.
     *
     * Note that, since a parameter can be both a master and a slave, and because
     * no slave can have two masters, it is guaranteed that we can only add the
     * master to the head of the chain if the slave was the head before, and, when
     * adding the slave at the end of the master's chain, none of the parameters
     * between master and slave can depend on the slave. This means there is no
     * scenario where a chain can become inconsistent from prepending masters or
     * appending slaves.
     *
     * If neither master nor slave is present in the existing chains, we create a
     * new chain with [master, slave].
     */
    if(slaveChain && masterChain) {
        if (masterChain != slaveChain) {
            args = slaveChain.slice();
            args.unshift(0);
            args.unshift(masterChain.length);
            [].splice.apply(masterChain,args);
            this.chains.splice(slaveChainIdx,1);
        }
    } else if (slaveChain) {
            slaveChain.unshift(master);
    } else if(masterChain) {
            masterChain.push(slave)
    } else {
        this.chains.push([master, slave]);
    }
}

/*
 * Iterate over the registered parameter syncing chains,
 * and configure syncing for each parameter pair.
 */
Dashboards.syncParametersInit = function() {
    var parameters = this.syncedParameters,
            i,j,k,master, slave;
    for(i = 0; i < this.chains.length;i++) {
        for(j = 0; j < this.chains[i].length;j++) {
            var master = this.chains[i][j];
            if(!parameters[master]) continue;
            for(k = 0; k < parameters[master].length; k++) {
                slave = parameters[master][k];
                this.syncParameters(master,slave);
            }
        }
    }
}


Dashboards.initEngine = function() {
    // Should really throw an error? Or return?
    if(this.waitingForInit && this.waitingForInit.length) {
        this.log("Overlapping initEngine!", 'warn');
    }

    var myself = this;
    var components = this.components;

    this.incrementRunningCalls();
    if( this.logLifecycle && typeof console != "undefined" ){
        console.log("%c          [Lifecycle >Start] Init (Running: "+ this.getRunningCalls()  +")","color: #ddd ");
    }

    this.createAndCleanErrorDiv();
    // Fire all pre-initialization events
    if(typeof this.preInit == 'function') {
        this.preInit();
    }
    this.trigger("cdf cdf:preInit",this);
    /* Legacy Event -- don't rely on this! */
    $(window).trigger('cdfAboutToLoad');
    var myself = this;
    var updating = [],i;
    for(i = 0; i < components.length;i++) {
        if(components[i].executeAtStart) {
            updating.push(components[i]);
        }
    }

    if (!updating.length) {
        this.handlePostInit();
        return;
    }

    // Since we can get into racing conditions between last component's
    // preExecution and dashboard.postInit, we'll add a last component with very
    // low priority who's funcion is only to act as a marker.
    var postInitComponent = {
        name: "PostInitMarker",
        type: "unmanaged",
        lifecycle: {
            silent: true
        },
        executeAtStart: true,
        priority:999999999
    };
    this.bindControl(postInitComponent)
    updating.push(postInitComponent);


    this.waitingForInit = updating.slice();

    var callback = function(comp,isExecuting) {
        /*
         * The `preExecution` event will pass two arguments (the component proper
         * and a flag telling us whether the preExecution test passed), so we can
         * test for that, and check whether the component is executing or not.
         * If it's not going to execute, we should check for postInit right now.
         * If it is, we shouldn't do anything.right now.
         */
        if(arguments.length == 2 && isExecuting) {
            return;
        }
        this.waitingForInit = _(this.waitingForInit).without(comp);
        comp.off('cdf:postExecution',callback);
        comp.off('cdf:preExecution',callback);
        comp.off('cdf:error',callback);
        this.handlePostInit();
    }

    for(var i= 0, len = updating.length; i < len; i++){
        var component = updating[i];
        component.on('cdf:postExecution cdf:preExecution cdf:error',callback,myself);
    }
    Dashboards.updateAll(updating);
    if(components.length > 0) {
        myself.handlePostInit();
    }

};

Dashboards.handlePostInit = function() {
    if( (!this.waitingForInit || this.waitingForInit.length === 0) && !this.finishedInit ) {
        this.trigger("cdf cdf:postInit",this);
        /* Legacy Event -- don't rely on this! */
        $(window).trigger('cdfLoaded');

        if(typeof this.postInit == "function") {
            this.postInit();
        }
        this.restoreDuplicates();
        this.finishedInit = true;

        this.decrementRunningCalls();
        if( this.logLifecycle && typeof console != "undefined" ){
            console.log("%c          [Lifecycle <End  ] Init (Running: "+ this.getRunningCalls()  +")","color: #ddd ");
        }

    }
};

Dashboards.resetAll = function(){
    this.createAndCleanErrorDiv();
    var compCount = this.components.length;
    for(var i= 0, len = this.components.length; i < len; i++){
        this.components[i].clear();
    }
    var compCount = this.components.length;
    for(var i= 0, len = this.components.length; i < len; i++){
        if(this.components[i].executeAtStart){
            this.update(this.components[i]);
        }
    }
};

Dashboards.processChange = function(object_name){

    //Dashboards.log("Processing change on " + object_name);

    var object = this.getComponentByName(object_name);
    var parameter = object.parameter;
    var value;
    if (typeof object['getValue'] == 'function') {
        value = object.getValue();
    }
    if (value == null) // We won't process changes on null values
        return;

    if(!(typeof(object.preChange)=='undefined')){
        var preChangeResult = object.preChange(value);
        value = preChangeResult != undefined ? preChangeResult : value;
    }
    if(parameter) {
        this.fireChange(parameter,value);
    }
    if(!(typeof(object.postChange)=='undefined')){
        object.postChange(value);
    }
};

/* fireChange must accomplish two things:
 * first, we must change the parameters
 * second, we execute the components that listen for
 * changes on that parameter.
 *
 * Because some browsers won't draw the blockUI widgets
 * until the script has finished, we find the list of
 * components to update, then execute the actual update
 * in a function wrapped in a setTimeout, so the running
 * script has the opportunity to finish.
 */
Dashboards.fireChange = function(parameter, value) {
    var myself = this;
    this.createAndCleanErrorDiv();

    this.setParameter(parameter, value);
    this.parameterModel.change();
    var toUpdate = [];
    var workDone = false;
    for (var i= 0, len = this.components.length; i < len; i++){
        if ($.isArray(this.components[i].listeners)){
            for (var j= 0 ; j < this.components[i].listeners.length; j++){
                var comp = this.components[i];
                if (comp.listeners[j] == parameter && !comp.disabled) {
                    toUpdate.push(comp);
                    break;
                }
            }
        }
    }
    myself.updateAll(toUpdate);

};


/* Update components by priority. Expects as parameter an object where the keys
 * are the priorities, and the values are arrays of components that should be
 * updated at that priority level:
 *
 *    {
 *      0: [c1,c2],
 *      2: [c3],
 *      10: [c4]
 *    }
 *
 * Alternatively, you can pass an array of components, `[c1, c2, c3]`, in which
 * case the priority-keyed object will be created internally from the priority
 * values the components declare for themselves.
 *
 * Note that even though `updateAll` expects `components` to have numerical
 * keys, and that it does work if you pass it an array, `components` should be
 * an object, rather than an array, so as to allow negative keys (and so that
 * we can use it as a sparse array of sorts)
 */
Dashboards.updateAll = function(components) {
    if(!this.updating) {
        this.updating = {
            tiers: {},
            current: null
        };
    }
    if(components && _.isArray(components) && !_.isArray(components[0])) {
        var comps = {};
        _.each(components,function(c) {
            var prio = c.priority || 0;
            if(!comps[prio]) {
                comps[prio] = [];
            }
            comps[prio].push(c);
        });
        components = comps;
    }
    this.mergePriorityLists(this.updating.tiers,components);

    var updating = this.updating.current;
    if(updating === null || updating.components.length == 0) {
        var toUpdate = this.getFirstTier(this.updating.tiers);
        if(!toUpdate) return;
        this.updating.current = toUpdate;

        var postExec = function(component,isExecuting) {
            /*
             * We first need to figure out what event we're handling. `error` will
             * pass the component, error message and caught exception (if any) to
             * its event handler, while the `preExecution` event will pass two
             * arguments (the component proper and a flag telling us whether the
             * preExecution test passed).
             *
             * If we're not going to finish updating the component, either because
             * `preExecution` cancelled the update, or because we're in an `error`
             * event handler, we should queue up the next component right now.
             */
            if(arguments.length == 2 && typeof isExecuting == "boolean" && isExecuting) {
                return;
            }
            component.off("cdf:postExecution",postExec);
            component.off("cdf:preExecution",postExec);
            component.off("cdf:error",postExec);
            var current = this.updating.current;
            current.components = _.without(current.components, component);
            var tiers = this.updating.tiers;
            tiers[current.priority] = _.without(tiers[current.priority], component);
            this.updateAll();
        }
        /*
         * Any synchronous components we update will edit the `current.components`
         * list midway through this loop, so we need a separate copy of that list
         * so as to avoid messing up the indices.
         */
        var comps = this.updating.current.components.slice();
        for(var i = 0; i < comps.length;i++) {
            component = comps[i];
            // Start timer
            component.startTimer();
            component.on("cdf:postExecution cdf:preExecution cdf:error",postExec,this);

            // Logging this.updating. Uncomment if needed to trace issues with lifecycle
            // Dashboards.log("Processing "+ component.name +" (priority " + this.updating.current.priority +"); Next in queue: " +
            //  _(this.updating.tiers).map(function(v,k){return k + ": [" + _(v).pluck("name").join(",") + "]"}).join(", "));
            this.updateComponent(component);
        }
    }
}

/*
 * Given a list of component priority tiers, returns the highest priority
 * non-empty tier of components awaiting update, or null if no such tier exists.
 */
Dashboards.getFirstTier = function(tiers) {
            var keys = _.keys(tiers).sort(function(a,b){
                return parseInt(a,10) - parseInt(b,10);
            }),
            i, tier;

    for(i = 0;i < keys.length;i++) {
        tier = tiers[keys[i]];
        if(tier.length > 0) {
            return {priority: keys[i], components: tier.slice()};
        }
    }
    return null;
}

/*
 * Add all components in priority list 'source' into priority list 'target'
 */
Dashboards.mergePriorityLists = function(target,source) {
    if(!source) {
        return;
    }
    for(var key in source) if (source.hasOwnProperty(key)) {
        if(_.isArray(target[key])) {
            target[key] = _.union(target[key],source[key]);
        } else {
            target[key] = source[key];
        }
    }
}

Dashboards.restoreView = function() {
    var p, params;
    if(!this.view) return;
    /* Because we're storing the parameters in OrientDB, and as OrientDB has some
     * serious issues when storing nested objects, we're stuck marshalling the
     * parameters into a JSON object and converting that JSON into a Base64 blob
     * before storage. So now we have to decode that mess.
     */
    params = JSON.parse(Base64.decode(this.view.params));
    for(p in params) if (params.hasOwnProperty(p)) {
        this.setParameter(p,params[p]);
    }
};

Dashboards.getHashValue = function(key) {
    var hash = window.location.hash,
            obj;
    try {
        obj = JSON.parse(hash.slice(1));
    } catch (e) {
        obj = {};
    }
    if (arguments.length === 0) {
        return obj;
    } else {
        return obj[key];
    }
}

Dashboards.setHashValue = function(key, value) {
    var obj = this.getHashValue(),json;
    if (arguments.length == 1) {
        obj = key;
    } else {
        obj[key] = value;
    }
    json = JSON.stringify(obj);
    /* We don't want to store empty objects */
    if (json != "{}") {
        window.location.hash = json;
    } else {
        if (window.location.hash) {
            window.location.hash = '';
        }
    }
}
Dashboards.deleteHashValue = function(key) {
    var obj = this.getHashValue();
    if (arguments.length === 0) {
        window.location.hash = "";
    } else {
        delete obj[key];
        this.setHashValue(obj);
    }
}
Dashboards.setBookmarkable = function(parameter, value) {
        if(!this.bookmarkables) this.bookmarkables = {};
        if (arguments.length === 1) value = true;
        this.bookmarkables[parameter] = value;
};

Dashboards.isBookmarkable = function(parameter) {
        if(!this.bookmarkables) {return false;}
        return Boolean(this.bookmarkables[parameter]);
};



Dashboards.generateBookmarkState = function() {
    var params = {},
            bookmarkables = this.bookmarkables;
    for (var k in bookmarkables) if (bookmarkables.hasOwnProperty(k)) {
        if (bookmarkables[k]) {
            params[k] = this.getParameterValue(k);
        }
    }
    return params;
};

Dashboards.persistBookmarkables = function(param) {
    var bookmarkables = this.bookmarkables,
            params = {};
    /*
     * We don't want to update the hash if we were passed a
     * non-bookmarkable parameter (why bother?), nor is there
     * much of a point in publishing changes when we're still
     * initializing the dashboard. That's just the code for
     * restoreBookmarkables doing the reverse of this!
     */
    if (!bookmarkables || !bookmarkables[param]) {
        return;
    }
    if(!this.finishedInit) {
        return;
    }
    params = this.generateBookmarkState();
    this.setBookmarkState({impl: 'client',params: params});
}

Dashboards.setBookmarkState = function(state) {
    if(window.history && window.history.replaceState) {
        var method = window.location.pathname.split('/').pop(),
                query = window.location.search.slice(1).split('&').map(function(e){
                    var entry = e.split('=');
                    entry[1] = decodeURIComponent(entry[1]);
                    return entry;
                }),
                url;
        query = this.propertiesArrayToObject(query);
        query.bookmarkState = JSON.stringify(state);
        url = method + '?' + $.param(query);
        window.history.replaceState({},'',url);
        this.deleteHashValue('bookmark');
    } else {
        this.setHashValue('bookmark',state);
    }
};

Dashboards.getBookmarkState = function() {
    /*
     * browsers that don't support history.pushState
     * can't actually safely remove bookmarkState param,
     * so we must first check whether there is a hash-based
     * bookmark state.
     */
    if (window.location.hash.length > 1) {
    try {
            return this.getHashValue('bookmark') || {};
        } catch (e) {
            /*
             * We'll land here if the hash isn't a valid json object,
             * so we'll go on and try getting the state from the params
             */
        }
    }
    var query = window.location.search.slice(1).split('&').map(function(e){
                    var pair = e.split('=');
                    pair[1] = decodeURIComponent(pair[1]);
                    return pair;
            }),
            params = this.propertiesArrayToObject(query);
    if(params.bookmarkState) {
        return JSON.parse(decodeURIComponent(params.bookmarkState.replace(/\+/g,' '))) || {};
    } else  {
        return {};
    }
};

Dashboards.restoreBookmarkables = function() {
    var state;
    this.bookmarkables = this.bookmarkables || {};
    try {
        state = this.getBookmarkState().params;
        for (var k in state) if (state.hasOwnProperty(k)) {
            this.setParameter(k,state[k]);
        }
    } catch (e) {
        this.log(e,'error');
    }
}

Dashboards.setParameterViewMode = function(parameter, value) {
        if(!this.viewParameters) this.viewParameters = {};
        if (arguments.length === 1) value = this.viewFlags.VIEW;
        //if(!Dashboards.viewFlags.hasOwnProperty(value)) throw
        this.viewParameters[parameter] = value;
};

Dashboards.isViewParameter = function(parameter) {
        if(!this.viewParameters) {return false;}
        return this.viewParameters[parameter];
};

/*
 * List the values for all dashboard parameters flagged as being View parameters
 */
Dashboards.getViewParameters = function(){
    if(!this.viewParameters) return {};
    var params = this.viewParameters,
            ret = {};
    for(var p in params) if (params.hasOwnProperty(p)) {
        if (params[p] == this.viewFlags.VIEW|| params[p] == this.viewFlags.UNBOUND) {
            ret[p] = this.getParameterValue(p);
        }
    }
    return ret;
};

/*
 * List all dashboard parameters flagged as being Unbound View parameters
 */

Dashboards.getUnboundParameters = function(){
    if(!this.viewParameters) return [];
    var params = this.viewParameters,
            ret = []
    for(var p in params) if (params.hasOwnProperty(p)) {
        if (params[p] == this.viewFlags.UNBOUND) {
            ret.push(p);
        }
        return ret;
    }
};

Dashboards.getParameterValue = function (parameterName) {
    if (this.globalContext) {
        try{
            return eval(parameterName);
        }
        catch (e){
            this.error(e);
            //return undefined;
        }
    } else {
        return this.parameters[parameterName];
    }
};

Dashboards.getQueryParameter = function ( parameterName ) {
    // Add "=" to the parameter name (i.e. parameterName=value)
    var queryString = window.location.search.substring(1);
    var parameterName = parameterName + "=";
    if ( queryString.length > 0 ) {
        // Find the beginning of the string
        var begin = queryString.indexOf ( parameterName );
        // If the parameter name is not found, skip it, otherwise return the value
        if ( begin != -1 ) {
            // Add the length (integer) to the beginning
            begin += parameterName.length;
            // Multiple parameters are separated by the "&" sign
            var end = queryString.indexOf ( "&" , begin );
            if ( end == -1 ) {
                end = queryString.length
            }
            // Return the string
            return decodeURIComponent ( queryString.substring ( begin, end ) );
        }
        // Return "" if no parameter has been found
        return "";
    }
};

Dashboards.setParameter = function(parameterName, parameterValue) {
    if(parameterName == undefined || parameterName == "undefined"){
        this.log('Dashboards.setParameter: trying to set undefined!!','warn');
        return;
    }
    if (this.globalContext) {
        //ToDo: this should really be sanitized!
        eval( parameterName + " = " + JSON.stringify(parameterValue) );
    } else {
        if(this.escapeParameterValues) {
            this.parameters[parameterName] = encode_prepare_arr(parameterValue);
        } else {
            this.parameters[parameterName] = parameterValue;
        }
    }
    this.parameterModel.set(parameterName,parameterValue,{silent:true});
    this.persistBookmarkables(parameterName);
};


Dashboards.post = function(url,obj){

    var form = '<form action="' + url + '" method="post">';
    for(var o in obj){

        var v = (typeof obj[o] == 'function' ? obj[o]() : obj[o]);

        if (typeof v == 'string') {
            v = v.replace(/"/g , "\'")
        }

        form += '"<input type="hidden" name="' + o + '" value="' + v + '"/>';
    }
    form += '</form>';
    jQuery(form).appendTo('body').submit().remove();
};

Dashboards.clone = function clone(obj) {

    var c = obj instanceof Array ? [] : {};

    for (var i in obj) {
        var prop = obj[i];

        if (typeof prop == 'object') {
            if (prop instanceof Array) {
                c[i] = [];

                for (var j = 0; j < prop.length; j++) {
                    if (typeof prop[j] != 'object') {
                        c[i].push(prop[j]);
                    } else {
                        c[i].push(this.clone(prop[j]));
                    }
                }
            } else {
                c[i] = this.clone(prop);
            }
        } else {
            c[i] = prop;
        }
    }

    return c;
};

Dashboards.getArgValue  = function(key)
{
    for (i=0;i<this.args.length;i++){
        if(this.args[i][0] == key){
            return this.args[i][1];
        }
    }

    return undefined;
};

Dashboards.ev = function(o){
    return typeof o == 'function'?o():o
};

Dashboards.callPentahoAction = function(obj, solution, path, action, parameters, callback ){
    var myself = this;

    // Encapsulate pentahoAction call
    // Dashboards.log("Calling pentahoAction for " + obj.type + " " + obj.name + "; Is it visible?: " + obj.visible);
    if(typeof callback == 'function'){
        return this.pentahoAction( solution, path, action, parameters,
            function(json){
                callback(myself.parseXActionResult(obj,json));
            }
            );
    }
    else{
        return this.parseXActionResult(obj,this.pentahoAction( solution, path, action, parameters, callback ));
    }
};

Dashboards.urlAction = function ( url, params, func) {
    return this.executeAjax('xml', url, params, func);
};

Dashboards.executeAjax = function( returnType, url, params, func ) {
    var myself = this;
    // execute a url
    if (typeof func == "function"){
        // async
        return $.ajax({
            url: url,
            type: "POST",
            dataType: returnType,
            async: true,
            data: params,
            complete: function (XMLHttpRequest, textStatus) {
                func(XMLHttpRequest.responseXML);
            },
            error: function (XMLHttpRequest, textStatus, errorThrown) {
                myself.log("Found error: " + XMLHttpRequest + " - " + textStatus + ", Error: " +  errorThrown,"error");
            }
        });
    }

    // Sync
    var result = $.ajax({
        url: url,
        type: "POST",
        dataType:returnType,
        async: false,
        data: params,
        error: function (XMLHttpRequest, textStatus, errorThrown) {
            myself.log("Found error: " + XMLHttpRequest + " - " + textStatus + ", Error: " +  errorThrown,"error");
        }

    });
    if (returnType == 'xml') {
        return result.responseXML;
    } else {
        return result.responseText;
    }

};

Dashboards.pentahoAction = function( solution, path, action, params, func ) {
    return this.pentahoServiceAction('ServiceAction', 'xml', solution, path, action, params, func);
};

Dashboards.pentahoServiceAction = function( serviceMethod, returntype, solution, path, action, params, func ) {
    // execute an Action Sequence on the server

    var url = this.getWebAppPath() + "/" + serviceMethod;

    // Add the solution to the params
    var arr = {};
    arr.wrapper = false;
    arr.solution = solution;
    arr.path = path;
    arr.action = action;
    $.each(params,function(i,val){
        arr[val[0]]=val[1];
    });
    return this.executeAjax(returntype, url, arr, func);
};

Dashboards.parseXActionResult = function(obj,html){

    var jXML = $(html);
    var error = jXML.find("SOAP-ENV\\:Fault");
    if (error.length == 0){
        return jXML;
    }

    // error found. Parsing it
    var errorMessage = "Error executing component " + obj.name;
    var errorDetails = new Array();
    errorDetails[0] = " Error details for component execution " + obj.name + " -- ";
    errorDetails[1] = error.find("SOAP-ENV\\:faultstring").find("SOAP-ENV\\:Text:eq(0)").text();
    error.find("SOAP-ENV\\:Detail").find("message").each(function(){
        errorDetails.push($(this).text())
    });
    if (errorDetails.length > 8){
        errorDetails = errorDetails.slice(0,7);
        errorDetails.push("...");
    }

    var out = "<table class='errorMessageTable' border='0'><tr><td><img src='"+ ERROR_IMAGE + "'></td><td><span class=\"cdf_error\" title=\" " + errorDetails.join('<br/>').replace(/"/g,"'") +"\" >" + errorMessage + " </span></td></tr></table/>";

    // if this is a hidden component, we'll place this in the error div
    if (obj.visible == false){
        $("#"+CDF_ERROR_DIV).append("<br />" + out);
    }
    else{
        $('#'+obj.htmlObject).html(out);
    }


    return null;

};

Dashboards.setSettingsValue = function(name,object){

    var data = {
        method: "set",
        key: name,
        value: JSON.stringify(object)
    };
    $.post("Settings", data, function(){});
};

Dashboards.getSettingsValue = function(key,value){

    var callback = typeof value == 'function' ? value : function(json){
        value = json;
    };

    $.getJSON("Settings?method=get&key=" + key , callback);
};

Dashboards.fetchData = function(cd, params, callback) {
    this.log('Dashboards.fetchData() is deprecated. Use Query objects instead','warn');
    // Detect and handle CDA data sources
    if (cd != undefined && cd.dataAccessId != undefined) {
        for (var param in params) {
            cd['param' + params[param][0]] = this.getParameterValue(params[param][1]);
        }
        $.post(webAppPath + "/content/cda/doQuery?", cd,
            function(json) {
                callback(json);
            },'json').error(Dashboards.handleServerError);
    }
    // When we're not working with a CDA data source, we default to using jtable to fetch the data...
    else if (cd != undefined){

        var xactionFile = (cd.queryType == 'cda')? "jtable-cda.xaction" : "jtable.xaction";

        $.post(webAppPath + "/ViewAction?solution=system&path=pentaho-cdf/actions&action=" + xactionFile, cd,
            function(result) {
                callback(result.values);
            },'json');
    }
    // ... or just call the callback when no valid definition is passed
    else {
        callback([]);
    }
};

Dashboards.escapeHtml = function(input) {
    var escaped = input
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/'/g,"&#39;")
    .replace(/"/g,"&#34;");
    return escaped;
};
// STORAGE ENGINE

// Default object
Dashboards.storage = {};

// Operations
Dashboards.loadStorage = function(){
    var myself = this;
    // Don't do anything for anonymousUser.
    if( this.context && this.context.user === "anonymousUser") {
        return;
    }

    var args = {
        action: "read",
        _: (new Date()).getTime() // Needed so IE doesn't try to be clever and retrieve the response from cache
    };
    $.getJSON(webAppPath + "/content/pentaho-cdf/Storage", args, function(json) {
        $.extend(myself.storage,json);
    });
};

Dashboards.saveStorage = function(){
    var myself = this;
    // Don't do anything for anonymousUser
    if( this.context && this.context.user === "anonymousUser") {
        return;
    }

    var args = {
        action: "store",
        storageValue: JSON.stringify(this.storage),
        _: (new Date()).getTime() // Needed so IE doesn't try to be clever and retrieve the response from cache
    };
    $.getJSON(webAppPath + "/content/pentaho-cdf/Storage", args, function(json) {
        if(json.result != true){
            myself.log("Error saving storage",'error');
        }
    });
};

Dashboards.cleanStorage = function(){
    var myself = this;
    this.storage = {};

    // Don't do noting for anonymousUser
    if( this.context && this.context.user === "anonymousUser") {
        return;
    }

    var args = {
        action: "delete"
    };
    $.getJSON(webAppPath + "/content/pentaho-cdf/Storage", args, function(json) {
        if(json.result != true){
            myself.log("Error deleting storage", 'error');
        }
    });
};


(function (D) {
    
    // Conversion functions
    function _pa2obj (pArray) {
        var obj = {};
            for (var p in pArray) if (pArray.hasOwnProperty(p)) {
                var prop = pArray[p];
                obj[prop[0]] = prop[1];
            }
        return obj;
    };
    function _obj2pa (obj) {
        var pArray = [];
        for (var key in obj) if (obj.hasOwnProperty(key)) {
            pArray.push([key,obj[key]]);
        }
        return pArray;
    };

    // Exports
    // NOTE: using underscore.js predicates but we could also use Dashboards.isArray() and 
    //       Dashboards.isObject() (would need to create this one.)
    D.propertiesArrayToObject = function(pArray) {
        // Mantra 1: "Order matters!"
        // Mantra 2: "Arrays are Objects!"
        return ( _.isArray(pArray) && _pa2obj(pArray) ) || ( _.isObject(pArray) && pArray ) || undefined;  
    };

    D.objectToPropertiesArray = function(obj) {
        // Mantra 1: "Order matters!"
        // Mantra 2: "Arrays are Objects!"
        return ( _.isArray(obj) && obj) || ( _.isObject(obj) && _obj2pa(obj)) || undefined;
    };

})(Dashboards);




/**
 * Traverses each <i>value</i>, <i>label</i> and <i>id</i> triple of a <i>values array</i>.
 *
 * @param {Array.<Array.<*>>} values the values array - an array of arrays.
 *   <p>
 *   Each second-level array is a <i>value specification</i> and contains
 *   a value and, optionally, a label and an id.
 *   It may have the following forms:
 *   </p>
 *   <ul>
 *     <li><tt>[valueAndLabel]</tt> - when having <i>length</i> one</li>
 *     <li><tt>[value, label,...]</tt> - when having <i>length</i> two or more and
 *         <tt>opts.valueAsId</tt> is falsy
 *     </li>
 *     <li><tt>[id, valueAndLabel,..]</tt> - when having <i>length</i> two or more and
 *         <tt>opts.valueAsId</tt> is truthy
 *     </li>
 *   </ul>
 * @param {object} opts an object with options.
 *
 * @param {?boolean=} [opts.valueAsId=false] indicates if the first element of
 *   the value specification array is the id, instead of the value.
 *
 * @param {function(string, string, string, number):?boolean} f
 * the traversal function that is to be called with
 * each value-label-id triple and with the JS content <tt>x</tt>.
 * The function is called with arguments: <tt>value</tt>, <tt>label</tt>,
 * <tt>id</tt> and <tt>index</tt>.
 * <p>
 * When the function returns the value <tt>false</tt>, traversal is stopped,
 * and <tt>false</tt> is returned.
 * </p>
 *
 * @param {object} x the JS context object on which <tt>f</tt> is to be called.
 *
 * @return {boolean} indicates if the traversal was complete, <tt>true</tt>,
 *   or if explicitly stopped by the traversal function, <tt>false</tt>.
 */
Dashboards.eachValuesArray = function(values, opts, f, x) {
    if(typeof opts === 'function') {
        x = f;
        f = opts;
        opts = null;
    }

    var valueAsId = !!(opts && opts.valueAsId);
    for(var i = 0, j = 0, L = values.length; i < L; i++) {
        var valSpec = values[i];
        if(valSpec && valSpec.length) {
            var v0 = valSpec[0];
            var value, label, id = undefined; // must reset on each iteration

            if (valSpec.length > 1) {
                if(valueAsId) { id = v0; }
                label = "" + valSpec[1];
                value = (valueAsId || v0 == null) ? label : ("" + v0);
            } else {
                value = label = "" + v0;
            }

            if(f.call(x, value, label, id, j, i) === false) { return false; }
            j++;
        }
    }

    return true;
};


/**
 * Given a parameter value obtains an equivalent values array.
 *
 * <p>The parameter value may encode multiple values in a string format.</p>
 * <p>A nully (i.e. null or undefined) input value or an empty string result in <tt>null</tt>,
 *    and so the result of this method is normalized.
 * </p>
 * <p>
 * A string value may contain multiple values separated by the character <tt>|</tt>.
 * </p>
 * <p>An array or array-like object is returned without modification.</p>
 * <p>Any other value type returns <tt>null</tt>.</p>
 *
 * @param {*} value
 * a parameter value, as returned by {@link Dashboards.getParameterValue}.
 *
 * @return {null|!Array.<*>|!{join}} null or an array or array-like object.
 *
 * @static
 */
Dashboards.parseMultipleValues = function(value) {
    if(value != null && value !== '') {
        // An array or array like?
        if(this.isArray(value)) { return value; }
        if(typeof value === "string") { return value.split("|"); }
    }

    // null or of invalid type
    return null;
};

/**
 * Normalizes a value so that <tt>undefined</tt>, empty string
 * and empty array, are all translated to <tt>null</tt>.
 * @param {*} value the value to normalize.
 * @return {*} the normalized value.
 *
 * @static
 */
Dashboards.normalizeValue = function(value) {
    if(value === '' || value == null) { return null; }
    if(this.isArray(value) && !value.length) return null;
    return value;
};

/**
 * Determines if a value is considered an array.
 * @param {*} value the value.
 * @return {boolean}
 *
 * @static
 */
Dashboards.isArray = function(value) {
    // An array or array like?
    return !!value &&
                 ((value instanceof Array) ||
                    (typeof value === 'object' && value.join && value.length != null));
};

/**
 * Determines if two values are considered equal.
 * @param {*} a the first value.
 * @param {*} b the second value.
 * @return {boolean}
 *
 * @static
 */
Dashboards.equalValues = function(a, b) {
    // Identical or both null/undefined?
    a = this.normalizeValue(a);
    b = this.normalizeValue(b);

    if(a === b) { return true; }

    if(this.isArray(a) && this.isArray(b)) {
        var L = a.length;
        if(L !== b.length) { return false; }
        while(L--) { if(!this.equalValues(a[L], b[L])) { return false; } }
        return true;
    }

    // Last try, give it to JS equals
    return a == b;
};

// Based on the algorithm described at http://en.wikipedia.org/wiki/HSL_and_HSV.
/**
 * Converts an HSV to an RGB color value.
 * 
 * @param {number} h Hue as a value between 0 - 360 (degrees)
 * @param {number} s Saturation as a value between 0 - 100 (%)
 * @param {number} v Value as a value between 0 - 100 (%)
 * @return {string} An rgb(...) color string.
 *
 * @static
 */
Dashboards.hsvToRgb = function(h, s, v) {
        v = v / 100; // 0 - 1
        s = s / 100; // idem
        
        var h6 = (h % 360) /60;
        var chroma = v * s;
        var m = v - chroma;
        var h6t = Math.abs((h6 % 2) - 1);
        //var r = 1 - h6t;
        //var x = chroma * r;
        var x_m = v * (1 - s * h6t); // x + m
        var c_m = v; // chroma + m
        // floor(h6) (0, 1, 2, 3, 4, 5)

        var rgb;
        switch(~~h6) {
                case 0: rgb = [c_m, x_m, m  ]; break;
                case 1: rgb = [x_m, c_m, m  ]; break;
                case 2: rgb = [m,   c_m, x_m]; break;
                case 3: rgb = [m,   x_m, c_m]; break;
                case 4: rgb = [x_m, m,   c_m]; break;
                case 5: rgb = [c_m, m,   x_m]; break;
        }

        rgb.forEach(function(val, i) {
            rgb[i] = Math.min(255, Math.round(val * 256));
        });

        return "rgb(" + rgb.join(",") + ")";
};

/**
 * UTF-8 data encode / decode
 * http://www.webtoolkit.info/
 **/
function encode_prepare_arr(value) {
    if(typeof value == "number"){
        return value;
    } else if ($.isArray(value)){
        var a = new Array(value.length);
        $.each(value,function(i,val){
            a[i] = encode_prepare(val);
        });
        return a;
    }
    else{
        return encode_prepare(value);
    }
};

function encode_prepare( s )
{
    if (s != null) {
        s = s.replace(/\+/g," ");
        if ($.browser == "msie" || $.browser == "opera"){
            return Utf8.decode(s);
        }
    }
    return s;
};


/**
*
* UTF-8 data encode / decode
* http://www.webtoolkit.info/
*
**/ 


var Utf8 = {

    // public method for url encoding
    encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // public method for url decoding
    decode : function (utftext) {
        var string = "";
        var i = 0;
        var c = 0, c2 = 0, c3 = 0;

        while ( i < utftext.length ) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }

        }

        return string;
    }

}

function getURLParameters(sURL)
{
    if (sURL.indexOf("?") > 0){

        var arrParams = sURL.split("?");
        var arrURLParams = arrParams[1].split("&");
        var arrParam = [];

        for (var i=0;i<arrURLParams.length;i++){
            var sParam =  arrURLParams[i].split("=");

            if (sParam[0].indexOf("param",0) == 0){
                var parameter = [sParam[0].substring(5,sParam[0].length),unescape(sParam[1])];
                arrParam.push(parameter);
            }
        }

    }

    return arrParam;
}

function toFormatedString(value) {
    value += '';
    var x = value.split('.');
    var x1 = x[0];
    var x2 = x.length > 1 ? '.' + x[1] : '';
    var rgx = /(\d+)(\d{3})/;
    while (rgx.test(x1))
        x1 = x1.replace(rgx, '$1' + ',' + '$2');
    return x1 + x2;
}

//quote csv values in a way compatible with CSVTokenizer
function doCsvQuoting(value, separator, alwaysEscape){
    var QUOTE_CHAR = '"';
    if(separator == null) {
        return value;
    }
    if(value == null) {
        return null;
    }
    if(value.indexOf(QUOTE_CHAR) >= 0){
        //double them
        value = value.replace(QUOTE_CHAR, QUOTE_CHAR.concat(QUOTE_CHAR));
    }
    if(alwaysEscape || value.indexOf(separator) >= 0){
        //quote value
        value =  QUOTE_CHAR.concat(value, QUOTE_CHAR);
    }
    return value;
}

/**
*
*  Javascript sprintf
*  http://www.webtoolkit.info/
*
*
**/
sprintfWrapper = {

    init : function () {

        if (typeof arguments == 'undefined') {
            return null;
        }
        if (arguments.length < 1) {
            return null;
        }
        if (typeof arguments[0] != 'string') {
            return null;
        }
        if (typeof RegExp == 'undefined') {
            return null;
        }

        var string = arguments[0];
        var exp = new RegExp(/(%([%]|(\-)?(\+|\x20)?(0)?(\d+)?(\.(\d)?)?([bcdfosxX])))/g);
        var matches = new Array();
        var strings = new Array();
        var convCount = 0;
        var stringPosStart = 0;
        var stringPosEnd = 0;
        var matchPosEnd = 0;
        var newString = '';
        var match = null;

        while ((match = exp.exec(string))) {
            if (match[9]) {
                convCount += 1;
            }

            stringPosStart = matchPosEnd;
            stringPosEnd = exp.lastIndex - match[0].length;
            strings[strings.length] = string.substring(stringPosStart, stringPosEnd);

            matchPosEnd = exp.lastIndex;

            var negative = parseInt(arguments[convCount]) < 0;
            if(!negative) negative = parseFloat(arguments[convCount]) < 0;

            matches[matches.length] = {
                match: match[0],
                left: match[3] ? true : false,
                sign: match[4] || '',
                pad: match[5] || ' ',
                min: match[6] || 0,
                precision: match[8],
                code: match[9] || '%',
                negative: negative,
                argument: String(arguments[convCount])
            };
        }
        strings[strings.length] = string.substring(matchPosEnd);

        if (matches.length == 0) {
            return string;
        }
        if ((arguments.length - 1) < convCount) {
            return null;
        }

        match = null;
        var i = null;

        for (i=0; i<matches.length; i++) {
            var m =matches[i];
            var substitution;
            if (m.code == '%') {
                substitution = '%'
            }
            else if (m.code == 'b') {
                m.argument = String(Math.abs(parseInt(m.argument)).toString(2));
                substitution = sprintfWrapper.convert(m, true);
            }
            else if (m.code == 'c') {
                m.argument = String(String.fromCharCode(parseInt(Math.abs(parseInt(m.argument)))));
                substitution = sprintfWrapper.convert(m, true);
            }
            else if (m.code == 'd') {
                m.argument = toFormatedString(String(Math.abs(parseInt(m.argument))));
                substitution = sprintfWrapper.convert(m);
            }
            else if (m.code == 'f') {
                m.argument = toFormatedString(String(Math.abs(parseFloat(m.argument)).toFixed(m.precision ? m.precision : 6)));
                substitution = sprintfWrapper.convert(m);
            }
            else if (m.code == 'o') {
                m.argument = String(Math.abs(parseInt(m.argument)).toString(8));
                substitution = sprintfWrapper.convert(m);
            }
            else if (m.code == 's') {
                m.argument = m.argument.substring(0, m.precision ? m.precision : m.argument.length)
                substitution = sprintfWrapper.convert(m, true);
            }
            else if (m.code == 'x') {
                m.argument = String(Math.abs(parseInt(m.argument)).toString(16));
                substitution = sprintfWrapper.convert(m);
            }
            else if (m.code == 'X') {
                m.argument = String(Math.abs(parseInt(m.argument)).toString(16));
                substitution = sprintfWrapper.convert(m).toUpperCase();
            }
            else {
                substitution = m.match;
            }

            newString += strings[i];
            newString += substitution;
        }

        newString += strings[i];

        return newString;

    },

    convert : function(match, nosign){
        if (nosign) {
            match.sign = '';
        } else {
            match.sign = match.negative ? '-' : match.sign;
        }
        var l = match.min - match.argument.length + 1 - match.sign.length;
        var pad = new Array(l < 0 ? 0 : l).join(match.pad);
        if (!match.left) {
            if (match.pad == '0' || nosign) {
                return match.sign + pad + match.argument;
            } else {
                return pad + match.sign + match.argument;
            }
        } else {
            if (match.pad == '0' || nosign) {
                return match.sign + match.argument + pad.replace(/0/g, ' ');
            } else {
                return match.sign + match.argument + pad;
            }
        }
    }
}

sprintf = sprintfWrapper.init;



// CONTAINER begin
;(function (D){

        function Container() {

                // PUBLIC

                // register(type, what [, scope])
                // register(type, name, what [, scope])
                this.register = function(type, name, what, scope) {
                        if(!type) { throw new Error("Argument 'type' is required."); }
                        if(typeof type !== 'string') { throw new Error("Argument 'type' must be a string."); }

                        if(name != null) {
                                if(typeof name !== 'string') {
                                        scope = what;
                                        what  = name;
                                        name  = null;
                                } else if(!name) {
                                        name = null;
                                }
                        }

                        if(!what) { throw new Error("Argument 'what' is required."); }

                        var holder;
                        switch(typeof what) {
                                case 'function': holder = new FactoryHolder (this, what, scope); break;
                                case 'object':   holder = new InstanceHolder(this, what, scope); break;
                                default: throw new Error("Argument 'what' is of an invalid type.");
                        }

                        if(!name) { name = ''; }

                        var holdersByName = _typesTable[type] || (_typesTable[type] = {});
                        var currHolder = holdersByName[name];
                        if(currHolder) {
                                // throw? log?
                                currHolder.dispose();
                        }
                        holdersByName[name] = holder;
                };

                this.has    = function(type, name) { return !!getHolder(type, name, true); };
                this.canNew = function(type, name) { return getHolder(type, name, false) instanceof FactoryHolder; };

                this.get       = function(type, name)         { return get(type, name, null,   false, false); };
                this.tryGet    = function(type, name)         { return get(type, name, null,   false, true ); };

                this.getNew    = function(type, name, config) { return get(type, name, config, true,  false); };
                this.tryGetNew = function(type, name, config) { return get(type, name, config, true,  true ); };

                this.getAll    = function(type) { return getAll(type, false); };
                this.tryGetAll = function(type) { return getAll(type, true ); };

                this.listType = function(type) { return getType(type,false); };
                this.tryListType = function(type) { return getType(type,true); };

                this.dispose = function() {
                        if(_typesTable) {
                                for(var type in _typesTable) {
                                        var holdersByName = _typesTable[type];
                                        for(var name in holdersByName) {
                                                holdersByName[name].dispose();
                                        }
                                }

                                _typesTable = null;
                        }
                };

                // PRIVATE

                var _typesTable = {}; // type -> []

                function getType(type, isTry) {
                        if(!type) { throw new Error("Argument 'type' is required."); }
                        if(typeof type !== 'string') { throw new Error("Argument 'type' must be a string."); }

                        var holdersByName = _typesTable[type];
                        if(!isTry && (!holdersByName || isOwnEmpty(holdersByName))) {
                                throw new Error("There are no registrations for type '" + type + "'.");
                        }
                        return holdersByName;
                }

                function getHolder(type, name, isTry) {
                        var holder;
                        var holdersByName = getType(type, isTry);
                        if(holdersByName) {
                                holder = holdersByName[name || ''];
                                if(!holder && !isTry) {
                                        throw new Error(
                                                "There is no registration for type '" + type + "'" +
                                                (name ? (" and name '" + name + "'") : "") + ".");
                                }
                        }

                        return holder;
                }

                function get(type, name, config, isNew, isTry) {
                        if(typeof name !== 'string') {
                                config = name;
                                name = '';
                        }

                        var holder = getHolder(type, name, isTry);

                        // Can't store as singletons instances with special config params
                        if(config) { isNew = true;  } else
                        if(!isNew) { config = {}; }

                        return holder ? holder.build(config, isNew) : null;
                }

                function getAll(type, isTry) {
                        var holdersByName = getType(type, isTry);

                        // Includes the default (unnamed) instance
                        var instances = [];
                        for(var name in holdersByName) {
                                instances.push(holdersByName[name].build({}, false));
                        }
                        return instances;
                }
        }

        // Shared/Static stuff

        // Allows creating multiple instances
        function FactoryHolder(container, factory, scope) {
                var instance;

                if(!scope) { scope = 'instance'; }

                this.build = function(config, buildNew) {
                        if(instance && !buildNew) { return instance; }

                        var inst = factory(container, config);

                        if(!buildNew && scope === 'singleton') { instance = inst; }

                        return inst;
                };

                this.dispose = function() {
                        if(instance) {
                                doDispose(instance);
                                instance = null;
                        }
                };
        }

        function InstanceHolder(container, instance, scope) {
                if(!scope) { scope = 'external'; }

                this.build = function(/*config, buildNew*/) { return instance; };

                // external scope is managed outside the container
                this.dispose = function() {
                        if(instance) {
                                scope === 'singleton' && doDispose(instance);
                                instance = null;
                        }
                };
        }

        // Fwk stuff

        function doDispose(instance) {
                if(typeof instance.dispose === 'function') { instance.dispose(); }
        }

        var hasOwn = Object.prototype.hasOwnProperty;

        function isOwnEmpty(o) {
                // tolerates o == null
                for(var n in o) { if(hasOwn.call(o, n)) { return false; } }
                return true;
        }

        // Export
        D.Container = Container;
})(Dashboards);
// CONTAINER end 



// ADDINS begin
;(function (D){
    D.addIns = new D.Container ();

    //Normalization - Ensure component does not finish with component and capitalize first letter
    D.normalizeAddInKey = function(key, subKey) {
            if (key.indexOf('Component', key.length - 'Component'.length) !== -1) 
                key = key.substring(0, key.length - 'Component'.length);  
            key = key.charAt(0).toUpperCase() + key.substring(1);

            if(subKey) { key += "." + subKey; }

        return key;
    }

    D.registerAddIn = function(type,subType,addIn){
        var type = this.normalizeAddInKey(type, subType),
                name = addIn.getName ? addIn.getName() : null;
        this.addIns.register(type, name, addIn);
    };

    D.hasAddIn = function(type,subType,addInName){
        var type = this.normalizeAddInKey(type, subType);
        return Boolean(this.addIns && this.addIns.has(type,addInName));
    };

    D.getAddIn = function(type,subType,addInName){
        var type = this.normalizeAddInKey(type, subType);
        try {
            var addIn = this.addIns.get(type,addInName);
            return addIn;
        } catch (e) {
            return null;
        }
    };

    D.setAddInDefaults = function(type, subType, addInName, defaults) {
        var addIn = this.getAddIn(type, subType,addInName);
        if(addIn) {
            addIn.setDefaults(defaults);
        }
    };
    D.listAddIns = function(type, subType) {
    var type = this.normalizeAddInKey(type, subType);
        var addInList = [];
        try {
            return this.addIns.listType(type);
        } catch (e) {
            return [];
        }
    };
})(Dashboards);
// ADDINS end






Dashboards.safeClone = function(){
    var options, name, src, copy, copyIsArray, clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
        target = {};
    }

    for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
            // Extend the base object
            for ( name in options ) if (options.hasOwnProperty(name)) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];

                    } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = this.safeClone( deep, clone, copy );

                // Don't bring in undefined values
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};



// OPTIONS MANAGER begin
;(function (D){

    // This class is intended to be used as a generic Options Manager, by providing a way to
    // keep record of the values of an options set, but also custom readers, writers and validators 
    // for each of the options.
    function OptionsManager (config ){ /* { defaults: {}, interfaces: {}, libraries: {} }*/
        var myself = this;

        // PROTECTED
        this._options = {};
        this._interfaces = {};
        this._libraries = {
            predicates: {
                tautology: function (value){ return true },
                isFunction: _.isFunction ,
                isPositive: function (value){ return (_.isNumber(value) && value > 0); },
                isObjectOrPropertiesArray : function (value){ 
                    return _.isArray(value) || _.isObject(value);
                },
                isObject: _.isObject,
                isArray: _.isArray
            },
            mappers: {
                identity: _.identity,
                propertiesObject: function (value) {
                    return (_.isArray(value)) ? D.propertiesArrayToObject(value) : value;
                }
            }
        };

        // PUBLIC
        this.mixin = function (instance){
            instance.getOption = this.getOption;
            instance.setOption = this.setOption;
        };

        this.init = function (defaults, interfaces, libraries) {
            var myself = this;
            this._libraries = $.extend(true, {}, this._libraries, libraries);
            _.each( interfaces, function (el,key){
                setInterfaces( key, el );
            });
            _.each( defaults, function(el, key) {
                var ifaces = ( interfaces && interfaces[key] ) || {};
                setInterfaces( key, ifaces);
                setValue( key, el );
            })
        };

        this.setOption = function (opt, value, interfaces){
            setInterfaces(opt, interfaces);
            var reader = getReader(opt),
                    validator = getValidator(opt);
            if ( validator(value) ){
                value = reader(value);
                setValue( opt, value );
                return true
            } else {
                throw new Error( "Invalid Option " + opt.charAt(0).toUpperCase() + opt.slice(1) );
            }
        };

        this.getOption = function (opt){
            var writer = getWriter( opt ),
                    value = getValue(opt);
            return writer( value );
        }; 

        // PRIVATE
        function setInterfaces (opt, interfaces){
            interfaces = interfaces || {};
            setReader(opt, interfaces['reader']);
            setWriter(opt, interfaces['writer']);
            setValidator(opt, interfaces['validator']);
        };

        function getReader(opt){ 
            return get( myself._interfaces, opt, 'reader', myself._libraries.mappers['identity'] 
        )};
        function getWriter(opt){
            return get( myself._interfaces, opt, 'writer', myself._libraries.mappers['identity'] 
        )};
        function getValidator(opt){ 
            return get( myself._interfaces, opt, 'validator', myself._libraries.predicates['tautology'] 
        )};
        function getValue(opt){ return get( myself._options, opt, 'value') };
        
        // Reader, Writer and Validator work in the same way:
        // If the value is a function, use it. 
        // Otherwise, if it is a string and a valid library key, use it.
        // Otherwise, use a default library function: for readers and writers an indentity map, 
        //    for validators a predicate that always returns true.

        function setReader(opt, fn){
            var lib = myself._libraries.mappers;
            fn = ( _.isFunction(fn) && fn ) || ( _.isString(fn) && lib[fn] ) || getReader(opt) || lib['identity'] ;
            return set( myself._interfaces , opt, 'reader', fn) 
        };
        function setWriter(opt, fn){ 
            var lib = myself._libraries.mappers;
            fn = ( _.isFunction(fn) && fn ) || ( _.isString(fn) && lib[fn] ) || getWriter(opt) || lib['identity'] ;
            return set( myself._interfaces, opt, 'writer', fn) 
        };
        function setValidator(opt, fn){ 
            var lib = myself._libraries.predicates;
            fn = ( _.isFunction(fn) && fn ) || ( _.isString(fn) && lib[fn] ) || getValidator(opt) || lib['tautology'] ;
            return set( myself._interfaces, opt, 'validator', fn)
        };
        function setValue(opt, value){ return set( myself._options, opt, 'value', value) };

        // Init
        this.init( config.defaults, config.interfaces, config.libraries);

    }

    // Shared / Static
    function get ( container, opt, attr, defaultValue ){
        var val = defaultValue || undefined ;   
        if ( container && container[opt] && container[opt].hasOwnProperty(attr) ){
            val = container[opt][attr];
        }
        return val
    }
    function set (container, opt, attr, value){
        if (container && opt && attr){
            container[opt] = container[opt] || {};
            container[opt][attr] = value ; 
        }
    }

    D.OptionsManager = OptionsManager;
})(Dashboards);
// OPTIONS MANAGER end



// QUERIES begin
(function (D){

    var _BaseQuery = Base;

    D.getBaseQuery = function (){
        return _BaseQuery;
    };
    D.setBaseQuery = function ( QueryClass ){
        if ( _.isFunction(QueryClass) && QueryClass.extend ){
            _BaseQuery = QueryClass;
        }
    };

    D.queryFactories = new D.Container ();

    D.registerQuery = function(type, query){
        var BaseQuery = this.getBaseQuery();

        // Goes a level deeper one extending these properties. Usefull to preserve defaults and
        // options interfaces from BaseQuery.
        if (!_.isFunction(query) && _.isObject(query)){
            var deepProperties = {};
            _.each( BaseQuery.prototype.deepProperties, function (prop){
                    deepProperties[prop] = _.extend({} , BaseQuery.prototype[prop], query[prop]);
            });
        }

        var QueryClass  = ( _.isFunction(query) && query ) || 
                    ( _.isObject(query) && BaseQuery.extend( _.extend( {}, query, deepProperties ) ) );
 
        // Registers a new query factory with a custom class
        this.queryFactories.register('Query', type, function (container, config){
            return new QueryClass(config);
        });
    };

    D.hasQuery = function(type){
        return Boolean(this.queryFactories && this.queryFactories.has('Query', type));
    };

    D.getQuery = function(type, opts){
        if (_.isUndefined(type) ) {
            type = 'cda';
        } else if ( _.isObject(type) ) {
            opts = type;
            type = opts.queryType || 'cda';
        }
        var query = this.queryFactories.getNew('Query', type, opts);
        return query;
    };

    D.listQueries = function() {
        return _.keys( this.queryFactories.listType('Query') );
    };
})(Dashboards);


/*
 * Query STUFF
 * (Here for legacy reasons)
 * 
 */
//Ctors:
// Query(queryString) --> DEPRECATED
// Query(queryDefinition{path, dataAccessId})
// Query(path, dataAccessId)
Query = function( cd, dataAccessId ) {

    var opts, queryType;

    if( _.isObject(cd) ){
        opts = Dashboards.safeClone(true, cd);
        queryType = (_.isString(cd.queryType) && cd.queryType) || ( !_.isUndefined(cd.query) && 'legacy') || 
            ( !_.isUndefined(cd.path) && !_.isUndefined(cd.dataAccessId) && 'cda') || undefined ;
    } else if ( _.isString(cd) && _.isString(dataAccessId) ) {
        queryType = 'cda';
        opts = {
            path: cd,
            dataAccessId: dataAccessId
        };
    } 

    if (!queryType) { throw 'InvalidQuery' }

    return Dashboards.getQuery(queryType, opts);
};
// QUERIES end



/*
 * UTILITY STUFF
 *
 *
 */

(function() {
    function accessorDescriptor(field, fun)
    {
        var desc = {
            enumerable: true,
            configurable: true
        };
        desc[field] = fun;
        return desc;
    }

    this.defineGetter = function defineGetter(obj, prop, get)
    {
        if (Object.prototype.__defineGetter__)
            return obj.__defineGetter__(prop, get);
        if (Object.defineProperty)
            return Object.defineProperty(obj, prop, accessorDescriptor("get", get));

        throw new Error("browser does not support getters");
    }

    this.defineSetter = function defineSetter(obj, prop, set)
    {
        if (Object.prototype.__defineSetter__)
            return obj.__defineSetter__(prop, set);
        if (Object.defineProperty)
            return Object.defineProperty(obj, prop, accessorDescriptor("set", set));

        throw new Error("browser does not support setters");
    }
})();





/*
 * Popups (Move somewhere else?)
 *
 *
 */


var wd = wd || {};
wd.cdf = wd.cdf || {};
wd.cdf.popups = wd.cdf.popups || {};

wd.cdf.popups.okPopup = {
    template: Mustache.compile(
                            "<div class='cdfPopup'>" +
                            "  <div class='cdfPopupHeader'>{{{header}}}</div>" +
                            "  <div class='cdfPopupBody'>" +
                            "    <div class='cdfPopupDesc'>{{{desc}}}</div>" +
                            "    <div class='cdfPopupButton'>{{{button}}}</div>" +
                            "  </div>" +
                            "</div>"),
    defaults:{
        header: "Title",
        desc:"Description Text",
        button:"Button Text",
        callback: function (){
            return true
        }
    },
    $el: undefined,
    show: function (opts){
        if (opts || this.firstRender){
            this.render(opts);
        }
        this.$el.show();
    },
    hide: function (){
        this.$el.hide();
    },
    render: function (newOpts){
        var opts = _.extend( {} , this.defaults, newOpts );
        var myself = this;
        if (this.firstRender){
            this.$el = $('<div/>').addClass('cdfPopupContainer')
                .hide()
                .appendTo('body');
            this.firstRender = false;
        };
        this.$el.empty().html( this.template( opts ) );
        this.$el.find('.cdfPopupButton').click( function (){
            opts.callback();
            myself.hide();
        });
    },
    firstRender: true
};


/*
 * Error information divs
 *
 *
 */

wd.cdf.notifications = wd.cdf.notifications || {};

wd.cdf.notifications.component = {
    template: Mustache.compile(
                            "<div class='cdfNotification component {{#isSmallComponent}}small{{/isSmallComponent}}'>" +
                            "  <div class='cdfNotificationBody'>" +
                            "    <div class='cdfNotificationImg'>&nbsp;</div>" +
                            "    <div class='cdfNotificationTitle' title='{{title}}'>{{{title}}}</div>" +
                            "    <div class='cdfNotificationDesc' title='{{desc}}'>{{{desc}}}</div>" +
                            "  </div>" +
                            "</div>" ),
    defaults:{
        title: "Component Error",
        desc: "Error processing component."
    },
    render: function (ph, newOpts){
        var opts = _.extend( {}, this.defaults, newOpts);
        opts.isSmallComponent = ( $(ph).width() < 300 );
        $(ph).empty().html( this.template( opts ) );
        var $nt = $(ph).find('.cdfNotification');
        $nt.css({'line-height': $nt.height() + 'px' });
    }
};

wd.cdf.notifications.growl = {
    template: Mustache.compile(
                            "<div class='cdfNotification growl'>" +
                            "  <div class='cdfNotificationBody'>" +
                            "    <h1 class='cdfNotificationTitle' title='{{title}}'>{{{title}}}</h1>" +
                            "    <h2 class='cdfNotificationDesc' title='{{desc}}'>{{{desc}}}</h2>" +
                            "  </div>" +
                            "</div>" ),
    defaults:{
        title: 'Title',
        desc: 'Default CDF notification.',
        timeout: 4000,
        onUnblock: function (){ return true },
        css: $.extend( {},
            $.blockUI.defaults.growlCSS,
            { position: 'absolute' , width: '100%' , top:'10px' } ),
        showOverlay: false,
        fadeIn: 700,
        fadeOut: 1000,
        centerY:false
    },
    render: function (newOpts){
        var opts = _.extend( {}, this.defaults, newOpts),
                $m = $( this.template( opts )),
                myself = this;
        opts.message = $m;
        var outerUnblock = opts.onUnblock;
        opts.onUnblock = function(){
            myself.$el.hide();
            outerUnblock.call(this);
        };
        if (this.firstRender){
            this.$el = $('<div/>').addClass('cdfNotificationContainer')
                .hide()
                .appendTo('body');
            this.firstRender = false;
        }
        this.$el.show().block(opts);
    },
    firstRender: true
};
; /* ************************ new file ************************ */
BaseComponent = Base.extend({
    //type : "unknown",
    visible: true,
    isManaged: true,
    timerStart: 0,
    timerSplit: 0,
    elapsedSinceSplit: -1,
    elapsedSinceStart: -1,
    logColor: undefined,
    //valueAsId:
    //valuesArray:

    clear : function() {
        $("#"+this.htmlObject).empty();
    },

    copyEvents: function(target,events) {
        _.each(events,function(evt, evtName){
            var e = evt,
                    tail = evt.tail;
            while((e = e.next) !== tail) {
                target.on(evtName,e.callback,e.context);
            }
        })
    },

    clone: function(parameterRemap,componentRemap,htmlRemap) {
        var that, dashboard, callbacks;
        /*
         * `dashboard` points back to this component, so we need to remove it from
         * the original component before cloning, lest we enter an infinite loop.
         * `_callbacks` contains the event bindings for the Backbone Event mixin
         * and may also point back to the dashboard. We want to clone that as well,
         * but have to be careful about it.
         */
        dashboard = this.dashboard;
        callbacks = this._callbacks;
        delete this.dashboard;
        delete this._callbacks;
        that = $.extend(true,{},this);
        that.dashboard = this.dashboard = dashboard;
        this._callbacks = callbacks;
        this.copyEvents(that,callbacks);

        if (that.parameters) {
            that.parameters = that.parameters.map(function(param){
                if (param[1] in parameterRemap) {
                    return [param[0],parameterRemap[param[1]]];
                } else {
                    return param;
                }
            });
        }
        if (that.components) {
            that.components = that.components.map(function(comp){
                if (comp in componentRemap) {
                    return componentRemap[comp];
                } else {
                    return comp;
                }
            });
        }
        that.htmlObject = !that.htmlObject? undefined : htmlRemap[that.htmlObject];
        if (that.listeners) {
            that.listeners = that.listeners.map(function(param){
                if (param in parameterRemap) {
                    return parameterRemap[param];
                } else {
                    return param;
                }
            });
        }
        if (that.parameter && that.parameter in parameterRemap) {
            that.parameter = parameterRemap[that.parameter];
        }
        return that;
    },
    getAddIn: function (slot,addIn) {
        var type = typeof this.type == "function" ? this.type() : this.type;
        return Dashboards.getAddIn(type,slot,addIn);
    },
    hasAddIn: function (slot,addIn) {
        var type = typeof this.type == "function" ? this.type() : this.type;
        return Dashboards.hasAddIn(type,slot,addIn);
    },
    getValuesArray : function() {


        var jXML;
        if ( typeof(this.valuesArray) == 'undefined' || this.valuesArray.length == 0) {
            if(typeof(this.queryDefinition) != 'undefined'){

                var vid = (this.queryDefinition.queryType == "sql")?"sql":"none";
                if((this.queryDefinition.queryType == "mdx") && (!this.valueAsId)){
                    vid = "mdx";
                } else if (this.queryDefinition.dataAccessId !== undefined && !this.valueAsId) {
                    vid = 'cda';
                }
                QueryComponent.makeQuery(this);
                var myArray = new Array();
                for(p in this.result) if(this.result.hasOwnProperty(p)){
                    switch(vid){
                        case "sql":
                            myArray.push([this.result[p][0],this.result[p][1]]);
                            break;
                        case "mdx":
                            myArray.push([this.result[p][1],this.result[p][0]]);
                            break;
                        case 'cda':
                            myArray.push([this.result[p][0],this.result[p][1]]);
                            break;
                        default:
                            myArray.push([this.result[p][0],this.result[p][0]]);
                            break;
                    }
                }
                return myArray;
            } else {

                //go through parameter array and update values
                var p = new Array(this.parameters?this.parameters.length:0);
                for(var i= 0, len = p.length; i < len; i++){
                    var key = this.parameters[i][0];
                    var value = this.parameters[i][1] == "" || this.parameters[i][1] == "NIL" ? this.parameters[i][2] : Dashboards.getParameterValue(this.parameters[i][1]);
                    p[i] = [key,value];
                }

                //execute the xaction to populate the selector
                var myself=this;
                if (this.url) {
                    var arr = {};
                    $.each(p,function(i,val){
                        arr[val[0]]=val[1];
                    });
                    jXML = Dashboards.parseXActionResult(myself, Dashboards.urlAction(this.url, arr));
                } else {
                    jXML = Dashboards.callPentahoAction(myself, this.solution, this.path, this.action, p,null);
                }
                //transform the result int a javascript array
                var myArray = this.parseArray(jXML, false);
                return myArray;
            }
        } else {
            return this.valuesArray;
        }
    },
    parseArray : function(jData,includeHeader){

        if(jData === null){
            return []; //we got an error...
        }

        if($(jData).find("CdaExport").size() > 0){
            return this.parseArrayCda(jData, includeHeader);
        }

        var myArray = new Array();

        var jHeaders = $(jData).find("COLUMN-HDR-ITEM");
        if (includeHeader && jHeaders.size() > 0 ){
            var _a = new Array();
            jHeaders.each(function(){
                _a.push($(this).text());
            });
            myArray.push(_a);
        }

        var jDetails = $(jData).find("DATA-ROW");
        jDetails.each(function(){
            var _a = new Array();
            $(this).children("DATA-ITEM").each(function(){
                _a.push($(this).text());
            });
            myArray.push(_a);
        });

        return myArray;

    },
    parseArrayCda : function(jData,includeHeader){
        //ToDo: refactor with parseArray?..use as parseArray?..
        var myArray = new Array();

        var jHeaders = $(jData).find("ColumnMetaData");
        if (jHeaders.size() > 0 ){
            if(includeHeader){//get column names
                var _a = new Array();
                jHeaders.each(function(){
                    _a.push($(this).attr("name"));
                });
                myArray.push(_a);
            }
        }

        //get contents
        var jDetails = $(jData).find("Row");
        jDetails.each(function(){
            var _a = new Array();
            $(this).children("Col").each(function(){
                _a.push($(this).text());
            });
            myArray.push(_a);
        });

        return myArray;

    },

    setAddInDefaults: function(slot,addIn,defaults) {
        var type = typeof this.type == "function" ? this.type() : this.type;
        Dashboards.setAddInDefaults(type,slot,addIn,defaults)
    },
    setAddInOptions: function(slot, addIn,options) {
        if(!this.addInOptions) {
            this.addInOptions = {};
        }

        if (!this.addInOptions[slot]) {
            this.addInOptions[slot] = {};
        }
        this.addInOptions[slot][addIn] = options
    },

    getAddInOptions: function(slot,addIn) {
        var opts = null;
        try {
            opts = this.addInOptions[slot][addIn];
        } catch (e) {
            /* opts is still null, no problem */
        }
        /* opts is falsy if null or undefined */
        return opts || {};
    },

    startTimer: function(){

        this.timerStart = new Date();
        this.timerSplit = new Date();

    },

    splitTimer: function(){

        // Sanity check, in case this component doesn't follow the correct workflow
        if(this.elapsedSinceStart === -1 || this.elapsedSinceSplit === -1){
            this.startTimer();
        }

        var now = new Date();

        this.elapsedSinceStart = now.getTime() - this.timerStart.getTime();
        this.elapsedSinceSplit = now.getTime() - this.timerSplit.getTime();

        this.timerSplit = now;
        return this.getTimerInfo();
    },

    formatTimeDisplay: function(t){
        return Math.log(t)/Math.log(10)>=3?Math.round(t/100)/10+"s":t+"ms";
    },

    getTimerInfo: function(){

            return {
                timerStart: this.timerStart,
                timerSplit: this.timerSplit,
                elapsedSinceStart: this.elapsedSinceStart,
                elapsedSinceStartDesc: this.formatTimeDisplay(this.elapsedSinceStart),
                elapsedSinceSplit: this.elapsedSinceSplit,
                elapsedSinceSplitDesc: this.formatTimeDisplay(this.elapsedSinceSplit)
            }

    },

    /*
     * This method assigns and returns a unique and somewhat randomish color for
     * this log. The goal is to be able to track cdf lifecycle more easily in
     * the console logs. We're returning a Hue value between 0 and 360, a range between 0
     * and 75 for saturation and between 45 and 80 for value
     *
     */

    getLogColor: function(){

        if (this.logColor){
            return this.logColor;
        }
        else{
            // generate a unique,

            var hashCode = function(str){
                var hash = 0;
                if (str.length == 0) return hash;
                for (i = 0; i < str.length; i++) {
                    var chr = str.charCodeAt(i);
                    hash = ((hash<<5)-hash)+chr;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash;
            }

            var hash = hashCode(this.name).toString();
            var hueSeed = hash.substr(hash.length-6,2) || 0;
            var saturationSeed = hash.substr(hash.length-2,2) || 0;
            var valueSeed = hash.substr(hash.length-4,2) || 0;

            this.logColor = Dashboards.hsvToRgb(360/100*hueSeed, 75/100*saturationSeed, 45 + (80-45)/100*valueSeed);
            return this.logColor;

        }


    }

});


var TextComponent = BaseComponent.extend({
    update : function() {
        $("#"+this.htmlObject).html(this.expression());
    }
});

/*******
Comments Component
********/

var CommentsComponent = BaseComponent.extend({

    processing: function () {

        var myself = {};

        myself.defaults = {
                        dataTemplates: {

                            comments:         '<div class="commentsDetails">'+
                                                                ' {{#user}} {{{user}}}, {{/user}} {{{createdOn}}}'+
                                                                '</div>'+
                                                                '<div class="commentsBody">'+
                                                                ' <div class="comment">'+
                                                                '   {{{comment}}}'+
                                                                ' </div>'+
                                                                ' {{#user}}'+
                                                                ' <div class="operation">'+
                                                                ' {{#permissions.deletePermission}}'+
                                                                '   <div class="delete">X</div>' +
                                                                ' {{/permissions.deletePermission}}'+
                                                                ' {{#permissions.archive}}'+
                                                                '  <div class="archive">X</div>' +
                                                                ' {{/permissions.archive}}'+
                                                                ' </div>'+
                                                                ' {{/user}}'+
                                                                '</div>'
                                                                ,

                            addComments:      '<div class="commentsAdd">'+
                                                                '{{#add}}'+
                                                                ' <div class="addComment">Add Comment</div>'+
                                                                ' <div class="addCommentWrapper">'+
                                                                '   <textarea class=addCommentText></textarea>'+
                                                                '   <div class="commentsButtons">'+
                                                                '   <div class="saveComment">Save</div>'+
                                                                '   <div class="cancelComment">Cancel</div>'+
                                                                '   </div>'+
                                                                ' </div>'+
                                                                '{{/add}}'+
                                                                '</div>'
                                                                ,

                            paginateComments: '<div class="paginate commentPaginate"> '+
                                                                '{{#active}}'+
                                                                ' <div class="navigateRefresh"> Refresh </div>'+
                                                                ' <div class="navigatePrevious"> Newest Comments </div>'+
                                                                ' <div class="navigateNext"> Oldest Comments </div>'+
                                                                '{{/active}}'+
                                                                '</div>'
                        }

        };

        // Process operations
        myself.operations = {

            processOperation: function(operation, comment, collection, callback, defaults) {
                var ajaxOptions = {};
                switch(operation) {
                    case 'LIST_ALL':
                        ajaxOptions = {data: { action: 'list', page: defaults.page, firstResult: defaults.paginate.firstResult, maxResults: defaults.paginate.maxResults, where: false} };
                        break;
                    case 'LIST_ACTIVE':
                        ajaxOptions = {data: { action: 'list', page: defaults.page, firstResult: defaults.paginate.firstResult, maxResults: defaults.paginate.maxResults} };
                        break;
                    case 'GET_LAST':
                        ajaxOptions = {data: { action: 'list', page: defaults.page, firstResult: 0, maxResults: 1} };
                        break;
                    case 'DELETE_COMMENT':
                        ajaxOptions = {data: { action: 'delete', page: defaults.page, commentId: comment} };
                        break;
                    case 'ARCHIVE_COMMENT':
                        ajaxOptions = {data: { action: 'archive', page: defaults.page, commentId: comment} };
                        break;
                    case 'ADD_COMMENT':
                        ajaxOptions = {data: { action: 'add', page: defaults.page, comment: comment} };
                        break;
                }
                this.requestProcessing(ajaxOptions, operation, collection, callback);
            },

            requestProcessing: function(overrides, operation, collection, callback){
                var myself = this;
                overrides = overrides || {};
                var ajaxOpts = {
                    type: 'GET',
                    url: "/pentaho/content/pentaho-cdf/Comments",
                    success: function(data) {
                        myself.requestResponse(data, operation, collection, callback)
                    },
                    dataType: 'json'
                };
                ajaxOpts = _.extend( {}, ajaxOpts, overrides);
                $.ajax(ajaxOpts);
            },

            resetCollection: function(result) {
                var paginate = myself.options.paginate;
                var start = paginate.activePageNumber*paginate.pageCommentsSize;
                var end = ((start+paginate.pageCommentsSize) < result.length) ? (start+paginate.pageCommentsSize) : result.length;
                var commentsArray = [];

                for (var idx = start; idx < end; idx++) {
                    var singleComment = new myself.CommentModel(result[idx]);
                    commentsArray.push(singleComment)
                }
                return commentsArray;
            },

            requestResponse: function (json, operation, collection, callback) {
                if ((operation == 'LIST_ALL') || (operation == 'LIST_ACTIVE')) {
                    var paginate = myself.options.paginate;
                    if (paginate.activePageNumber > 0) {
                        if ((paginate.activePageNumber+1) > Math.ceil(json.result.length/paginate.pageCommentsSize))
                         paginate.activePageNumber--;
                    }
                    myself.options.queyResult = json.result;
                    collection.reset(this.resetCollection(json.result));
                    if ((paginate.activePageNumber == 0) && ((json) && (typeof json.result != 'undefined')) && (json.result.length == 0)) {
                        json.result = [{
                                id: 0,
                                comment: 'No Comments to show!',
                                createdOn: '',
                                elapsedMinutes: '',
                                isArchived: false,
                                isDeleted: false,
                                isMe: true,
                                page: '',
                                user: '',
                                permissions: {
                                    add: false,
                                    archive: false,
                                    remove: false
                                }
                        }];
                        if ((collection) && (typeof collection != 'undefined')) {
                            collection.reset(this.resetCollection(json.result));
                        }
                    }
                }
                if ((callback) && (typeof callback != 'undefined')) {
                    callback.apply(this, [json, collection]);
                }
            }
        };

        myself.CommentModel = Backbone.Model.extend({
                defaults: {
                        id: 0,
                        comment: 'Guest User',
                        createdOn: '',
                        elapsedMinutes: '',
                        isArchived: false,
                        isDeleted: false,
                        isMe: true,
                        page: 'comments',
                        user: 'comments',
                        permissions: {}
                },

                initialize: function(){
                    this.set('permissions', myself.options.permissions);
                }

        });

        myself.CommentView = Backbone.View.extend({
            tagName: 'div',
            className: 'commentView',

            events: {
                "click .delete": "deleteComment",
                "click .archive": "archiveComment"
            },

            initialize: function(model){
                _.bindAll(this, 'render', 'deleteComment', 'archiveComment');
                this.model = model;
            },

            render: function(){
                this.$el.append(myself.dataTemplates.comments(this.attributes));
                return this.$el;
            },

            deleteComment: function() {
                var callback = function(data, collection) {
                    myself.operations.processOperation('LIST_ACTIVE', null, collection, null, myself.options);
                };
                myself.operations.processOperation('DELETE_COMMENT', this.model.get('id'), this.model.collection, callback, myself.options);
            },

            archiveComment: function() {
                var callback = function(data, collection) {
                    myself.operations.processOperation('LIST_ACTIVE', null, collection, null, myself.options);
                };
                myself.operations.processOperation('ARCHIVE_COMMENT', this.model.get('id'), this.model.collection, callback, myself.options);
            }

        });

        myself.CommentsCollection = Backbone.Collection.extend({
            model: myself.CommentModel
        });

        myself.CommentsView = Backbone.View.extend({
            tagName: 'div',
            className: 'commentComponent',

            events: {
                "click .addComment": "addComment",
                "click .saveComment": "saveComment",
                "click .cancelComment": "cancelComment",
                "click .navigatePrevious": "navigatePrevious",
                "click .navigateNext": "navigateNext",
                "click .navigateRefresh": "navigateRefresh"
            },

            initialize: function(collection){
                 _.bindAll(this, 'render',
                                                 'addComment',
                                                 'saveComment',
                                                 'cancelComment',
                                                 'renderSingeComment',
                                                 'addComment',
                                                 'saveComment',
                                                 'cancelComment',
                                                 'navigateNext',
                                                 'navigatePrevious',
                                                 'commentsUpdateNotification');

                this.collection = collection;

                this.collection.on('reset', this.render);
                this.collection.on('commentsUpdateNotification', this.commentsUpdateNotification);

                this.render();
            },

            render: function() {
                var $renderElem = $('#'+myself.options.htmlObject);
                var $commentsElem = $('<div/>').addClass('commentsGroup');
                Dashboards.log("Comments Component: Render comments", "debug");
                _(this.collection.models).each(function(comment){
                    $commentsElem.append(this.renderSingeComment(comment));
                }, this);
                var $add = $(myself.dataTemplates.addComments(myself.options.permissions));
                var $paginate = $(myself.dataTemplates.paginateComments(myself.options.paginate));
                this.$el.empty().append($commentsElem, $add, $paginate)
                $renderElem.append(this.$el);
                this.updateNavigateButtons();
            },

            renderSingeComment: function(comment) {
                Dashboards.log("Comments Component: Render single comment", "debug");
                var singleCommentView = new myself.CommentView(comment);
                return singleCommentView.render();
            },

            addComment: function() {
                Dashboards.log("Comments Component: Add comment", "debug");
                this.showAddComment();
            },

            saveComment: function() {
                Dashboards.log("Comments Component: Save comment", "debug");
                var text = this.$el.find('.addCommentText').val();
                var callback = function(data, collection) {
                    var paginate = myself.options.paginate;
                    paginate.activePageNumber = 0;
                    myself.operations.processOperation('LIST_ACTIVE', null, collection, null, myself.options);
                };
                myself.operations.processOperation('ADD_COMMENT', text, this.collection, callback, myself.options);

            },

            cancelComment: function() {
                Dashboards.log("Comments Component: Cancel comment", "debug");
                this.hideAddComment();
            },

            navigateNext: function() {
                Dashboards.log("Comments Component: Next", "debug");
                var paginate = myself.options.paginate;
                var start = paginate.activePageNumber*paginate.pageCommentsSize;
                if ((start+paginate.pageCommentsSize) < myself.options.queyResult.length) {
                    paginate.activePageNumber++;
                    this.collection.reset(myself.operations.resetCollection(myself.options.queyResult));
                }
                this.commentsUpdateNotification();
                this.updateNavigateButtons();
            },

            navigatePrevious: function() {
                Dashboards.log("Comments Component: Previous", "debug");
                var paginate = myself.options.paginate;
                var start = paginate.activePageNumber;
                if (paginate.activePageNumber > 0) {
                    paginate.activePageNumber--;
                    this.collection.reset(myself.operations.resetCollection(myself.options.queyResult));
                }
                this.commentsUpdateNotification();
                this.updateNavigateButtons();
            },

            navigateRefresh: function() {
                Dashboards.log("Comments Component: Refresh", "debug");
                var paginate = myself.options.paginate;
                myself.options.paginate.activePageNumber = 0;
                myself.operations.processOperation('LIST_ACTIVE', null, this.collection, null, myself.options);
                $('.tipsy').remove();
            },

            updateNavigateButtons: function() {
                var paginate = myself.options.paginate;
                $('.navigatePrevious').addClass("disabled");
                $('.navigateNext').addClass("disabled");
                if (paginate.activePageNumber > 0){
                    $('.navigatePrevious').removeClass("disabled");
                }
                if ((paginate.activePageNumber+1) < Math.ceil(myself.options.queyResult.length/paginate.pageCommentsSize)) {
                    $('.navigateNext').removeClass("disabled");
                }
            },

            commentsUpdateNotification: function() {
                Dashboards.log("Comments Component: Comments notification", "debug");
                if (myself.options.queyResult.length > 0) {
                    var lastCommentDate = myself.options.queyResult[0].createdOn;
                    var callback = function(data) {
                        if (data.result.length > 0) {
                            if (!!(data.result[0].createdOn==lastCommentDate)) {
                                Dashboards.log("Comments Component: New Comments? false", "debug");
                            } else {
                                Dashboards.log("Comments Component: New Comments? true", "debug");
                                var tipsyOptions = {
                                    html: true,
                                    fade: true,
                                    trigger: 'manual',
                                    className: 'commentsComponentTipsy',
                                    title: function () {
                                        return 'New comments, please refresh!';
                                    }
                                }
                                $('.commentComponent .navigateRefresh').attr('title','New comments, please refresh!').tipsy(tipsyOptions);
                                $('.commentComponent .navigateRefresh').tipsy('show');

                            }
                        }
                    }
                    myself.operations.processOperation('GET_LAST', null, null, callback, myself.options);
                }
            },

            showAddComment: function() {
                this.$el.find('.addCommentWrapper').show();
                this.$el.find('.paginate').hide();
                this.$el.find('.addCommentText').val('');
            },

            hideAddComment: function() {
                this.$el.find('.addCommentWrapper').hide();
                this.$el.find('.paginate').show();
                this.$el.find('.addCommentText').val('');
            }

        });

        myself.compileTemplates = function() {
            myself.dataTemplates = myself.dataTemplates || {};
            _(myself.defaults.dataTemplates).each(function(value, key) {
                myself.dataTemplates[key] = Mustache.compile(value);
            });
        };

        myself.start = function(options) {
            myself.options = options;
            myself.defaults = _.extend({}, myself.defaults, options.defaults);
            myself.compileTemplates();

            myself.commentsCollection = new myself.CommentsCollection();
            myself.operations.processOperation('LIST_ACTIVE', null, myself.commentsCollection, null, myself.options);
            myself.commentsView = new myself.CommentsView(myself.commentsCollection);

            if (myself.options.intervalActive) {
                var refresh = function() {
                    Dashboards.log("Comments Component: Refresh", "debug");
                    myself.operations.processOperation('LIST_ACTIVE', null, myself.commentsCollection, null, myself.options);
                }
                //setInterval(refresh, myself.options.interval);
                setInterval(function () { myself.commentsCollection.trigger('commentsUpdateNotification'); }, myself.options.interval);
            }

        };

        return myself;

    },


    /*****
     Process component
    *****/

    update: function() {

        // Set page start and length for pagination
        this.paginateActive = (typeof this.paginate == 'undefined')? true: this.paginate;
        this.pageCommentsSize = (typeof this.pageCommentsSize == 'undefined')? 10: this.pageCommentsSize;
        this.firstResult = (typeof this.firstResult == 'undefined')? 0: this.firstResult;
        this.maxResults  = (typeof this.maxResults  == 'undefined')? 100: this.maxResults;
        this.interval  = (typeof this.interval  == 'undefined')? /*60000*/ 5000: this.interval;
        this.intervalActive  = (typeof this.intervalActive  == 'undefined')? true: this.intervalActive;

        this.addPermission = (typeof this.addPermission == 'undefined')? true: this.addPermission;
        this.deletePermission = (typeof this.deletePermission == 'undefined')? false: this.deletePermission;
        this.archivePermission = (typeof this.archivePermission == 'undefined')? true: this.archivePermission;

        this.options = (typeof this.options == 'undefined')? {}: this.options;

        // set the page name for the comments
        if (this.page == undefined){
            Dashboards.log("Fatal - no page definition passed","error");
            return;
        }
        options = {
            htmlObject: this.htmlObject,
            page: this.page,
            intervalActive: this.intervalActive,
            interval: this.interval,
            paginate: {
                active: this.paginateActive,
                activePageNumber: 0,
                pageCommentsSize: this.pageCommentsSize,
                firstResult: this.firstResult,
                maxResults: this.maxResults
            },
            permissions: {
                add: this.addPermission,
                deletePermission: this.deletePermission,
                archive: this.archivePermission
            },
            defaults: this.options
        }

        this.processing().start(options);

        // Old comment component definition
        // this.firePageUpdate();
    }

});


var QueryComponent = BaseComponent.extend({
    visible: false,
    update : function() {
        QueryComponent.makeQuery(this);
    },
    warnOnce: function() {
    Dashboards.log("Warning: QueryComponent behaviour is due to change. See " +
        "http://http://www.webdetails.org/redmine/projects/cdf/wiki/QueryComponent" +
        " for more information");
        delete(this.warnOnce);
    }
},
{
    makeQuery: function(object){

        if (this.warnOnce) {this.warnOnce();}
        var cd = object.queryDefinition;
        if (cd == undefined){
         Dashboards.log("Fatal - No query definition passed","error");
            return;
        }
        var query = Dashboards.getQuery( cd );
        object.queryState = query;

        // Force synchronous queries
        query.setAjaxOptions({async: false});

        query.fetchData(object.parameters, function(values) {
            // We need to make sure we're getting data from the right place,
            // depending on whether we're using CDA

            changedValues = undefined;
            object.metadata = values.metadata;
            object.result = values.resultset != undefined ? values.resultset: values;
            object.queryInfo = values.queryInfo;
            if((typeof(object.postFetch)=='function')){
                changedValues = object.postFetch(values);
            }
            if (changedValues != undefined){
                values = changedValues;

            }

            if (object.resultvar != undefined){
                Dashboards.setParameter(object.resultvar, object.result);
            }
            object.result = values.resultset != undefined ? values.resultset: values;
            if (typeof values.resultset != "undefined"){
                object.metadata = values.metadata;
                object.queryInfo = values.queryInfo;
            }
        });

    }
}
);

var MdxQueryGroupComponent = BaseComponent.extend({
    visible: false,
    update : function() {
        OlapUtils.updateMdxQueryGroup(this);
    }
});

var ManagedFreeformComponent = BaseComponent.extend({
    update : function() {
        this.customfunction(this.parameters || []);
    }
});


/*
 * UnmanagedComponent is an advanced version of the BaseComponent that allows
 * control over the core CDF lifecycle for implementing components. It should
 * be used as the base class for all components that desire to implement an
 * asynchronous lifecycle, as CDF cannot otherwise ensure that the postExecution
 * callback is correctly handled.
 */
var UnmanagedComponent = BaseComponent.extend({
    isManaged: false,
    isRunning: false,

    /*
     * Handle calling preExecution when it exists. All components extending
     * UnmanagedComponent should either use one of the three lifecycles declared
     * in this class (synchronous, triggerQuery, triggerAjax), or call this method
     * explicitly at the very earliest opportunity. If preExec returns a falsy
     * value, component execution should be cancelled as close to immediately as
     * possible.
     */
    preExec: function() {
        /*
         * runCounter gets incremented every time we run a query, allowing us to
         * determine whether the query has been called again after us.
         */
        if(typeof this.runCounter == "undefined") {
            this.runCounter = 0;
        }
        var ret;
        if (typeof this.preExecution == "function") {
            try {
                ret = this.preExecution();
                ret = typeof ret == "undefined" || ret;
            } catch(e){
                this.error( Dashboards.getErrorObj('COMPONENT_ERROR').msg, e);
                this.dashboard.log(e,"error");
                ret = false;
            }
        } else {
            ret = true;
        }
        this.trigger('cdf cdf:preExecution', this, ret);
        return ret;
    },

    /*
     * Handle calling postExecution when it exists. All components extending
     * UnmanagedComponent should either use one of the three lifecycles declared
     * in this class (synchronous, triggerQuery, triggerAjax), or call this method
     * explicitly immediately before yielding control back to CDF.
     */
    postExec: function() {
        if(typeof this.postExecution == "function") {
            this.postExecution();
        }
        this.trigger('cdf cdf:postExecution', this);
    },

    drawTooltip: function() {
        if (this.tooltip) {
            this._tooltip = typeof this.tooltip == "function" ?
                    this.tooltip():
                    this.tooltip;
        }
    },
    showTooltip: function() {
        if(typeof this._tooltip != "undefined") {
            $("#" + this.htmlObject).attr("title",this._tooltip).tooltip({
                delay:0,
                track: true,
                fade: 250
            });
        }
    },

    /*
     * The synchronous lifecycle handler closely resembles the core CDF lifecycle,
     * and is provided as an alternative for components that desire the option to
     * alternate between a synchronous and asynchronous style lifecycles depending
     * on external configuration (e.g. if it can take values from either a static
     * array or a query). It take the component drawing method as a callback.
     */
    synchronous: function(callback, args) {
        if (!this.preExec()) {
            return;
        }
        var silent = this.isSilent();
        if(!silent) {
            this.block();
        }
        setTimeout(_.bind(function(){
            try{
                /* The caller should specify what 'this' points at within the callback
                 * via a Function#bind or _.bind. Since we need to pass a 'this' value
                 * to call, the component itself is the only sane value to pass as the
                 * callback's 'this' as an alternative to using bind.
                 */
                callback.call(this, args || []);
                this.drawTooltip();
                this.postExec();
                this.showTooltip();
            } catch(e){
                this.error(Dashboards.getErrorObj('COMPONENT_ERROR').msg, e );
                this.dashboard.log(e,"error");
            } finally {
                if(!silent) {
                    this.unblock();
                }
            }
        },this), 10);
    },

    /*
     * The triggerQuery lifecycle handler builds a lifecycle around Query objects.
     *
     * It takes a query definition object that is passed directly into the Query
     * constructor, and the component rendering callback, and implements the full
     * preExecution->block->render->postExecution->unblock lifecycle. This method
     * detects concurrent updates to the component and ensures that only one
     * redraw is performed.
     */
    triggerQuery: function(queryDef, callback, userQueryOptions) {
        if(!this.preExec()) {
            return;
        }
        var silent = this.isSilent();
        if (!silent){
            this.block();
        };
        userQueryOptions = userQueryOptions || {};
        /*
         * The query response handler should trigger the component-provided callback
         * and the postExec stage if the call wasn't skipped, and should always
         * unblock the UI
         */
        var success = _.bind(function(data) {
            callback(data);
            this.postExec();
        },this);
        var always = _.bind(function (){
            if (!silent){
                this.unblock();
            }
        }, this);
        var handler = this.getSuccessHandler(success, always),
                errorHandler = this.getErrorHandler();

        var query = this.queryState = this.query = Dashboards.getQuery( queryDef);
        var ajaxOptions = {
            async: true
        }
        if(userQueryOptions.ajax) {
            _.extend(ajaxOptions,userQueryOptions.ajax);
        }
        query.setAjaxOptions(ajaxOptions);
        if(userQueryOptions.pageSize){
            query.setPageSize(userQueryOptions.pageSize);
        }
        query.fetchData(this.parameters, handler, errorHandler);
    },

    /*
     * The triggerAjax method implements a lifecycle based on generic AJAX calls.
     * It implements the full preExecution->block->render->postExecution->unblock
     * lifecycle.
     *
     * triggerAjax can be used with either of the following call conventions:
     * - this.triggerAjax(url,params,callback);
     * - this.triggerAjax({url: url, data: params, ...},callback);
     * In the second case, you can add any other jQuery.Ajax parameters you desire
     * to the object, but triggerAjax will take control over the success and error
     * callbacks.
     */
    triggerAjax: function(url,params,callback) {
        if(!this.preExec()) {
            return;
        }
        var silent = this.isSilent();
        if (!silent){
            this.block();
        };
        var ajaxParameters = {
            async: true
        };
        /* Detect call convention used and adjust parameters */
        if (typeof callback != "function") {
            callback = params;
            _.extend(ajaxParameters,url);
        } else {
            _.extend(ajaxParameters,{
                url: url,
                data: params
            });
        }
        var success = _.bind(function(data){
            callback(data);
            this.trigger('cdf cdf:render',this,data);
            this.postExec();
        },this);
        var always = _.bind(function (){
            if (!silent){
                this.unblock();
            }
        }, this);
        ajaxParameters.success = this.getSuccessHandler(success,always);
        ajaxParameters.error = this.getErrorHandler();
        jQuery.ajax(ajaxParameters);
    },


    /*
     * Increment the call counter, so we can keep track of the order in which
     * requests were made.
     */
    callCounter: function() {
        return ++this.runCounter;
    },

    /* Trigger an error event on the component. Takes as arguments the error
     * message and, optionally, a `cause` object.
     * Also
     */
    error: function(msg, cause) {
        msg = msg || Dashboards.getErrorObj('COMPONENT_ERROR').msg;
        if (!this.isSilent()){
            this.unblock();
        };
        this.errorNotification({
            error: cause,
            msg: msg
        });
        this.trigger("cdf cdf:error", this, msg , cause || null);
    },
    /*
     * Build a generic response handler that runs the success callback when being
     * called in response to the most recent AJAX request that was triggered for
     * this component (as determined by comparing counter and this.runCounter),
     * and always calls the always callback. If the counter is not provided, it'll
     * be generated automatically.
     *
     * Accepts the following calling conventions:
     *
     * - this.getSuccessHandler(counter, success, always)
     * - this.getSuccessHandler(counter, success)
     * - this.getSuccessHandler(success, always)
     * - this.getSuccessHandler(success)
     */
    getSuccessHandler: function(counter,success,always) {

        if (arguments.length === 1) {
        /* getSuccessHandler(success) */
            success = counter;
            counter = this.callCounter();
        } else if (typeof counter == 'function') {
            /* getSuccessHandler(success,always) */
            always = success;
            success = counter;
            counter = this.callCounter();
        }
        return _.bind(function(data) {
                var newData;
                if(counter >= this.runCounter) {
                    try {
                        if(typeof this.postFetch == "function") {
                            newData = this.postFetch(data);
                            this.trigger('cdf cdf:postFetch',this,data);
                            data = typeof newData == "undefined" ? data : newData;
                        }
                        success(data);
                    } catch(e) {
                        this.error(Dashboards.getErrorObj('COMPONENT_ERROR').msg, e);
                        this.dashboard.log(e,"error");
                    }
                }
                if(typeof always == "function") {
                    always();
                }
        },
        this);
    },

    getErrorHandler: function() {
        return  _.bind(function() {
            var err = Dashboards.parseServerError.apply(this, arguments );
            this.error( err.msg, err.error );
        },
        this);
    },
    errorNotification: function (err, ph) {
        ph = ph || ( ( this.htmlObject ) ? $('#' + this.htmlObject) : undefined );
        var name = this.name.replace('render_', '');
        err.msg = err.msg + ' (' + name + ')';
        Dashboards.errorNotification( err, ph );
    },

    /*
     * Trigger UI blocking while the component is updating. Default implementation
     * uses the global CDF blockUI, but implementers are encouraged to override
     * with per-component blocking where appropriate (or no blocking at all in
     * components that support it!)
     */
    block: function() {
        if(!this.isRunning){
            this.dashboard.incrementRunningCalls();
            this.isRunning = true;
        }

    },

    /*
     * Trigger UI unblock when the component finishes updating. Functionality is
     * defined as undoing whatever was done in the block method. Should also be
     * overridden in components that override UnmanagedComponent#block.
     */
    unblock: function() {

        if(this.isRunning){
            this.dashboard.decrementRunningCalls();
            this.isRunning = false;
        }
    },

    isSilent: function (){
        return (this.lifecycle) ? !!this.lifecycle.silent : false;
    }
});

var FreeformComponent = UnmanagedComponent.extend({

    update: function() {
        var render = _.bind(this.render,this);
        if(typeof this.manageCallee == "undefined" || this.manageCallee) {
            this.synchronous(render);
        } else {
            render();
        }
    },

    render : function() {
        var parameters =this.parameters || [];
        this.customfunction(parameters);
    }
});

; /* ************************ new file ************************ */
var InputBaseComponent = UnmanagedComponent.extend({
    update: function(){
        var qd = this.queryDefinition;
        if(this.valuesArray && this.valuesArray.length > 0) {
            var handler = _.bind(function() {
                this.draw(this.valuesArray);
            },this);
            this.synchronous(handler);
        } else if(qd){
            var handler = _.bind(function(data){
                var filtered;
                if(this.valueAsId) {
                    filtered = data.resultset.map(function(e){
                        return [e[0],e[0]];
                    });
                } else {
                    filtered = data.resultset;
                }
                this.draw(filtered);
            },this);
            this.triggerQuery(qd,handler);
        } else {
            /* Legacy XAction-based components are a wasps' nest, so
             * we'll steer clearfrom updating those for the time being
             */
            var handler = _.bind(function() {
                var data = this.getValuesArray();
                this.draw(data);
            },this);
            this.synchronous(handler);

        }
    },

    // TODO: is the result of Dashoards.getParameterValue subject or not to HTML encoding?
    // Some controls in this file do html encode the result while others don't.

    /**
     * Obtains the value of this component's parameter.
     * <p>
     * If the parameter value is a function, the result of evaluating it is returned instead.
     * </p>
     * <p>
     * Normalizes return values by using {@link Dashboards.normalizeValue}.
     * </p>
     *
     * @return {*} the parameter value.
     */
    _getParameterValue: function() {
        return Dashboards.normalizeValue(
                        Dashboards.ev(
                            Dashboards.getParameterValue(this.parameter)));
    }
});


var SelectBaseComponent = InputBaseComponent.extend({
    visible: false,

    //defaultIfEmpty: [false]
    //isMultiple: [true]
    //size: when isMultiple==true, the default value is the number of possible values
    //externalPlugin:
    //extraOptions:
    //changeMode: ['immediate'], 'focus', 'timeout-focus'
    //changeTimeout: [2000], // in milliseconds
    //changeTimeoutScrollFraction: 1,
    //changeTimeoutChangeFraction: 5/8,
    //NOTE: changeMode 'timeout-focus' is not supported in mobile and fallsback to 'focus'

    draw: function(myArray) {
        var ph = $("#" + this.htmlObject);
        var name = this.name;

        // Build the HTML
        var selectHTML = "<select";

        var allowMultiple = this._allowMultipleValues();
        if(allowMultiple) { selectHTML += " multiple"; }

        var placeholderText = this._getPlaceholderText();
        if(placeholderText) { selectHTML += " data-placeholder='" + placeholderText + "'" ; }

        var size = this._getListSize(myArray);
        if(size != null) { selectHTML += " size='" + size + "'"; }

        var extPlugin = this.externalPlugin;
        switch(extPlugin) {
            case "chosen": selectHTML += " class='chzn-select'" ; break;
            case "hynds":  selectHTML += " class='hynds-select'"; break;
        }

        selectHTML += ">";

        // ------

        var currentVal  = this._getParameterValue();
        var currentVals = Dashboards.parseMultipleValues(currentVal); // may be null
        var valuesIndex = {};
        var firstVal;

        Dashboards.eachValuesArray(myArray, {valueAsId: this.valueAsId},
            function(value, label, id, index) {
                selectHTML += "<option value = '" + Dashboards.escapeHtml(value) + "' >" +
                                                Dashboards.escapeHtml(label) +
                                            "</option>";

                // For value validation, below
                if(!index) { firstVal = value; }
                valuesIndex[value] = true;
            },
            this);

        selectHTML += "</select>";
        ph.html(selectHTML);

        // ------

        // All current values valid?
        var currentIsValid = true;

        // Filter out invalid current values
        if(currentVals != null) {
            var i = currentVals.length;
            while(i--) {
                if(valuesIndex[currentVals[i]] !== true) {
                    // At least one invalid value
                    currentIsValid = false;
                    currentVals.splice(i, 1);
                }
            }
            if(!currentVals.length) { currentVals = null; }
        }

        /* If the current value for the parameter is invalid or empty,
         * we need to pick a sensible default.
         * If defaultIfEmpty is true, the first possible value is selected,
         * otherwise, nothing is selected.
         */
        var isEmpty    = currentVals == null;
        var hasChanged = !currentIsValid;
        if(isEmpty && this.defaultIfEmpty && firstVal != null) {
            // Won't remain empty
            currentVals = [firstVal];
            hasChanged = true;
        }


        // jQuery only cleans the value if it receives an empty array. 
        $("select", ph).val( (currentVals == null && []) || currentVals );

        if(hasChanged) {
            // TODO: couldn't we just call fireChange(this.parameter, currentVals) ?
            Dashboards.setParameter(this.parameter, currentVals);
            Dashboards.processChange(name);
        }

        // TODO: shouldn't this be called right after setting the value of select?
        // Before hasChanged firing?
        switch(extPlugin) {
            case "chosen": ph.find("select.chzn-select" ).chosen(this._readExtraOptions()); break;
            case "hynds":  ph.find("select.hynds-select").multiselect({multiple: allowMultiple}); break;
        }

        this._listenElement(ph);
    },

    /**
     * Indicates if the user can select multiple values.
     * The default implementation returns <tt>false</tt>.
     * @return {boolean}
     * @protected
     */
    _allowMultipleValues: function() {
        return false;
    },

    /**
     * Returns the placeholder label for empty values, or false if it is an non-empty String.
     * @protected
     */
    _getPlaceholderText: function() {
        var txt = this.placeholderText;
        return ( _.isString(txt) && !_.isEmpty(txt) && txt ) || false;
    },

    /**
     * The number of elements that the list should show
     * without scrolling.
     * The default implementation
     * returns the value of the {@link #size} property.
     *
     * @param {Array.<Array.<*>>} values the values array.
     * @return {?number}
     * @protected
     */
    _getListSize: function(values) {
        return this.size;
    },

    /**
     * Currently, reads extra options for the "chosen" plugin,
     * by transforming the array of key/value pair arrays
     * in {@link #extraOptions} into a JS object.
     *
     * @return {!Object.<string,*>} an options object.
     */
    _readExtraOptions: function() {
        if(this.externalPlugin && this.extraOptions) {
            return Dashboards.propertiesArrayToObject(this.extraOptions);
        }
    },

    /**
     * Installs listeners in the HTML element/object.
     * <p>
     *    The default implementation listens to the change event
     *    and dashboard-processes each change.
     * </p>
     * @param {!HTMLElement} elem the element.
     */
    _listenElement: function(elem) {
        var me = this;
        var prevValue = me.getValue();
        var stop;
        var check = function() {
            
            stop && stop();
            
            var currValue = me.getValue();
            if(!Dashboards.equalValues(prevValue, currValue)) {
                prevValue = currValue;
                Dashboards.processChange(me.name);
            }
        };
        
        var selElem = $("select", elem);
        
        selElem
                .keypress(function(ev) { if(ev.which === 13) { check(); } });

        var changeMode = this._getChangeMode();
        if(changeMode !== 'timeout-focus') {
            selElem
                .on(me._changeTrigger(), check);
        } else {
            
            var timScrollFraction = me.changeTimeoutScrollFraction;
            timScrollFraction = Math.max(0, timScrollFraction != null ? timScrollFraction : 1  );
            
            var timChangeFraction = me.changeTimeoutChangeFraction;
            timChangeFraction = Math.max(0, timChangeFraction != null ? timChangeFraction : 5/8);
            
            var changeTimeout = Math.max(100, me.changeTimeout || 2000);
            var changeTimeoutScroll = timScrollFraction * changeTimeout;
            var changeTimeoutChange = timChangeFraction * changeTimeout;
            
            var timeoutHandle;

            stop = function() {
                if(timeoutHandle != null) {
                    clearTimeout(timeoutHandle);
                    timeoutHandle = null;
                }
            };

            var renew = function(tim) {
                stop();
                timeoutHandle = setTimeout(check, tim || changeTimeout);
            };
            
            selElem
                .change(function() { renew(changeTimeoutChange); })
                .scroll(function() { renew(changeTimeoutScroll); })
                .focusout(check);
        }
    },

    /**
     * Obtains the change mode to use.
     * 
     * <p>
     * The default implementation normalizes, validates and defaults
     * the change mode value.
     * </p>
     *
     * @return {!string} one of values: 
     * <tt>'immediate'</tt>, 
     * <tt>'focus'</tt> or 
     * <tt>'timeout-focus'</tt>.
     */
    _getChangeMode: function() {
        var changeMode = this.changeMode;
        if(changeMode) {
            changeMode = changeMode.toLowerCase();
            switch(changeMode) {
                case 'immediate':
                case 'focus':  return changeMode;
                    
                case 'timeout-focus': 
                    // Mobiles do not support this strategy. Downgrade to 'focus'.
                    if((/android|ipad|iphone/i).test(navigator.userAgent)) { return 'focus'; }
                    return changeMode;

                default:
                    Dashboards.log("Invalid 'changeMode' value: '" + changeMode + "'.", 'warn');
            }
        }
        return 'immediate';
    },

    /**
     * Obtains an appropriate jQuery event name
     * for when testing for changes is done.
     * 
     * @return {!string} the name of the event.
     */
    _changeTrigger: function() {
        /**
         * <p>
         * Mobile user agents show a dialog/popup for choosing amongst possible values,
         * for both single and multi-selection selects.
         * </p>
         * <ul>
         *   <li>iPad/iPhone -
         *       the popup shows a button "OK" only when in multiple selection.
         *       As the user clicks on the items, "change" events are fired.
         *       A "focusout" event is fired when the user dismisses the popup
         *       (by clicking on the button or outside of the popup).
         *   </li>
         *   <li>Android -
         *       the popup shows a button "Done" whether in single or multiple selection.
         *       As the user clicks on the items no events are fired.
         *       A change event is fired (whether or not values actually changed),
         *       when the user dismisses the popup.
         *   </li>
         *   <li>Desktops -
         *       no popup is shown.
         *       As the user clicks on the items, "change" events are fired.
         *       A "focusout" event is fired when it should...
         *   </li>
         * </ul>
         *
         * | Change mode: | Immediate  | Focus    | Timeout-Focus |
         * +--------------+------------+----------+---------------+
         * | Desktop      | change     | focusout | focusout      |
         * | iPad         | change     | focusout | -             |
         * | Android      | change *   | change   | -             |
         *
         * (*) this is the most immediate that android can do
         *     resulting in Immediate = Focus
         *
         *  On mobile devices the Done/OK is equiparated with the
         *  behavior of focus out and of the ENTER key.
         */
        if(this._getChangeMode() === 'immediate') { return 'change'; }
        return (/android/i).test(navigator.userAgent) ? 'change' : 'focusout';
    }
});

var SelectComponent = SelectBaseComponent.extend({
    defaultIfEmpty: true,
    getValue : function() {
        return $("#"+this.htmlObject + " select").val();
    }
});

var SelectMultiComponent = SelectBaseComponent.extend({
    getValue : function() {
        var ph = $("#"+this.htmlObject + " select");
        var val = ph.val();
        return val == null ? [] : val;
    },


    /**
     * Obtains the normalized and defaulted value of
     * the {@link #isMultiple} option.
     * 
     * @override
     * @return {boolean}
     */
    _allowMultipleValues: function() {
        return this.isMultiple == null || !!this.isMultiple;
    },

    /**
     * When the size option is unspecified,
     * and multiple values are allowed,
     * returns the number of items in the
     * provided possible values list.
     * 
     * @override
     */
    _getListSize: function(values) {
        var size = this.base(values);
        if(size == null) {
            if(!this._allowMultipleValues()) {
                size = values.length;
            } // TODO: otherwise no default... Why?
        }

        return size;
    }
});


var TextInputComponent = BaseComponent.extend({
    update: function() {
        var name = this.name;
        var selectHTML = "<input type='text' id='" + name +
            "' name='"  + name +
            "' value='" + Dashboards.getParameterValue(this.parameter) +
            (this.size ? ("' size='" + this.size) : "") +
            (this.maxLength ? ("' maxlength='" + this.maxLength) : "") +
            "'>";

        $("#" + this.htmlObject).html(selectHTML);

        $("#" + name)
            .change(function() { Dashboards.processChange(name); })
            .keyup(function(ev) { if (ev.keyCode == 13) { Dashboards.processChange(name); } });
    },
    getValue : function() {
        return $("#"+this.name).val();
    }
});


var TextareaInputComponent = BaseComponent.extend({
    update: function() {
        var name = this.name;
        var selectHTML = "<textarea id='" + name +
            "' name='" + name +
            (this.numRows ? ("' rows='" + this.numRows) : "") +
            (this.numColumns ? ("' cols='" + this.numColumns) : "") +
            "'>" +
            Dashboards.getParameterValue(this.parameter) +
            '</textarea>';

        $("#" + this.htmlObject).html(selectHTML);

        $("#" + name)
            .change(function() { Dashboards.processChange(name); })
            .keyup(function(ev){ if (ev.keyCode == 13) { Dashboards.processChange(name); }
        });
    },
    getValue : function() {
        return $("#"+this.name).val();
    }
});



// Start by setting a sane i18n default to datepicker
//TODO: move this to where we know for sure datepicker is loaded..
if($.datepicker) {
    $(function(){$.datepicker.setDefaults($.datepicker.regional[''])});
}

var DateInputComponent = BaseComponent.extend({
    update: function(){
        var format = (this.dateFormat == undefined || this.dateFormat == null)? 'yy-mm-dd' : this.dateFormat;
        var myself = this;

        var startDate, endDate;

        if(this.startDate == 'TODAY') startDate = new Date();
        else if(this.startDate) startDate = $.datepicker.parseDate( format, this.startDate);

        if(this.endDate == 'TODAY') endDate = new Date();
        else if(this.endDate) endDate = $.datepicker.parseDate( format, this.endDate);

        //ToDo: stretch interval to catch defaultValue?..
        //Dashboards.getParameterValue(this.parameter))

        $("#" + this.htmlObject).html($("<input/>").attr("id", this.name).attr("value", Dashboards.getParameterValue(this.parameter)).css("width", "80px"));
        $(function(){
            $("#" + myself.htmlObject + " input").datepicker({
                dateFormat: format,
                changeMonth: true,
                changeYear: true,
                minDate: startDate,
                maxDate: endDate,
                onSelect: function(date, input){
                    Dashboards.processChange(myself.name);
                }
            });
            // Add JQuery DatePicker standard localization support only if the dashboard is localized
            if (typeof Dashboards.i18nSupport !== "undefined" && Dashboards.i18nSupport != null) {
                var $input = $("#" + myself.htmlObject + " input");

                $input.datepicker('option', $.datepicker.regional[Dashboards.i18nCurrentLanguageCode]);


                //Setup alt field and format to keep iso format
                $input.parent().append($('<hidden>').attr("id", myself.name + "_hidden"));
                $input.datepicker("option", "altField", "#" + myself.name + "_hidden" );
                $input.datepicker("option", "altFormat", format );
            }
        });
    },
    getValue : function() {
        if (typeof Dashboards.i18nSupport !== "undefined" && Dashboards.i18nSupport != null)
                return $("#" + this.name + "_hidden").val();
        else
                return $("#"+this.name).val();
    }
});


var DateRangeInputComponent = BaseComponent.extend({
    update : function() {
        var dr;
        if (this.singleInput == undefined || this.singleInput == true){
            dr = $("<input/>").attr("id",this.name).attr("value",Dashboards.getParameterValue(this.parameter[0]) + " > " + Dashboards.getParameterValue(this.parameter[1]) ).css("width","170px");
            $("#"+this.htmlObject).html(dr);
        } else {
            dr = $("<input/>").attr("id",this.name).attr("value",Dashboards.getParameterValue(this.parameter[0])).css("width","80px");
            $("#"+this.htmlObject).html(dr);
            dr.after($("<input/>").attr("id",this.name + "2").attr("value",Dashboards.getParameterValue(this.parameter[1])).css("width","80px"));
            if(this.inputSeparator != undefined){
                dr.after(this.inputSeparator);
            }
        }
        var offset = dr.offset();
        var myself = this;
        var earliestDate = this.earliestDate != undefined  ?  this.earliestDate : Date.parse('-1years');
        var latestDate = this.latestDate != undefined  ?  this.latestDate : Date.parse('+1years');
        var leftOffset = this.leftOffset != undefined ?  this.leftOffset : 0;
        var topOffset = this.topOffset != undefined ?  this.topOffset : 15;

        var changed, closed;
        function triggerWhenDone() {
            if(changed && closed) {
                myself.fireInputChange(myself.startValue,myself.endValue);
                changed = closed = false;
            }
        };

        var format = (myself.dateFormat == undefined || myself.dateFormat == null)? 'yy-mm-dd' : myself.dateFormat;

        $(function(){
            $("#" + myself.htmlObject + " input").daterangepicker({
                posX: offset.left + leftOffset,
                posY: offset.top + topOffset,
                earliestDate: earliestDate,
                latestDate: latestDate,
                dateFormat: format,
                onOpen: function() {
                    changed = closed = false;
                    myself.startValue = null;
                    myself.endValue = null;
                },
                onDateSelect: function(rangeA, rangeB) {
                    changed = true;
                    myself.storeChanges(rangeA, rangeB);
                    triggerWhenDone();
                },
                onClose: function() {
                    closed = true;
                    triggerWhenDone();
                }
            });
        });
    },

    fireInputChange : function(start, end){
        //TODO: review this!
        if(this.preChange){
            this.preChange(start, end);
        }

        if(this.parameter)
        {
            if( this.parameter.length == 2) Dashboards.setParameter(this.parameter[1], end);
            if( this.parameter.length > 0) Dashboards.fireChange(this.parameter[0], start);
        }

        if(this.postChange){
            this.postChange(start, end);
        }
    },

    storeChanges : function(start,end){
        this.startValue = start;
        this.endValue = end;
    }
},
{
    fireDateRangeInputChange : function(name, rangeA, rangeB){
        // WPG: can we just use the parameter directly?
        var object = Dashboards.getComponentByName(name);
        if(!(typeof(object.preChange)=='undefined')){
            object.preChange(rangeA, rangeB);
        }
        var parameters = eval(name + ".parameter");
        // set the second date and fireChange the first
        Dashboards.setParameter(parameters[1], rangeB);
        Dashboards.fireChange(parameters[0],rangeA);
        if(!(typeof(object.postChange)=='undefined')){
            object.postChange(rangeA, rangeB);
        }
    }
}
);

var MonthPickerComponent = BaseComponent.extend({
    update : function() {
        var selectHTML = this.getMonthPicker(this.name, this.size, this.initialDate, this.minDate, this.maxDate, this.months);
        $("#" + this.htmlObject).html(selectHTML);
        var myself = this;
        $("#"+this.name).change(function() {
            Dashboards.processChange(myself.name);
        });
    },
    getValue : function() {
        var value = $("#" + this.name).val();

        var year = value.substring(0,4);
        var month = parseInt(value.substring(5,7) - 1);
        var d = new Date(year,month,1);

        // rebuild picker
        var selectHTML = this.getMonthPicker(this.name, this.size, d, this.minDate, this.maxDate, this.months);
        $("#" + this.htmlObject).html(selectHTML);
        var myself = this;
        $("#"+this.name).change(function() {
            Dashboards.processChange(myself.name);
        });
        return value;
    },parseDate : function(aDateString){
        //This works assuming the Date comes in this format -> yyyy-mm-dd or yyyy-mm
        //Date.UTC(year[year after 1900],month[0 to 11],day[1 to 31], hours[0 to 23], min[0 to 59], sec[0 to 59], ms[0 to 999])
        var parsedDate = null;
        var yearIndex = 0, monthIndex = 1, dayindex = 2;
        var split = aDateString.split("-");
        var year, month, day;

        if(split.length == 3){
            year = parseInt(split[yearIndex]);
            month = parseInt(split[monthIndex]);
            day = parseInt(split[dayindex]);
            parsedDate = new Date(Date.UTC(year,(month-1),day));
        }else if(split.length == 2){
            year = parseInt(split[yearIndex]);
            month = parseInt(split[monthIndex]);
            parsedDate = new Date(Date.UTC(year,(month-1)));
        }

        return parsedDate;
    },getMonthsAppart : function(aDateOne, aDateTwo){
        var min, max;
        if(aDateOne < aDateTwo){
            min = aDateOne;
            max = aDateTwo;
        }else{
            min = aDateTwo;
            max = aDateOne;
        }

        var yearsAppart = (max.getFullYear() - min.getFullYear());
        var monthsToAdd = yearsAppart * 12;
        var monthCount = (max.getMonth() - min.getMonth()) + monthsToAdd; //TODO verify this calculation
        
        return monthCount;
    },normalizeDateToCompare : function(dateObject){
        var normalizedDate = dateObject;
        normalizedDate.setDate(1);
        normalizedDate.setHours(0);
        normalizedDate.setMinutes(0);
        normalizedDate.setSeconds(0);
        normalizedDate.setMilliseconds(0);

        return normalizedDate;

    },getMonthPicker : function(object_name, object_size, initialDate, minDate, maxDate, monthCount) {


        var selectHTML = "<select";
        selectHTML += " id='" + object_name + "'";

        if(initialDate == undefined || initialDate == null){
            initialDate = new Date();
        }
        if (minDate == undefined || minDate == null){
            minDate = new Date();
            minDate.setYear(1980);
        }
        if (maxDate == undefined || maxDate == null){
            maxDate = new Date();
            maxDate.setYear(2060);
        }

        //if any of the dates comes in string format this will parse them
        if(typeof initialDate === "string"){
            initialDate = this.parseDate(initialDate);
        }
        if(typeof minDate === "string"){
            minDate = this.parseDate(minDate);
        }
        if(typeof maxDate === "string"){
            maxDate = this.parseDate(maxDate);
        }

        // if monthCount is not defined we'll use everything between max and mindate
        var monthCountUndefined = false;
        if(monthCount == undefined || monthCount == 0) {
            monthCount = this.getMonthsAppart(minDate,maxDate);
            monthCountUndefined = true;
        }

        //set size
        if (object_size != undefined){
            selectHTML += " size='" + object_size + "'";
        }
        selectHTML += '>';

        var currentDate = new Date(+initialDate);

        /*
        * This block is to make sure the months are compared equally. A millisecond can ruin the comparation.
        */

            if(monthCountUndefined == true){
                currentDate.setMonth(currentDate.getMonth() - (this.getMonthsAppart(minDate,currentDate)) - 1);
            }else{
                currentDate.setMonth(currentDate.getMonth() - (monthCount/2) - 1);
            }
        currentDate = this.normalizeDateToCompare(currentDate);
        var normalizedMinDate = this.normalizeDateToCompare(minDate);
        var normalizedMaxDate = this.normalizeDateToCompare(maxDate);

        for(var i= 0; i <= monthCount; i++){
            
            currentDate.setMonth(currentDate.getMonth() + 1);

            if(currentDate >= normalizedMinDate && currentDate <= normalizedMaxDate)
            {
                selectHTML += "<option value = '" + currentDate.getFullYear() + "-" + this.zeroPad((currentDate.getMonth()+1),2) + "' ";

                if(currentDate.getFullYear() == initialDate.getFullYear() && currentDate.getMonth() == initialDate.getMonth()){
                    selectHTML += "selected='selected'"
                }

                selectHTML += ">" + Dashboards.monthNames[currentDate.getMonth()] + " " +currentDate.getFullYear()  + "</option>";
            }
        }

        selectHTML += "</select>";

        return selectHTML;
    },
    zeroPad : function(num,size) {
        var n = "00000000000000" + num;
        return n.substring(n.length-size,n.length);
    }
});

var ToggleButtonBaseComponent = InputBaseComponent.extend({
    draw: function(myArray){

        var selectHTML = "";

        //default
        var currentVal = Dashboards.getParameterValue(this.parameter);
        currentVal = (typeof currentVal == 'function') ? currentVal() : currentVal;

        var isSelected = false;

        var currentValArray = [];
        if(currentVal instanceof Array || (typeof(currentVal) == "object" && currentVal.join)) {
            currentValArray = currentVal;
        } else if(typeof(currentVal) == "string"){
            currentValArray = currentVal.split("|");
        }

        // check to see if current selected values are in the current values array. If not check to see if we should default to the first
        var vid = this.valueAsId==false?0:1;
        var hasCurrentVal = false;
            outer:
            for(var i = 0; i < currentValArray.length; i++){
                for(var y = 0; y < myArray.length; y++) {
                    if (currentValArray[i] == myArray[y][vid]) {
                        hasCurrentVal = true;
                        break outer;
                    }
                }
            }
        // if there will be no selected value, but we're to default if empty, select the first
        if(!hasCurrentVal && this.defaultIfEmpty){
            currentValArray = [myArray[0][vid]];

            this.currentVal = currentValArray;
            Dashboards.setParameter(this.parameter,currentValArray);
            Dashboards.processChange(this.name);
        }
        // (currentValArray == null && this.defaultIfEmpty)? firstVal : null


        selectHTML += "<ul class='"+ ((this.verticalOrientation)? "toggleGroup vertical":"toggleGroup horizontal")+"'>"
        for (var i = 0, len = myArray.length; i < len; i++) {
            selectHTML += "<li class='"+ ((this.verticalOrientation)? "toggleGroup vertical":"toggleGroup horizontal")+"'><label><input onclick='ToggleButtonBaseComponent.prototype.callAjaxAfterRender(\"" + this.name + "\")'";

            isSelected = false;
            for (var j = 0, valLength = currentValArray.length; j < valLength; j++) {
                isSelected = currentValArray[j] == myArray[i][vid];
                if(isSelected) {
                    break;
                }
            }

            if (this.type == 'radio' || this.type == 'radioComponent'){
                if ((i == 0 && !hasCurrentVal) ||
                    (hasCurrentVal && (myArray[i][vid] == currentVal ))) {
                    selectHTML += " CHECKED";
                }
                selectHTML += " type='radio'";
            }else{
                if ((i == 0 && !hasCurrentVal && this.defaultIfEmpty) ||
                    (hasCurrentVal && isSelected)) {
                    selectHTML += " CHECKED";
                }
                selectHTML += " type='checkbox'";
            }
            selectHTML += "class='" + this.name +"' name='" + this.name +"' value='" + myArray[i][vid] + "' /> " + myArray[i][1] + "</label></li>" + ((this.separator == undefined || this.separator == null || this.separator == "null")?"":this.separator);
        }
        selectHTML += "</ul>"
        // update the placeholder
        $("#" + this.htmlObject).html(selectHTML);
        this.currentVal = null;
    },
    callAjaxAfterRender: function(name){
        setTimeout(function(){
            Dashboards.processChange(name)
        },1);
    }
});

var RadioComponent = ToggleButtonBaseComponent.extend({
    getValue : function() {
        if (this.currentVal != 'undefined' && this.currentVal != null) {
            return this.currentVal;
        } else {
            return $("#"+this.htmlObject + " ."+this.name+":checked").val()
        }
    }
});

var CheckComponent = ToggleButtonBaseComponent.extend({
    getValue : function() {
        if (this.currentVal != 'undefined' && this.currentVal != null) {
            return this.currentVal;
        } else {
            var a = new Array()
            $("#"+this.htmlObject + " ."+this.name + ":checked").each(function(i,val){
                a.push($(this).val());
            });
            return a;
        }
    }
});

var MultiButtonComponent = ToggleButtonBaseComponent.extend({
    indexes: [],//used as static
    draw: function(myArray){
        this.cachedArray = myArray;
        var cssWrapperClass= "pentaho-toggle-button pentaho-toggle-button-up "+ ((this.verticalOrientation)? "pentaho-toggle-button-vertical" : "pentaho-toggle-button-horizontal");
        var selectHTML = "";
        var firstVal;

        var valIdx = this.valueAsId ? 1 : 0;
        var lblIdx = 1;

        if (this.isMultiple == undefined) this.isMultiple = false;

        var ph = $("<div>");
        ph.appendTo($("#" + this.htmlObject).empty());
        for (var i = 0, len = myArray.length; i < len; i++){
            var value = myArray[i][valIdx],
                label = myArray[i][lblIdx],
                classes = cssWrapperClass + this.getExtraCss(i,len,this.verticalOrientation),
                selector;

            value = (value == null ? null : value.replace('"','&quot;' ));
            label = (label == null ? null : label.replace('"','&quot;' ));

            if(i == 0){
                firstVal = value;
            }

            selectHTML = "<div class='" + classes +"'><button name='" + this.name + "'>" + label + "</button  >" +"</div>";
            selector = $(selectHTML);
            // We wrap the click handler in a self-executing function so that we can capture 'i'.
            var myself = this;
            (function(index){ selector.click(function(){
                MultiButtonComponent.prototype.clickButton(myself.htmlObject, myself.name, index, myself.isMultiple, myself.verticalOrientation);
            });}(i));
            ph.append(selector);
            if (!(this.separator == undefined || this.separator == null || this.separator == "null") && i != myArray.length - 1) {
                ph.append(this.separator);
            }
        }


        //default
        var currentVal = Dashboards.ev(Dashboards.getParameterValue(this.parameter));

        var isSelected = false;

        var currentValArray;
        if(currentVal == null) {
            currentValArray = [];
        } else if(currentVal instanceof Array || (typeof(currentVal) == "object" && currentVal.join)) {
            currentValArray = currentVal;
        } else {
            currentValArray = currentVal.toString().split("|");
        }

        var foundDefault = false;
        this.clearSelections(this.htmlObject, this.name, this.verticalOrientation);
        for (var i = 0; i < myArray.length; i++) {

            isSelected = false;
            for (var j = 0, valLength = currentValArray.length; j < valLength; j++) {
                isSelected = currentValArray[j] == myArray[i][valIdx];
                if(isSelected) {
                    break;
                }
            }


            if ( ( $.isArray(currentVal) && isSelected || isSelected)
                || (myArray[i][valIdx] == currentVal || myArray[i][lblIdx] == currentVal) ) {

                MultiButtonComponent.prototype.clickButton(this.htmlObject, this.name, i, this.isMultiple, this.verticalOrientation, true);

                foundDefault = true;
                if(!this.isMultiple) {
                    break;
                }
            }
        }
        if(((!foundDefault && !this.isMultiple) || (!foundDefault && this.isMultiple && this.defaultIfEmpty)) && myArray.length > 0){
            //select first value
            if((currentVal == null || currentVal == "" || (typeof(currentVal) == "object" && currentVal.length == 0)) && this.parameter){
                Dashboards.fireChange(this.parameter, (this.isMultiple) ? [firstVal] : firstVal);
            }

            MultiButtonComponent.prototype.clickButton(this.htmlObject, this.name, 0, this.isMultiple, this.verticalOrientation, true);
        }

        // set up hovering
        $(".pentaho-toggle-button").hover(function() {
            $(this).addClass("pentaho-toggle-button-up-hovering");
        }, function() {
            $(this).removeClass("pentaho-toggle-button-up-hovering");
        });
        // set up hovering when inner button is hovered
        $(".pentaho-toggle-button button").hover(function() {
            $(this).parent().addClass("pentaho-toggle-button-up-hovering");
        }, function() {
            // don't remove it, since it's inside the outer div it will handle that
        });

    },

    getValue: function(){
        if(this.isMultiple){
            var indexes = MultiButtonComponent.prototype.getSelectedIndex(this.name);
            var a = new Array();
            // if it is not an array, handle that too
            if (indexes.length == undefined) {
                a.push(this.getValueByIdx(indexes));
            } else {
                for(var i=0; i < indexes.length; i++){
                    a.push(this.getValueByIdx(indexes[i]));
                }
            }
            return a;
        }
        else {
            return this.getValueByIdx(MultiButtonComponent.prototype.getSelectedIndex(this.name));
        }
    },

    getValueByIdx: function(idx){
        return this.cachedArray[idx][this.valueAsId ? 1 : 0];
    },

    getSelecetedCss: function(verticalOrientation) {
        return "pentaho-toggle-button pentaho-toggle-button-down "+ ((verticalOrientation)? "pentaho-toggle-button-vertical" : "pentaho-toggle-button-horizontal");
    },
    getUnselectedCss: function(verticalOrientation) {
        return "pentaho-toggle-button pentaho-toggle-button-up "+ ((verticalOrientation)? "pentaho-toggle-button-vertical" : "pentaho-toggle-button-horizontal");
    },

    //static MultiButtonComponent.prototype.clickButton
    // This method should be broken up so the UI state code is reusable outside of event processing
    clickButton: function(htmlObject, name, index, isMultiple, verticalOrientation, updateUIOnly){

        var cssWrapperClass= this.getUnselectedCss(verticalOrientation);
        var cssWrapperClassSelected= this.getSelecetedCss(verticalOrientation);

        var buttons = $("#" + htmlObject + " button");
        if (isMultiple) {//toggle button
            if (this.indexes[name] == undefined) this.indexes[name] = [];
            else if(!$.isArray(this.indexes[name])) this.indexes[name] = [this.indexes[name]];//!isMultiple->isMultiple

            var disable = false;
            for (var i = 0; i < this.indexes[name].length; ++i) {
                if (this.indexes[name][i] == index) {
                    disable = true;
                    this.indexes[name].splice(i, 1);
                    break;
                }
            }
            if (disable){
                buttons[index].parentNode.className = cssWrapperClass + this.getExtraCss(index,buttons.length,verticalOrientation);
            } else {
                buttons[index].parentNode.className = cssWrapperClassSelected + this.getExtraCss(index,buttons.length,verticalOrientation);
                this.indexes[name].push(index);
            }
        }
        else {//de-select old, select new
            this.clearSelections(htmlObject, name, verticalOrientation);
            this.indexes[name] = index;
            buttons[index].parentNode.className = cssWrapperClassSelected + this.getExtraCss(index,buttons.length,verticalOrientation);
        }
        if(!updateUIOnly){
            this.callAjaxAfterRender(name);
        }
    },

    clearSelections: function(htmlObject, name, verticalOrientation) {
        var buttons = $("#" + htmlObject + " button");
        var cssWrapperClass = this.getUnselectedCss(verticalOrientation);
        for(var i = 0; i < buttons.length; i++){
            buttons[i].parentNode.className = cssWrapperClass + this.getExtraCss(i,buttons.length,verticalOrientation);
        }

        this.indexes[name] = [];
    },

    getExtraCss: function(index, count, verticalOrientation) {
        var css = "";
        if (index == 0 && count == 1) {
            // both first & last
            return " pentaho-toggle-button-single";
        }
        if (index == 0) {
            css += " "+ ((verticalOrientation) ? " pentaho-toggle-button-vertical-first" : " pentaho-toggle-button-horizontal-first");
        } else if (index == count-1) {
            css += " "+ ((verticalOrientation) ? " pentaho-toggle-button-vertical-last" : " pentaho-toggle-button-horizontal-last");
        }
        return css;
    },

    //static MultiButtonComponent.prototype.getSelectedIndex
    getSelectedIndex: function(name){
        return this.indexes[name];
    }
});

var AutocompleteBoxComponent = BaseComponent.extend({

    searchedWord : '',
    result: [],

    queryServer : function(searchString){

        if(!this.parameters) this.parameters = [];

        if(this.searchParam){
            this.parameters = [ [this.searchParam, this.getInnerParameterName()] ];
        }
        else if (this.parameters.length > 0){
            this.parameters[0][1] = this.getInnerParameterName();
        }

        if(this.maxResults){
            this.queryDefinition.pageSize = this.maxResults;
        }
        Dashboards.setParameter(this.getInnerParameterName(),this.getTextBoxValue());
        QueryComponent.makeQuery(this);
    },

    getTextBoxValue: function(){
        return this.textbox.val();
    },

    getInnerParameterName : function(){
        return this.parameter + '_textboxValue';
    },

    update : function() {

        $("#"+ this.htmlObject).empty();

        var initialValue = null;
        if(this.parameter){
            initialValue = Dashboards.getParameterValue(this.parameter);
        }

        var myself = this;

        //init parameter
        // TODO: FIXME: dcl - Isn't the following
        // this.getInnerParameterName missing parentesis?
        if(!Dashboards.getParameterValue(this.getInnerParameterName)){
            Dashboards.setParameter(this.getInnerParameterName(), '' );
        }

        var processChange = myself.processChange == undefined ? function(objName){
            Dashboards.processChange(objName);
        } : function(objName) {
            myself.processChange();
        };
        var processElementChange = myself.processElementChange == true ? function(value){
            Dashboards.fireChange(myself.parameter,value);
        } : undefined;

        //TODO:typo on minTextLength
        if(this.minTextLenght == undefined){
            this.minTextLenght = 0;
        }

        var opt = {
            list: function(){
                var val = myself.textbox.val();
                if(val.length >= myself.minTextLenght &&
                     !(val == '' //nothing to search
                         ||
                         val == myself.searchedWord
                         ||
                        ((myself.queryInfo != null && myself.result.length == myself.queryInfo.totalRows) && //has all results
                         myself.searchedWord != '' &&
                         ((myself.matchType == "fromStart")?
                                val.indexOf(myself.searchedWord) == 0 :
                                val.indexOf(myself.searchedWord) > -1)))) //searchable in local results
                {
                    myself.queryServer(val);
                    myself.searchedWord = val;
                }
                var list = [];
                for(p in myself.result) if (myself.result.hasOwnProperty(p)){
                    var obj = {};
                    obj.text = myself.result[p][0];
                    list.push(obj);
                }
                return list;
            },
            matchType: myself.matchType == undefined ? "fromStart" : myself.matchType, /*fromStart,all*/
            processElementChange:  processElementChange,
            processChange: function(obj,value) {
                obj.value = value;
                processChange(obj.name);
            },
            multiSelection: myself.selectMulti == undefined ? false : myself.selectMulti,
            checkValue: myself.checkValue == undefined ? true : myself.checkValue,
            minTextLenght: myself.minTextLenght == undefined ? 0 : myself.minTextLenght,
            scrollHeight: myself.scrollHeight,
            applyButton: myself.showApplyButton == undefined ? true : myself.showApplyButton,
            tooltipMessage: myself.tooltipMessage == undefined ? "Click it to Apply" : myself.tooltipMessage,
            addTextElements: myself.addTextElements == undefined ? true : myself.addTextElements,
            externalApplyButtonId: myself.externalApplyButtonId,
    //    selectedValues: initialValue,
            parent: myself
        };


        this.autoBoxOpt = $("#" + this.htmlObject ).autobox(opt);

        //setInitialValue
        this.autoBoxOpt.setInitialValue(this.htmlObject, initialValue, this.name);

        this.textbox = $('#' + this.htmlObject + ' input');
    },
    getValue : function() {
        return this.value;
    },
    processAutoBoxChange : function() {
        this.autoBoxOpt.processAutoBoxChange();
    }
});

var ButtonComponent = BaseComponent.extend({
    update : function() {
        var myself = this;
        var b = $("<button type='button'/>").text(this.label).unbind("click").bind("click", function(){
                return myself.expression.apply(myself,arguments);
        });
        if (typeof this.buttonStyle === "undefined" || this.buttonStyle === "themeroller")
            b.button();
        b.appendTo($("#"+ this.htmlObject).empty());
    }
});
; /* ************************ new file ************************ */
/*
 * Function: fnLengthChange
 * Purpose:  Change the number of records on display
 * Returns:  array:
 * Inputs:   object:oSettings - DataTables settings object
 *           int:iDisplay - New display length
 */
 // Ensure we load dataTables before this line. If not, just keep going
if($.fn.dataTableExt != undefined){
    $.fn.dataTableExt.oApi.fnLengthChange = function ( oSettings, iDisplay )
    {
        oSettings._iDisplayLength = iDisplay;
        oSettings.oApi._fnCalculateEnd( oSettings );

        // If we have space to show extra rows backing up from the end point - then do so
        if ( oSettings._iDisplayEnd == oSettings.aiDisplay.length )
        {
            oSettings._iDisplayStart = oSettings._iDisplayEnd - oSettings._iDisplayLength;
            if ( oSettings._iDisplayStart < 0 )
            {
                oSettings._iDisplayStart = 0;
            }
        }

        if ( oSettings._iDisplayLength == -1 )
        {
            oSettings._iDisplayStart = 0;
        }

        oSettings.oApi._fnDraw( oSettings );

        $('select', oSettings.oFeatures.l).val( iDisplay );
    };
/* Example
 * $(document).ready(function() {
 *    var oTable = $('#example').dataTable();
 *    oTable.fnLengthChange( 100 );
 * } );
 */
}

var TableComponent = UnmanagedComponent.extend({
    
    ph: undefined,
    

    update: function() {
        if(!this.preExec()){
            return;
        }
        if(!this.htmlObject) {
            return this.error("TableComponent requires an htmlObject");
        }
        try{
            this.block();
            this.setup();
            if(this.chartDefinition.paginateServerside) {
                this.paginatingUpdate();
            } else {
                /* The non-paging query handler only needs to concern itself
                 * with handling postFetch and calling the draw function
                 */
                var success = _.bind(function(data){
                    this.rawData = data;
                    this.processTableComponentResponse(data)
                },this);
                var handler = this.getSuccessHandler(success);

                this.queryState.setAjaxOptions({async:true});
                this.queryState.fetchData(this.parameters, handler);
            }
        } catch (e) {
            /*
             * Something went wrong and we won't have handlers firing in the future
             * that will trigger unblock, meaning we need to trigger unblock manually.
             */
            this.dashboard.error(e);
            this.unblock();
        }
    },
    
    paginatingUpdate: function() {
        var cd = this.chartDefinition;
        this.extraOptions = this.extraOptions || [];
        this.extraOptions.push(["bServerSide",true]);
        this.extraOptions.push(["bProcessing",true]);
        this.queryState.setPageSize(parseInt(cd.displayLength || 10));
        this.queryState.setCallback(_.bind(function(values) {
            changedValues = undefined;
            if((typeof(this.postFetch)=='function')){
                changedValues = this.postFetch(values);
            }
            if (changedValues != undefined) {
                values = changedValues;
            }
            this.processTableComponentResponse(values);
        },this));
        this.queryState.setParameters(this.parameters);
        this.queryState.setAjaxOptions({async:true});
        this.processTableComponentResponse();
     },

    /* Initial setup: clearing out the htmlObject and building the query object */
    setup: function() {
        var cd = this.chartDefinition;
        if (cd == undefined){
            Dashboards.log("Fatal - No chart definition passed","error");
            return;
        }
        cd["tableId"] = this.htmlObject + "Table";

        // Clear previous table
        this.ph = $("#"+this.htmlObject).empty();
        // remove drawCallback from the parameters, or
        // it'll be called before we have an actual table...
        var croppedCd = $.extend({},cd);
        croppedCd.drawCallback = undefined;
        this.queryState = Dashboards.getQuery(croppedCd);
        this.query = this.queryState; // for analogy with ccc component's name
        // make sure to clean sort options
        var sortBy = this.chartDefinition.sortBy || [],
            sortOptions = [];
        for (var i = 0; i < sortBy.length; i++) {
            var col = sortBy[i][0];
            var dir = sortBy[i][1];
            sortOptions.push( col + (dir == "asc" ? "A" : "D"));
        }
        this.queryState.setSortBy(sortOptions);
    },

    pagingCallback: function(url, params,callback,dataTable) {
        function p( sKey ) {
            for ( var i=0, iLen=params.length ; i<iLen ; i++ ) {
                if ( params[i].name == sKey ) {
                    return params[i].value;
                }
            }
            return null;
        }
        var sortingCols = p("iSortingCols"),sort = [];
        if (sortingCols > 0) {
            for (var i = 0; i < sortingCols; i++) {
                var col = p("iSortCol_" + i);
                var dir = p("sSortDir_" + i);
                sort.push( col + (dir == "asc" ? "A" : "D"));
            }
        }
        var query = this.queryState,
        myself = this;
        query.setSortBy(sort.join(","));
        query.setPageSize(parseInt(p("iDisplayLength")));
        query.setPageStartingAt(p("iDisplayStart"));
        query.setSearchPattern(p("sSearch") ? p("sSearch") : "");
        query.fetchData(function(d) {
            if (myself.postFetch){
                var mod = myself.postFetch(d,dataTable);
                if (typeof mod !== "undefined") {
                    d = mod;
                }
            }
            var response = {
                iTotalRecords: d.queryInfo.totalRows,
                iTotalDisplayRecords: d.queryInfo.totalRows
                };
            response.aaData = d.resultset;
            response.sEcho = p("sEcho");
            myself.rawData = d;
            callback(response);
        });
    },
    
    /* 
     * Callback for when the table is finished drawing. Called every time there
     * is a redraw event (so not only updates, but also pagination and sorting).
     * We handle addIns and such things in here.
     */
    fnDrawCallback: function(dataTableSettings) {
        var dataTable = dataTableSettings.oInstance,
                cd = this.chartDefinition,
                myself = this,
                handleAddIns = _.bind(this.handleAddIns,this);
        this.ph.find("tbody tr").each(function(row,tr){
            /* 
             * Reject rows that are not actually part
             * of the datatable (e.g. nested tables)
             */
            if (dataTable.fnGetPosition(tr) == null) {
                return true;
            }

            $(tr).children("td").each(function(col,td){

                    var foundAddIn = handleAddIns(dataTable, td);
                    /* 
                     * Process column format for those columns
                     * where we didn't find a matching addIn
                     */
                    if(!foundAddIn && cd.colFormats) {
                        var position = dataTable.fnGetPosition(td),
                                rowIdx = position[0],
                                colIdx = position[2],
                                format = cd.colFormats[colIdx],
                                value = myself.rawData.resultset[rowIdx][colIdx];
                        if (format && (typeof value != "undefined" && value !== null)) {
                            $(td).text(sprintf(format,value));
                        }
                    }
            });
        });

        /* Old urlTemplate code. This needs to be here for backward compatibility */
        if(cd.urlTemplate != undefined){
            var td =$("#" + myself.htmlObject + " td:nth-child(1)"); 
            td.addClass('cdfClickable');
            td.bind("click", function(e){
                    var regex = new RegExp("{"+cd.parameterName+"}","g");
                    var f = cd.urlTemplate.replace(regex,$(this).text());
                    eval(f);
                    });
        }
        /* Handle post-draw callback the user might have provided */
        if(typeof cd.drawCallback == 'function'){
            cd.drawCallback.apply(myself,arguments);
        }
    },

    /* 
     * Handler for when the table finishes initialising. This only happens once,
     * when the table *initialises* ,as opposed to every time the table is drawn,
     * so it provides us with a good place to add the postExec callback.
     */
    fnInitComplete: function() {
        this.postExec();
        this.unblock();
    },

    /* 
     * Resolve and call addIns for the given td in the context of the given 
     * dataTable. Returns true if there was an addIn and it was successfully
     * called, or false otherwise.
     */
    handleAddIns: function(dataTable, td) {
        var cd = this.chartDefinition,
                position = dataTable.fnGetPosition(td),
                rowIdx = position[0],
                colIdx = position[2],
                colType = cd.colTypes[colIdx],
                addIn = this.getAddIn("colType",colType),
                state = {},
                target = $(td),
                results = this.rawData;
        if (!addIn) {
            return false;
        }
        try {
            if(!(target.parents('tbody').length)) {
                return;
            } else if (target.get(0).tagName != 'TD') {
                target = target.closest('td');
            }
            state.rawData = results;
            state.tableData = dataTable.fnGetData();
            state.colIdx = colIdx;
            state.rowIdx = rowIdx;
            state.series = results.resultset[state.rowIdx][0];
            state.category = results.metadata[state.colIdx].colName;
            state.value =  results.resultset[state.rowIdx][state.colIdx];
            if(cd.colFormats) {
                state.colFormat = cd.colFormats[state.colIdx];
            }
            state.target = target;
            addIn.call(td,state,this.getAddInOptions("colType",addIn.getName()));
            return true;
        } catch (e) {
            this.dashboard.error(e);
            return false;
        }
    },

    processTableComponentResponse : function(json) {
        var myself = this,
                cd = this.chartDefinition,
                extraOptions = {};

        this.ph.trigger('cdfTableComponentProcessResponse');

        // Set defaults for headers / types
        if(typeof cd.colHeaders === "undefined" || cd.colHeaders.length == 0)
            cd.colHeaders = json.metadata.map(function(i){return i.colName});

        if(typeof cd.colTypes === "undefined" || cd.colTypes.length == 0)
            cd.colTypes = json.metadata.map(function(i){return i.colType.toLowerCase()});

        var dtData0 = TableComponent.getDataTableOptions(cd);

        // Build a default config from the standard options
        $.each(this.extraOptions ? this.extraOptions : {}, function(i,e){
            extraOptions[e[0]] = e[1];
        });
        var dtData = $.extend(cd.dataTableOptions,dtData0,extraOptions);


        /* Configure the table event handlers */
        dtData.fnDrawCallback = _.bind(this.fnDrawCallback,this);
        dtData.fnInitComplete = _.bind(this.fnInitComplete,this);
        /* fnServerData is required for server-side pagination */
        if (dtData.bServerSide) {
            var myself = this;
            dtData.fnServerData = function(u,p,c) {
                myself.pagingCallback(u,p,c,this);
            };
        }

        /* We need to make sure we're getting data from the right place,
         * depending on whether we're using CDA
         */
        if (json) {
            dtData.aaData = json.resultset;
        }
 
        this.ph.html("<table id='" + this.htmlObject + "Table' class='tableComponent' width='100%'></table>");
        /* 
         * We'll first initialize a blank table so that we have a
         * table handle to work with while the table is redrawing
         */
        this.dataTable = $("#"+this.htmlObject+'Table').dataTable(dtData);
    
        // We'll create an Array to keep track of the open expandable rows.
        this.dataTable.anOpen = [];


        myself.ph.find ('table').bind('click',function(e) {
            if (typeof cd.clickAction === 'function' || myself.expandOnClick) { 
                var state = {},
                    target = $(e.target),
                    results = myself.rawData; 
                if(!(target.parents('tbody').length)) {
                    return;
                } else if (target.get(0).tagName != 'TD') {
                    target = target.closest('td');
                }
                var position = myself.dataTable.fnGetPosition(target.get(0));
                state.rawData = myself.rawData;
                state.tableData = myself.dataTable.fnGetData();
                state.colIdx = position[2];
                state.rowIdx = position[0];
                state.series = results.resultset[state.rowIdx][0];
                
                state.category = results.metadata[state.colIdx].colName;
                state.value =  results.resultset[state.rowIdx][state.colIdx];
                state.colFormat = cd.colFormats[state.colIdx];           

                    
                state.target = target;

                
                if ( myself.expandOnClick ) {
                    myself.handleExpandOnClick(state);
                }
                if ( cd.clickAction  ){
                    cd.clickAction.call(myself,state);
                }
            }
        });
        myself.ph.trigger('cdfTableComponentFinishRendering');
    },

    handleExpandOnClick: function(event) {
        var myself = this,
            detailContainerObj = myself.expandContainerObject,
            activeclass = "expandingClass";

        if(typeof activeclass === 'undefined'){
            activeclass = "activeRow";
        }

        var obj = event.target.closest("tr"),
                a = event.target.closest("a");

        if (a.hasClass ('info')) {
            return;
        } else {
            var row = obj.get(0),
                    value = event.series,
                    htmlContent = $("#" + detailContainerObj).html(),
                    anOpen = myself.dataTable.anOpen,
                    i = $.inArray( row, anOpen );
            
            if( obj.hasClass(activeclass) ){
                obj.removeClass(activeclass);
                myself.dataTable.fnClose( row );
                anOpen.splice(i,1);

            } else {
                // Closes all open expandable rows .
                for ( var j=0; j < anOpen.length; j++ ) {
                    $(anOpen[j]).removeClass(activeclass);
                    myself.dataTable.fnClose( anOpen[j] );
                    anOpen.splice(j ,1);
                }
                obj.addClass(activeclass);

                anOpen.push( row );
                // Since the switch to async, we need to open it first
                myself.dataTable.fnOpen( row, htmlContent, activeclass );

                //Read parameters and fire changes
                var results = myself.queryState.lastResults();
                $(myself.expandParameters).each(function f(i, elt) {
                    Dashboards.fireChange(elt[1], results.resultset[event.rowIdx][parseInt(elt[0],10)]);              
                });

            };
        };
        $("td.expandingClass").click(
            function(event){
                //Does nothing but it prevents problems on expandingClass clicks!
                event.stopPropagation();
                return;
            }
        );
    }
},

{
    getDataTableOptions : function(options) {
        var dtData = {};

        if(options.tableStyle == "themeroller"){
            dtData.bJQueryUI = true;
        }
        dtData.bInfo = options.info;
        dtData.iDisplayLength = options.displayLength;
        dtData.bLengthChange = options.lengthChange;
        dtData.bPaginate = options.paginate;
        dtData.bSort = options.sort;
        dtData.bFilter = options.filter;
        dtData.sPaginationType = options.paginationType;
        dtData.sDom = options.sDom;
        dtData.aaSorting = options.sortBy;
        
        if (typeof options.oLanguage == "string"){
            dtData.oLanguage = eval("(" + options.oLanguage + ")");//TODO: er...
    }
        else {
            dtData.oLanguage = options.oLanguage;
    }

        if(options.colHeaders != undefined){
            dtData.aoColumns = new Array(options.colHeaders.length);
            for(var i = 0; i< options.colHeaders.length; i++){
                dtData.aoColumns[i]={}
                dtData.aoColumns[i].sClass="column"+i;
            };
            $.each(options.colHeaders,function(i,val){
                dtData.aoColumns[i].sTitle=val;
                if(val == "") dtData.aoColumns[i].bVisible=false;
            });  // colHeaders
            if(options.colTypes!=undefined){
                $.each(options.colTypes,function(i,val){
                    var col = dtData.aoColumns[i];
                    // Specific case: hidden cols
                    if(val == "hidden") col.bVisible=false;
                    col.sClass+=" "+val;
                    col.sType=val;

                })
            };  // colTypes
            if(options.colFormats!=undefined){
            // Changes are made directly to the json

            };  // colFormats

            var bAutoWidth = true;
            if(options.colWidths!=undefined){
                $.each(options.colWidths,function(i,val){
                    if (val!=null){
                        dtData.aoColumns[i].sWidth=val;
                        bAutoWidth = false;
                    }
                })
            }; //colWidths
            dtData.bAutoWidth = bAutoWidth;

            if(options.colSortable!=undefined){
                $.each(options.colSortable,function(i,val){
                    if (val!=null && ( !val || val == "false" ) ){
                        dtData.aoColumns[i].bSortable=false
                    }
                })
            }; //colSortable
            if(options.colSearchable!=undefined){
                $.each(options.colSearchable,function(i,val){
                    if (val!=null && ( !val || val == "false" ) ){
                        dtData.aoColumns[i].bSearchable=false
                    }
                })
            }; //colSearchable

        }

        return dtData;
    }
});
; /* ************************ new file ************************ */
/**
 * Creates a new AddIn.
 * 
 * The options parameter needs a label and name member, and must have
 * either a value (for static Add Ins) or implementation member (for
 * scriptable Add Ins). Should the AddIn support configuration, then
 * there should also be an options.defaults member containing the
 * default values for the configurable settings.
 *
 * @class AddIns come in two varieties: Static AddIns
 * represent static data or behaviour, whereas Scriptable AddIns
 * represent dynamic, context-dependent behaviour.
 *
 * @property {String} label  The AddIn's human-readable label. (read only) 
 * @property {String} name The internal identifier for the AddIn. (read only) 
 * @parameters options {Object} The options for the AddIn.
 */

function AddIn(options) {
    
    var myself = options;
    if (typeof options != "object") {
        throw TypeError;
    }
    /* We expect either an implementation or a value. */
    if (!options.label || !options.name || (!options.implementation && !options.value)) {
        throw TypeError;
    }
    var _name = options.name,
            _label = options.label,
            _type = options.implementation ? "scriptable" : "static",
            /* It's OK if any of these ends up being undefined */
            _implementation = options.implementation,
            _defaults = options.defaults,
            _value = options.options;
        
    /* Do we have an init method? Call it now */
    if(typeof options.init === 'function'){
        options.init.call(myself);
    }

    this.getLabel = function() {
        return _label;
    }
    this.getName = function() {
        return _name;
    }

    /**
     * Call the AddIn. If the AddIn is static, all parameters are
     * irrelevant, and this method will simply return the value.
     * 
     * In a dynamic AddIn, the implementation will be passed the
     * the target DOM Element (whatever element is relevant,
     * e.g. the element that was clicked on, or the table cell
     * that's being processed), a state object with whatever
     * context is relevant for the AddIn to fulfill its purpose,
     * and optionally any overriding options.
     *
     * Components are allowed to pass undefined as the target if 
     * no Elements make sense in context, and 
     *
     * @parameter target {Element} The relevant DOM Element.
     * @parameter state {Object} A representation of the necessary
     * context for the AddIn to operate.
     * @parameter options {Object} Configuration options for the AddIn
     */
    this.call = function(target, state, options) {
        if (!_implementation) {
            return Dashboards.clone(_value);
        }
        options = typeof options == "function" ? options(state) : options;
        var evaluatedDefaults = typeof _defaults == "function" ? _defaults(state) : _defaults;
        var compiledOptions = jQuery.extend(true,{},evaluatedDefaults,options);
        try{
            return _implementation.call(myself,target,state,compiledOptions);    
        }
        catch(e){Dashboards.log("Addin Error [" + this.getName() + "]: " + e,"error");}
    };

    this.setDefaults = function(defaults) {
        
        if (typeof defaults == 'function') {
            _defaults = defaults;
        }
        else{
            _defaults = jQuery.extend(true,{},_defaults,defaults);
        }
    };
}
; /* ************************ new file ************************ */
;
(function() {

    /* Sparkline AddIn, based on jquery.sparkline.js sparklines.
     * 
     */
    var sparkline = {
        name: "sparkline",
        label: "Sparkline",
        defaults: {
            type: 'line'
        },    
        init: function(){

            // Register this for datatables sort
            var myself = this;
            $.fn.dataTableExt.oSort[this.name+'-asc'] = function(a,b){
                return myself.sort(a,b)
            };
            $.fn.dataTableExt.oSort[this.name+'-desc'] = function(a,b){
                return myself.sort(b,a)
            };
                
        },
        
        sort: function(a,b){
            return this.sumStrArray(a) - this.sumStrArray(b);
        },
        
        sumStrArray: function(arr){
            return arr.split(',').reduce(function(prev, curr, index, array){  
                Dashboards.log("Current " + curr +"; prev " +  prev); 
                return parseFloat(curr) + (typeof(prev)==='number'?prev:parseFloat(prev));
            });
        },
        
        implementation: function (tgt, st, opt) {
            var t = $(tgt);
            t.sparkline(st.value.split(/,/),opt);
            t.removeClass("sparkline");
        }
    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(sparkline));

    var pvSparkline = {
        name: "pvSparkline",
        label: "Protovis Sparkline",
        defaults: {
            height: 10,
            strokeStyle: "#000",
            lineWidth: 1,
            width: undefined,
            canvasMargin: 2
        },
        init: function(){

            // Register this for datatables sort
            var myself = this;
            $.fn.dataTableExt.oSort[this.name+'-asc'] = function(a,b){
                return myself.sort(a,b)
            };
            $.fn.dataTableExt.oSort[this.name+'-desc'] = function(a,b){
                return myself.sort(b,a)
            };
                
        },
        
        sort: function(a,b){
            return this.sumStrArray(a) - this.sumStrArray(b);
        },
        
        sumStrArray: function(arr){
            return arr.split(',').reduce(function(prev, curr, index, array){  
                Dashboards.log("Current " + curr +"; prev " +  prev); 
                return parseFloat(curr) + (typeof(prev)==='number'?prev:parseFloat(prev));
            });
        },
        
        implementation: function(tgt, st, opt) {
            var ph = $(tgt),
            sparklineData = st.value,
            data = sparklineData.split(",");
            n = data.length,
            w = opt.width || ph.width() - opt.canvasMargin * 2,
            h = opt.height,
            min = pv.min.index(data),
            max = pv.max.index(data);
            ph.empty();
        
            var container = $("<div></div>").appendTo(ph);
        
            //console.log("count "+count);
        
            var vis = new pv.Panel()
            .canvas(container.get(0))
            .width(w)
            .height(h)
            .margin(opt.canvasMargin);
        
            vis.add(pv.Line)
            .data(data)
            .left(pv.Scale.linear(0, n - 1).range(0, w).by(pv.index))
            .bottom(pv.Scale.linear(data).range(0, h))
            .strokeStyle(opt.strokeStyle)
            .lineWidth(opt.lineWidth);        

            vis.render();

            
        }
    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(pvSparkline));


    var dataBar = {
        name: "dataBar",
        label: "Data Bar",
        defaults: {
            width: undefined,
            widthRatio:1,
            height: 10,
            startColor: "#55A4D6",
            endColor: "#448FC8",
            backgroundImage: undefined,
            stroke: null,
            max: undefined,
            min: undefined,
            includeValue: false,
            absValue: true,
            valueFormat: function(v, format, st) {
                return "" + sprintf(format || "%.1f",v) ;
            }
        },
        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['numeric-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['numeric-desc'];
        },
        implementation: function(tgt, st, opt) {
            var tblMax = Math.max.apply(Math,st.tableData.map(function(e){
                                                             return e[st.colIdx];
                                                         })),
                    tblMin = Math.min.apply(Math,st.tableData.map(function(e){
                                                             return e[st.colIdx];
                                                         }));

            var optMax = parseFloat(opt.max);
            var optMin = parseFloat(opt.min);

            var isValidNumber = function(nr){
                return _.isNumber(nr) && isFinite(nr);
            };

            var validMaxValue = isValidNumber(optMax);
            var validMinValue = isValidNumber(optMin);

            if (opt.absValue){
                var max = (validMaxValue == true) ? optMax : Math.max( Math.abs(tblMax), Math.abs(tblMin) ),
                        min = (validMinValue == true) ? optMin : 0,
                        val = Math.abs(parseFloat(st.value));
                        min = Math.max(min,0);
            }else{
                var max = (validMaxValue == true) ? optMax : Math.max(0, tblMax),
                        min = (validMinValue == true) ? optMin : Math.min(0, tblMin),
                        val = parseFloat(st.value);
            }

            var cell = $(tgt);
            cell.empty(); 
            var ph =$("<div>&nbsp;</div>").addClass('dataBarContainer').appendTo(cell);
            var wtmp = opt.width || ph.width();
            wtmp *= opt.widthRatio;
            var htmp = opt.height;       
        
            var leftVal  = Math.min(val,0),
                    rightVal = Math.max(val,0);

            // xx = x axis
            var xx = pv.Scale.linear(min,max).range(0,wtmp); 
            
            var paperSize = xx(Math.min(rightVal,max)) - xx(min);
            paperSize = (paperSize>1)?paperSize:1;
            var paper = Raphael(ph.get(0), paperSize , htmp);
            var c = paper.rect(xx(leftVal), 0, xx(rightVal)-xx(leftVal), htmp);
        
            c.attr({
                fill: opt.backgroundImage?"url('"+opt.backgroundImage+"')":"90-"+opt.startColor + "-" + opt.endColor,
                stroke: opt.stroke,
                title: "Value: "+ st.value
            });

            if(opt.includeValue) {
                var valph = $("<span></span>").addClass('value').append(opt.valueFormat(st.value, st.colFormat, st));
                valph.appendTo(ph);
            }
        }
    };

    Dashboards.registerAddIn("Table", "colType", new AddIn(dataBar));

    var trendArrow = {
        name: "trendArrow",
        label: "Trend Arrows",
        defaults: {
            good: true,
            includeValue: false,
            valueFormat: function(v,format,st) {
                return sprintf(format || "%.1f",v);
            },
            thresholds: { up: 0 , down: 0 }
        },
        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['numeric-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['numeric-desc'];
        },
        implementation: function(tgt, st, opt) {
            var ph = $(tgt),
                qualityClass = opt.good ? "good" : "bad",
                /* Anything that's not numeric is an invalid value.
                 * We consider "numeric" to mean either a number,
                 * or a string that is a fixed point for conversion
                 * to number and back to string.
                 */
                isNumeric = typeof st.value == "number" || (typeof st.value == "string" && Number(st.value).toString() != 'NaN' ),
                trendClass = !isNumeric ? "invalid": (st.value > opt.thresholds.up ? "up" : st.value < opt.thresholds.down ? "down" : "neutral");
            var trend = $("<div>&nbsp;</div>");
            trend.addClass('trend ' + trendClass + ' '  + qualityClass);
            ph.empty();
            if(opt.includeValue) {
                var valph = $("<div class='value'></div>").append(opt.valueFormat(st.value, st.colFormat, st));
                valph.appendTo(ph);
            }
            ph.append(trend);
        }
    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(trendArrow));


    var link = {
        name: "hyperlink",
        label: "Hyperlink",
        defaults:{
            openInNewTab: true,
            prependHttpIfNeeded: true,
            regexp: null,
            pattern: null,
            urlReference: 2,
            labelReference: 1
        },
        
        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['string-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['string-desc'];
        },
        
        implementation: function(tgt, st, opt){
            
            var ph = $(tgt);
            var link, label;
            if (opt.pattern) {
                var re = new RegExp(opt.pattern),
                    results = re.exec(st.value);
                link = results[opt.urlReference];
                label = results[opt.labelReference];
            } else {
                link = st.value;
                label = st.value;
            }
            if (opt.prependHttpIfNeeded && !/^https?:\/\//.test(link)){
                link = "http://" + link;
            }
            // is this text an hyperlink? 
            if(opt.regexp == null || (new RegExp(opt.regexp).test(st.value))){
                var a = $("<a></a>").attr("href",link).addClass("hyperlinkAddIn");
                a.text(label);
                if(opt.openInNewTab){
                    a.attr("target","_blank");
                }
                ph.empty().append(a);
            }
        }
        
    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(link));

    var circle = {
        name: "circle",
        label: "Circle",
        defaults:{
            canvasSize: 10,
            radius: 4,
            color: 'black',
            title: function(st) {return "Value: " + st.value;}
        },
        
        implementation: function(tgt, st, opt){
            var p = $(tgt).empty(),
                v = st.value,
                op,
                options = {},
                w,
                paper;

            for (key in opt) if (opt.hasOwnProperty(key)) {
                op = opt[key];
                options[key] = typeof op == 'function' ?
                    op.call(this,st):
                    op;
            }
            w = options.canvasSize;
            paper = Raphael(tgt, options.canvasSize, options.canvasSize);
            var r = paper.circle(w/2,w/2,options.radius);
            r.attr({
                    fill: options.color,
                    opacity: 1,
                    "stroke":"none",
                    "title": options.title
            });
        }
        
    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(circle));

    var bullet = {
        name: "cccBulletChart",
        label: "Bullet Chart",
        defaults:{
            height: 40,
            animate: false,
            orientation: "horizontal",
            bulletSize: 16,     // Bullet height
            bulletSpacing: 150, // Spacing between bullets
            bulletMargin: 5,   // Left margin
            // Specific values
            bulletRanges: [30,80,100],
            extensionPoints: {
                "bulletMarker_shape":"triangle",
                "bulletTitle_textStyle":"green",
                "bulletMeasure_fillStyle":"black",
                "bulletRuleLabel_font":"8px sans-serif",
                "bulletRule_height": 5
            }
        },

        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['string-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['string-desc'];
        },

        sort: function()  {
            
        },

        implementation: function(tgt, st, opt){
            var chartOptions = $.extend(true,{},opt);
            var $tgt = $(tgt);
            var target = $("<span></span>").appendTo($tgt.empty());
            var values = st.value.split(",");
            var data = this.getData(values);

            chartOptions.canvas = target.get(0);
            chartOptions.width = chartOptions.width || $tgt.width();
            chartOptions.bulletMeasures = [values[0]];
            chartOptions.bulletMarkers = [values[1]];
 
            var chart = new pvc.BulletChart(chartOptions);
            chart.setData(data,{});
            chart.render();
        },

        getData: function(values) {
            var dataSet = {
                    resultset: [values],
                    metadata: []
                },
                i;
            for (i = 0; i < values.length;i++) {
                dataSet.metadata.push({
                    colIndex: i,
                    colType: "String",
                    colName: ""
                });
            }
            return dataSet;
        }    
    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(bullet));

 var formattedText = {
        name: "formattedText",
        label: "Formatted Text",
        defaults: {
            textFormat: function(v, st) {return st.colFormat ? sprintf(st.colFormat,v) : v;}
        },

        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['string-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['string-desc'];
        },
        
        implementation: function(tgt, st, opt){
            var text = opt.textFormat.call(this, st.value, st, opt);
            $(tgt).empty().append(text);
        }
        
    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(formattedText));
    
    var localizedText = {
        name: "localizedText",
        label: "Localized Text",
        defaults: {
            localize: function(v) {return Dashboards.i18nSupport.prop(v);}
        },

        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['string-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['string-desc'];
        },
        
        implementation: function(tgt, st, opt){
            if (typeof Dashboards.i18nSupport !== "undefined" && Dashboards.i18nSupport != null) {
                var text = this.defaults.localize(st.value) ;
                $(tgt).empty().append(text);
                //change data, too, in order for search and sorting to work correctly on the localized text
                st.tableData[st.rowIdx][st.colIdx] = text;
            }
        }

    };
    Dashboards.registerAddIn("Table", "colType", new AddIn(localizedText));


    var groupHeaders = {
        name: "groupHeaders",
        label: "Group Headers",
        defaults: {
            hide:true,
            columnHeadersInGroups: false,
            replaceFirstHeader: true,
            textFormat: function(v, st) {return st.colFormat ? sprintf(st.colFormat,v) : v;}
        },

        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['string-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['string-desc'];
        },
        
        implementation: function(tgt, st, opt){
            var dt = $(tgt).parents('table').eq(0).dataTable(),
                    visColIdx = $(tgt).index();

            /* Decide whether to hide the original column we're drawing the group headers from */
            if (opt.hide){
                 dt.find('.groupHeaders:nth-child(' + (visColIdx + 1) + ')').addClass('hiddenCol');
            }

            
            if(opt.columnHeadersInGroups) {
                var header = dt.find("thead").eq(0);
                header.find("tr").clone
            }

            var $row = $(dt.fnGetNodes( st.rowIdx )),
                    visRowIdx = $row.index(),
                    count = $row.children().length,
                    $group;

            /* We create and insert a group header under any of the following circumstances:
             *   - On the very first row
             *   - Immediately after a higher-level group header
             *     when using group headers for more than one column
             *   - when the value for the current cell is
             *     different from the one immediately before it
             */
            if ( visRowIdx === 0 || $row.prev().hasClass('groupHeader') || ( st.value != dt.fnGetData( $row.prev().get(0) )[st.colIdx]  )) {
                    $group = this.buildHeader(tgt,st, opt);
                    $group.insertBefore($row);
            }
 
        },

        buildHeader: function(tgt, st, opt) {
            var $header,
                    $dt = $(tgt).parents('table').eq(0).dataTable(),
                    $theader,
                    headerText = opt.textFormat.call(this, st.value, st, opt);

            if(opt.columnHeadersInGroups) {
                $theader = $dt.find("thead").eq(0);
                $theader.hide();
                $header = $("<tr>");
                $theader.find("tr th").each(function(i,e){
                    var $e = $(e),
                            newCell = $("<td>").text($e.text()).width(e.style.width);
                    newCell.addClass($(e).hasClass("hiddenCol")? "hiddenCol" : "");
                    $header.append(newCell);
                });
                $header.find("td").eq($(tgt).index() + 1).empty().append(headerText).addClass("groupName");
            } else {
                $header = $("<tr/>");
                $("<td/>").addClass("groupName").empty().append(headerText).attr("colspan",  $(tgt).siblings().length + 1).appendTo($header);
            }
            $header.addClass("groupHeader group" + $(tgt).index());
            var $preSpace = $("<td>").attr("colspan",$(tgt).siblings().length + 1).wrap("<tr>").parent().addClass("groupHeader preSpace");
            var $postSpace = $("<td>").attr("colspan",$(tgt).siblings().length + 1).wrap("<tr>").parent().addClass("groupHeader postSpace");
            var $response = $preSpace.add($header).add($postSpace);
            return $response;
        }
    };
    
    Dashboards.registerAddIn("Table", "colType", new AddIn(groupHeaders));

    var clippedText = {
        name: "clippedText",
        label: "Clipped Text",
        defaults: {
            showTooltip: true,
            useTipsy: false,
            style: {}
        },

        init: function(){
            $.fn.dataTableExt.oSort[this.name+'-asc'] = $.fn.dataTableExt.oSort['string-asc'];
            $.fn.dataTableExt.oSort[this.name+'-desc'] = $.fn.dataTableExt.oSort['string-desc'];
        },
        
        implementation: function(tgt, st, opt){
            var $tgt = $(tgt),
                    $container = $("<div>");
            $tgt.empty().append($container);
            $container.text(st.value).addClass("clippedText").attr("title",opt.showTooltip ? st.value : "");
            $container.css(opt.style);
            if(opt.useTipsy) {
                $container.tipsy({
                        gravity: 's', 
                        html:false
                });
            }
        }
    };

    Dashboards.registerAddIn("Table", "colType", new AddIn(clippedText));
})();
; /* ************************ new file ************************ */
/*
    Copyright 2009,2010,2011 Roland Bouman
    contact: Roland.Bouman@gmail.com ~ http://rpbouman.blogspot.com/ ~ http://code.google.com/p/xmla4js
    twitter: @rolandbouman

    This is xmla4js - a stand-alone, cross-browser javascript library for working with "XML for Analysis".
    XML for Analysis (XML/A) is a vendor-neutral industry-standard protocol for OLAP services over HTTP.
    xmla4js enables web-browser-based analytical business intelligence applications.

    This file contains human-readable javascript source along with the YUI Doc compatible annotations.
    Note: some portions of the API documentation were adopted from the original XML/A specification.
    I believe that this constitutes fair use, but if you have reason to believe that the documentation
    violates any copyright, or is otherwise incompatible with the LGPL license please contact me.

    Include this in your web-pages for debug and development purposes only.
    For production purposes, consider using the minified/obfuscated versions in the /js directory.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
*
*  This is xmla4js - a stand-alone, cross-browser javascript library for working with "XML for Analysis".
*  XML for Analysis (XML/A) is a vendor-neutral industry-standard protocol for OLAP services over HTTP.
*  xmla4js enables web-browser-based analytical business intelligence applications.
*  @module xmla
*  @title Xmla
*/
(function(root) {
var Xmla,
    _soap = "http://schemas.xmlsoap.org/soap/",
    _xmlnsSOAPenvelope = _soap + "envelope/",
    _xmlnsSOAPenvelopePrefix = "SOAP-ENV",
    _xmlnsIsSOAPenvelope = "xmlns:" + _xmlnsSOAPenvelopePrefix + "=\"" + _xmlnsSOAPenvelope + "\"",
    _SOAPencodingStyle = _xmlnsSOAPenvelopePrefix + ":encodingStyle=\"" + _soap + "encoding/\"",
    _ms = "urn:schemas-microsoft-com:",
    _xmlnsXmla = _ms + "xml-analysis",
    _xmlnsIsXmla = "xmlns=\"" + _xmlnsXmla + "\"",
    _xmlnsSQLPrefix = "sql",
    _xmlnsSQL = _ms + "xml-sql",
    _xmlnsSchema = "http://www.w3.org/2001/XMLSchema",
    _xmlnsSchemaPrefix = "xsd",
    _xmlnsSchemaInstance = "http://www.w3.org/2001/XMLSchema-instance",
    _xmlnsSchemaInstancePrefix = "xsi",
    _xmlnsRowset = _xmlnsXmla + ":rowset",
    _xmlnsDataset = _xmlnsXmla + ":mddataset",
    _useAX = window.ActiveXObject ? true : false
;

function _ajax(options){
/*
    This is not a general ajax function,
    just something that is good enough for Xmla.
*/
    var xhr,
        handlerCalled = false,
        handler = function(){
            handlerCalled = true;
            switch (xhr.readyState){
                case 0:
                    options.aborted(xhr);
                    break;
                case 4:
                    if (xhr.status===200){
                        options.complete(xhr);
                    }
                    else {
                        options.error(
                            Xmla.Exception._newError(
                                "HTTP_ERROR",
                                "_ajax",
                                {
                                    request: options,
                                    status: this.status,
                                    statusText: this.statusText
                                }
                            )
                        );
                    }
                break;
            }
        };
    if (XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    }
    else
    if (_useAX) {
        xhr = new ActiveXObject("MSXML2.XMLHTTP.3.0");
    }
    if (options.username && options.password) {
        xhr.open(
            "POST", options.url, options.async,
            options.username, options.password
        );
    }
    else {
        xhr.open("POST", options.url, options.async);
    }
    xhr.onreadystatechange = handler;
    xhr.setRequestHeader("Accept", "text/xml, application/xml, application/soap+xml");
    xhr.setRequestHeader("Content-Type", "text/xml");
    if (options.headers) {
        var headers = options.headers, header;
        for (header in headers) xhr.setRequestHeader(header, headers[header]);
    }
    xhr.send(options.data);
    if (!options.async && !handlerCalled){
        handler.call(xhr);
    }
    return xhr;
};

function _isUnd(arg){
    return typeof(arg)==="undefined";
};
function _isArr(arg){
    return arg && arg.constructor === Array;
};
function _isNum(arg){
    return typeof(arg)==="number";
};
function _isFun(arg){
    return typeof(arg)==="function";
};
function _isStr(arg) {
    return typeof(arg)==="string";
};
function _isObj(arg) {
    return arg && typeof(arg)==="object";
};
function _xmlEncode(value){
    if (_isStr(value)) {
        value = value.replace(/\&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    return value;
};

var docEl = document.documentElement;

var _getElementsByTagNameNS = docEl.getElementsByTagNameNS ? function(node, ns, prefix, tagName){
                                                                 return node.getElementsByTagNameNS(ns, tagName);
                                                             }
                                                           : function(node, ns, prefix, tagName){
                                                                 if (prefix){
                                                                     return node.getElementsByTagName(prefix + ":" + tagName);
                                                                 }
                                                                 else {
                                                                     return node.getElementsByTagName(tagName);
                                                                 }
                                                             };

var _getAttributeNS = docEl.getAttributeNS ? function(element, ns, prefix, attributeName){
                                                 return element.getAttributeNS(ns, attributeName);
                                             }
                                           : function(element, ns, prefix, attributeName){
                                                 if (prefix) {
                                                     return element.getAttribute(prefix + ":" + attributeName);
                                                 }
                                                 else {
                                                     return element.getAttribute(attributeName);
                                                 }
                                             };
function _getElementText(el){
    //on first call, we examine the properies of the argument element
    //to try and find a native (and presumably optimized) method to grab
    //the text value of the element.
    //We then overwrite the original _getElementText
    //to use the optimized one in any subsequent calls
    var func;
    if (!_isUnd(el.innerText)) {         //ie
        func = function(el){
            return el.innerText;
        };
    }
    else
    if (!_isUnd(el.textContent)) {       //ff, chrome
        func = function(el){
            return el.textContent;
        };
    }
    else
    if (!_isUnd(el.nodeTypedValue)) {    //ie8
        func = function(el){
            return el.nodeTypedValue;
        };
    }
    else
    if (el.normalize){
        func = function(el) {
            el.normalize();
            if (el.firstChild){
                return el.firstChild.data;
            }
            else {
                return null;
            }
        }
    }
    else {                      //generic
        func = function(el) {
            var text = [], childNode,
                childNodes = el.childNodes, i,
                n = childNodes.length
            ;
            for (i = 0; i < n; i++){
                childNode = childNodes.item(i);
                if (childNode.data !== null) text.push(childNode.data);
            }
            return text.length ? text.join("") : null;
        }
    }
    _getElementText = func;
    return func(el);
};

function _getXmlaSoapList(container, listType, items, indent){
    if (!indent) indent = "";
    var n, i, entry, property, item, msg = "\n" + indent + "<" + container + ">";
    if (items) {
        msg += "\n" + indent + " <" + listType + ">";
        for (property in items){
            if (items.hasOwnProperty(property)) {
                item = items[property];
                msg += "\n" + indent + "  <" + property + ">";
                if (_isArr(item)){
                    n = item.length;
                    for (i = 0; i < n; i++){
                        entry = item[i];
                        msg += "<Value>" + _xmlEncode(entry) + "</Value>";
                    }
                } else {
                    msg += _xmlEncode(item);
                }
                msg += "</" + property + ">";
            }
        }
        msg += "\n" + indent + " </" + listType + ">";
    }
    msg += "\n" + indent + "</" + container + ">";
    return msg;
};

var _xmlRequestType = "RequestType";

function _getXmlaSoapMessage(options){
    var method = options.method,
        msg = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
        "\n<" + _xmlnsSOAPenvelopePrefix + ":Envelope" +
        " " + _xmlnsIsSOAPenvelope +
        " " + _SOAPencodingStyle + ">" +
        "\n <" + _xmlnsSOAPenvelopePrefix + ":Body>" +
        "\n  <" + method + " " + _xmlnsIsXmla + " " + _SOAPencodingStyle + ">"
    ;
    switch(method){
        case Xmla.METHOD_DISCOVER:
            if (!options.requestType) {
                Xmla.Exception._newError(
                    "MISSING_REQUEST_TYPE",
                    "Xmla._getXmlaSoapMessage",
                    options
                )._throw();
            }
            msg += "\n   <" + _xmlRequestType + ">" + options.requestType + "</" + _xmlRequestType + ">" +
                _getXmlaSoapList("Restrictions", "RestrictionList", options.restrictions, "   ") +
                _getXmlaSoapList("Properties", "PropertyList", options.properties, "   ");
            break;
        case Xmla.METHOD_EXECUTE:
            if (!options.statement){
                Xmla.Exception._newError(
                    "MISSING_REQUEST_TYPE",
                    "Xmla._getXmlaSoapMessage",
                    options
                )._throw();
            }
            msg += "\n   <Command>" +
                "\n    <Statement>" + _xmlEncode(options.statement) + "</Statement>" +
                "\n   </Command>" +
                _getXmlaSoapList("Properties", "PropertyList", options.properties, "   ")
            ;
            break;
        default:
            //we used to throw an exception here,
            //but this would make it impossible
            //to execute service or provider specific methods.
    }
    msg += "\n  </" + method + ">" +
        "\n </" + _xmlnsSOAPenvelopePrefix + ":Body>" +
        "\n</" + _xmlnsSOAPenvelopePrefix + ":Envelope>"
    ;
    return msg;
};

function _applyProps(object, properties, overwrite){
    if (properties && (!object)) {
        object = {};
    }
    var property;
    for (property in properties){
        if (properties.hasOwnProperty(property)){
            if (overwrite || _isUnd(object[property])) {
                object[property] = properties[property];
            }
        }
    }
    return object;
};

if (_isUnd(root)) root = window;

/**
*
*   The Xmla class provides a javascript API to communicate XML for Analysis (XML/A) over HTTP.
*   XML/A is an industry standard protocol that allows webclients to work with OLAP servers.
*   To fully understand the scope and purpose of this utility, it is highly recommended
*   to read <a href="http://xmla.org/xmla1.1.doc">the XML/A specification</a>
*   (MS Word format. For other formats,
*   see: <a href="http://code.google.com/p/xmla4js/source/browse/#svn/trunk/doc/xmla1.1 specification">http://code.google.com/p/xmla4js/source/browse/#svn/trunk/doc/xmla1.1 specification</a>).
*
*   @class Xmla
*   @constructor
*   @param options Object standard options
*/
Xmla = root.Xmla = function(options){

    this.listeners = {};
    this.listeners[Xmla.EVENT_REQUEST] = [];
    this.listeners[Xmla.EVENT_SUCCESS] = [];
    this.listeners[Xmla.EVENT_ERROR] = [];

    this.listeners[Xmla.EVENT_DISCOVER] = [];
    this.listeners[Xmla.EVENT_DISCOVER_SUCCESS] = [];
    this.listeners[Xmla.EVENT_DISCOVER_ERROR] = [];

    this.listeners[Xmla.EVENT_EXECUTE] = [];
    this.listeners[Xmla.EVENT_EXECUTE_SUCCESS] = [];
    this.listeners[Xmla.EVENT_EXECUTE_ERROR] = [];

    this.options = _applyProps(
        _applyProps(
            {},
            Xmla.defaultOptions,
            true
        ),
        options,
        true
    );
    var listeners = this.options.listeners;
    if (listeners) this.addListener(listeners);
    return this;
};

Xmla.defaultOptions = {
    requestTimeout: 30000,      //by default, we bail out after 30 seconds
    async: false,               //by default, we do a synchronous request
    addFieldGetters: true       //true to augment rowsets with a method to fetch a specific field.
};

/**
*   Can be used as value for the method option in the options object passed to the
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server.
*   Instead of explicitly setting the method yourself, consider using the <code><a href="#method_request">discover()</a></code> method.
*   The <code>discover()</code> method automatically sets the method option to <code>METHOD_DISCOVER</code>.
*   @property METHOD_DISCOVER
*   @static
*   @final
*   @type string
*   @default <code>Discover</code>
*/
Xmla.METHOD_DISCOVER = "Discover";
/**
*   Can be used as value for the method option property in the options objecct passed to the
*   <code><a href="#method_request">request()</code></a> method to invoke the XML/A Execute method on the server.
*   Instead of explicitly setting the method yourself, consider using the <code><a href="#method_execute">execute()</a></code> method.
*   The <code>execute()</code> method automatically sets the method option to <code>METHOD_EXECUTE</code>.
*   @property METHOD_EXECUTE
*   @static
*   @final
*   @type string
*   @default <code>Discover</code>
*/
Xmla.METHOD_EXECUTE = "Execute";

var _xmlaDISCOVER = "DISCOVER_";
var _xmlaMDSCHEMA = "MDSCHEMA_";
var _xmlaDBSCHEMA = "DBSCHEMA_";

/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DISCOVER_DATASOURCES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this constant as requestType yourself, consider calling the <code><a href="#method_discoverDataSources">discoverDataSources()</a></code> method.
*   The <code>discoverDataSources()</code> method passes <code>DISCOVER_DATASOURCES</code> automatically as requestType for Discover requests.
*
*   @property DISCOVER_DATASOURCES
*   @static
*   @final
*   @type string
*   @default <code>DISCOVER_DATASOURCES</code>
*/
Xmla.DISCOVER_DATASOURCES =     _xmlaDISCOVER + "DATASOURCES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DISCOVER_PROPERTIES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverProperties">discoverProperties()</a></code> method.
*   The <code>discoverProperties()</code> method passes <code>DISCOVER_PROPERTIES</code> automatically as requestType for Discover requests.
*
*   @property DISCOVER_PROPERTIES
*   @static
*   @final
*   @type string
*   @default <code>DISCOVER_PROPERTIES</code>
*/
Xmla.DISCOVER_PROPERTIES =      _xmlaDISCOVER + "PROPERTIES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DISCOVER_SCHEMA_ROWSETS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverSchemaRowsets">discoverSchemaRowsets()</a></code> method.
*   The <code>discoverProperties()</code> method passes <code>DISCOVER_PROPERTIES</code> automatically as requestType for Discover requests.
*
*   @property DISCOVER_SCHEMA_ROWSETS
*   @static
*   @final
*   @type string
*   @default <code>DISCOVER_SCHEMA_ROWSETS</code>
*/
Xmla.DISCOVER_SCHEMA_ROWSETS =  _xmlaDISCOVER + "SCHEMA_ROWSETS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DISCOVER_ENUMERATORS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverEnumerators">discoverEnumerators()</a></code> method.
*   The <code>discoverSchemaRowsets()</code> method issues a request to invoke the Discover method using <code>DISCOVER_SCHEMA_ROWSETS</code> as requestType.
*
*   @property DISCOVER_ENUMERATORS
*   @static
*   @final
*   @type string
*   @default <code>DISCOVER_ENUMERATORS</code>
*/
Xmla.DISCOVER_ENUMERATORS =     _xmlaDISCOVER + "ENUMERATORS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DISCOVER_KEYWORDS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this requestType yourself, consider calling the <code><a href="#method_discoverLiterals">discoverKeywords()</a></code> method.
*   The <code>discoverKeywords()</code> method issues a request to invoke the Discover method using DISCOVER_KEYWORDS as requestType.
*
*   @property DISCOVER_KEYWORDS
*   @static
*   @final
*   @type string
*   @default <code>DISCOVER_KEYWORDS</code>
*/
Xmla.DISCOVER_KEYWORDS =        _xmlaDISCOVER + "KEYWORDS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DISCOVER_LITERALS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverLiterals">discoverLiterals()</a></code> method.
*   The <code>discoverLiterals()</code> method issues a request to invoke the Discover method using DISCOVER_LITERALS as requestType.
*
*   @property DISCOVER_LITERALS
*   @static
*   @final
*   @type string
*   @default <code>DISCOVER_LITERALS</code>
*/
Xmla.DISCOVER_LITERALS =        _xmlaDISCOVER + "LITERALS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DBSCHEMA_CATALOGS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverDBCatalogs">discoverDBCatalogs()</a></code> method.
*   The <code>discoverDBCatalogs()</code> method issues a request to invoke the Discover method using <code>DBSCHEMA_CATALOGS</code> as requestType.
*
*   @property DBSCHEMA_CATALOGS
*   @static
*   @final
*   @type string
*   @default <code>DBSCHEMA_CATALOGS</code>
*/
Xmla.DBSCHEMA_CATALOGS =       _xmlaDBSCHEMA + "CATALOGS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DBSCHEMA_COLUMNS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverDBColumns">discoverDBColumns()</a></code> method.
*   The <code>discoverDBColumns()</code> method issues a request to invoke the Discover method using <code>DBSCHEMA_COLUMNS</code> as requestType.
*
*   @property DBSCHEMA_COLUMNS
*   @static
*   @final
*   @type string
*   @default <code>DBSCHEMA_COLUMNS</code>
*/
Xmla.DBSCHEMA_COLUMNS =        _xmlaDBSCHEMA + "COLUMNS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DBSCHEMA_PROVIDER_TYPES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverDBProviderTypes">discoverDBProviderTypes()</a></code> method.
*   The <code>discoverDBProviderTypes()</code> method issues a request to invoke the Discover method using <code>DBSCHEMA_PROVIDER_TYPES</code> as requestType.
*
*   @property DBSCHEMA_PROVIDER_TYPES
*   @static
*   @final
*   @type string
*   @default <code>DBSCHEMA_PROVIDER_TYPES</code>
*/
Xmla.DBSCHEMA_PROVIDER_TYPES = _xmlaDBSCHEMA + "PROVIDER_TYPES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DBSCHEMA_SCHEMATA</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverDBSchemata">discoverDBSchemata()</a></code> method.
*   The <code>discoverDBColumns()</code> method issues a request to invoke the Discover method using <code>DBSCHEMA_SCHEMATA</code> as requestType.
*
*   @property DBSCHEMA_SCHEMATA
*   @static
*   @final
*   @type string
*   @default <code>DBSCHEMA_SCHEMATA</code>
*/
Xmla.DBSCHEMA_SCHEMATA =       _xmlaDBSCHEMA + "SCHEMATA";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DBSCHEMA_TABLES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the <code><a href="#method_discoverDBTables">discoverDBTables()</a></code> method.
*   The <code>discoverDBColumns()</code> method issues a request to invoke the Discover method using <code>DBSCHEMA_TABLES</code> as requestType.
*
*   @property DBSCHEMA_TABLES
*   @static
*   @final
*   @type string
*   @default <code>DBSCHEMA_TABLES</code>
*/
Xmla.DBSCHEMA_TABLES =         _xmlaDBSCHEMA + "TABLES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>DBSCHEMA_TABLES_INFO</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverDBTablesInfo">discoverDBTablesInfo()</a></code> method.
*   The <code>discoverDBTablesInfo()</code> method issues a request to invoke the Discover method using <code>DBSCHEMA_TABLES_INFO</code> as requestType.
*
*   @property DBSCHEMA_TABLES_INFO
*   @static
*   @final
*   @type string
*   @default <code>DBSCHEMA_TABLES_INFO</code>
*/
Xmla.DBSCHEMA_TABLES_INFO =    _xmlaDBSCHEMA + "TABLES_INFO";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the <code>MDSCHEMA_ACTIONS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDActions">discoverMDActions()</a></code> method.
*   The <code>discoverMDActions()</code> method issues a request to invoke the Discover method using <code>MDSCHEMA_ACTIONS</code> as requestType.
*
*   @property MDSCHEMA_ACTIONS
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_ACTIONS</code>
*/
Xmla.MDSCHEMA_ACTIONS =        _xmlaMDSCHEMA + "ACTIONS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_CUBES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDCubes">discoverMDCubes()</a></code> method.
*   The <code>discoverMDCubes()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_CUBES</code> as requestType.
*
*   @property MDSCHEMA_CUBES
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_CUBES</code>
*/
Xmla.MDSCHEMA_CUBES =          _xmlaMDSCHEMA + "CUBES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_DIMENSIONS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDDimensions">discoverMDDimensions()</a></code> method.
*   The <code>discoverMDDimensions()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_DIMENSIONS</code> as requestType.
*
*   @property MDSCHEMA_DIMENSIONS
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_DIMENSIONS</code>
*/
Xmla.MDSCHEMA_DIMENSIONS =     _xmlaMDSCHEMA + "DIMENSIONS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_FUNCTIONS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDFunctions">discoverMDFunctions()</a></code> method.
*   The <code>discoverMDFunctions()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_FUNCTIONS</code> as requestType.
*
*   @property MDSCHEMA_FUNCTIONS
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_FUNCTIONS</code>
*/
Xmla.MDSCHEMA_FUNCTIONS =      _xmlaMDSCHEMA + "FUNCTIONS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_HIERARCHIES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDHierarchies">discoverMDHierarchies()</a></code> method.
*   The <code>discoverMDHierarchies()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_HIERARCHIES</code> as requestType.
*
*   @property MDSCHEMA_HIERARCHIES
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_HIERARCHIES</code>
*/
Xmla.MDSCHEMA_HIERARCHIES =    _xmlaMDSCHEMA + "HIERARCHIES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_LEVELS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDLevels">discoverMDLevels()</a></code> method.
*   The <code>discoverMDLevels()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_LEVELS</code> as requestType.
*
*   @property MDSCHEMA_LEVELS
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_LEVELS</code>
*/
Xmla.MDSCHEMA_LEVELS =         _xmlaMDSCHEMA + "LEVELS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_MEASURES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDMeasures">discoverMDMeasures()</a></code> method.
*   The <code>discoverMDMeasures()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_MEASURES</code> as requestType.
*
*   @property MDSCHEMA_MEASURES
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_MEASURES</code>
*/
Xmla.MDSCHEMA_MEASURES =       _xmlaMDSCHEMA + "MEASURES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_MEMBERS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDMembers">discoverMDMembers()</a></code> method.
*   The <code>discoverMDMembers()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_MEMBERS</code> as requestType.
*
*   @property MDSCHEMA_MEMBERS
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_MEMBERS</code>
*/
Xmla.MDSCHEMA_MEMBERS =        _xmlaMDSCHEMA + "MEMBERS";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_PROPERTIES</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDProperties">discoverMDProperties()</a></code> method.
*   The <code>discoverMDProperties()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_PROPERTIES</code> as requestType.
*
*   @property MDSCHEMA_PROPERTIES
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_PROPERTIES</code>
*/
Xmla.MDSCHEMA_PROPERTIES =     _xmlaMDSCHEMA + "PROPERTIES";
/**
*   Can be used as value for the <code>requestType</code> option in the options object passed to the to
*   <code><a href="#method_request">request()</a></code> method to invoke the XML/A Discover method on the server to return the
*   <code>MDSCHEMA_SETS</code> schema rowset.
*   The <code>requestType</code> option applies only to Discover requests.
*   Instead of passing this <code>requestType</code> yourself, consider calling the
*   <code><a href="#method_discoverMDSets">discoverMDSets()</a></code> method.
*   The <code>discoverMDSets()</code> method issues a request to invoke the Discover method using
*   <code>MDSCHEMA_SETS</code> as requestType.
*
*   @property MDSCHEMA_SETS
*   @static
*   @final
*   @type string
*   @default <code>MDSCHEMA_SETS</code>
*/
Xmla.MDSCHEMA_SETS = _xmlaMDSCHEMA + "SETS";
/**
*   Indicates the <code>request</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>request</code> event is the first event that is fired before submitting a request
*   (see: <code><a href="#method_request">request()</a></code>)
*   to the server, and before firing the method-specific request events
*   (see <code><a href="#property_EVENT_EXECUTE">EVENT_EXECUTE</a></code>
*   and <code><a href="#property_EVENT_DISCOVER">EVENT_DISCOVER</a></code>).
*   The <code>request</code> event itself is not method-specific, and fires for <code>Execute</code> as well as <code>Discover</code> requests.
*   The <code>EVENT_REQUEST</code> event is <em>cancelable</em>:
*   the <code>handler</code> function specified in the listener object passed to <code>addListener</code> should return a boolen, indicating
*   whether the respective operation should be canceled.
*
*   @property EVENT_REQUEST
*   @static
*   @final
*   @type string
*   @default <code>request</code>
*/
Xmla.EVENT_REQUEST = "request";
/**
*   Indicates the <code>success</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>success</code> event  is the last event that is fired after receiving and processing a normal response
*   (that is, a response that does not contain an XML/A <code>SoapFault</code>),
*   after firing the method-specific success events
*   (see <code><a href="#property_EVENT_EXECUTE_SUCCESS">EVENT_EXECUTE_SUCCESS</a></code>
*   and <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>).
*   The <code>success</code> event is not method-specific, and fires for <code>Execute</code> as well as <code>Discover</code> responses.
*   This is event is not cancelable.
*
*   @property EVENT_SUCCESS
*   @static
*   @final
*   @type string
*   @default <code>success</code>
*/
Xmla.EVENT_SUCCESS = "success";
/**
*   Indicates the <code>error</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>error</code> is fired when an error occurs while sending a request or receiving a response.
*   The <code>error</code> event is not method-specific, and fires for errors encountered during both <code>Execute</code> as well as <code>Discover</code> method invocations.
*   This is event is not cancelable.
*
*   @property EVENT_ERROR
*   @static
*   @final
*   @type string
*   @default <code>error</code>
*/
Xmla.EVENT_ERROR = "error";

/**
*   Indicates the <code>execute</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>execute</code> event is method-specific, and is fired before submitting an <code>Execute</code> request
*   (see: <code><a href="#method_execute">execute()</a></code>)
*   to the server, but after firing the <code>request</code> event
*   (see: <code><a href="#property_EVENT_REQUEST">EVENT_REQUEST</a></code>).
*   The <code>EVENT_EXECUTE</code> event is <em>cancelable</em>:
*   the <code>handler</code> function specified in the listener object passed to <code>addListener</code> should return a boolen, indicating
*   whether the respective operation should be canceled.
*
*   @property EVENT_EXECUTE
*   @static
*   @final
*   @type string
*   @default <code>execute</code>
*/
Xmla.EVENT_EXECUTE = "execute";
/**
*   Indicates the <code>executesuccess</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>executesuccess</code> event is method-specific and fired only after receiving and processing a normal response
*   (that is, a response that does not contain a <code>SoapFault</code>)
*   to an incovation of the XML/A <code>Execute</code> method
*   (see: <code><a href="#method_execute">execute()</a></code>).
*   This is event is not cancelable.
*
*   @property EVENT_EXECUTE_SUCCESS
*   @static
*   @final
*   @type string
*   @default <code>executesuccess</code>
*/
Xmla.EVENT_EXECUTE_SUCCESS = "executesuccess";
/**
*   Indicates the <code>executeerror</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>executeerror</code> event is method-specific and fired when an error occurs while sending an <code>Execute</code> request, or receiving a response to an <code>Execute</code method.
*   (see: <code><a href="#method_execute">execute()</a></code>).
*   This is event is not cancelable.
*
*   @property EVENT_EXECUTE_ERROR
*   @static
*   @final
*   @type string
*   @default <code>executeerror</code>
*/
Xmla.EVENT_EXECUTE_ERROR = "executeerror";

/**
*   Indicates the <code>discover</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>discover</code> event is method-specific, and is fired before submitting a <code>Discover</code> request
*   (see: <code><a href="#method_discover">discover()</a></code>)
*   to the server, but after firing the <code>request</code> event
*   (see: <code><a href="#property_EVENT_DISCOVER">EVENT_DISCOVER</a></code>).
*   The <code>EVENT_DISCOVER</code> event is <em>cancelable</em>:
*   the <code>handler</code> function specified in the listener object passed to <code>addListener</code> should return a boolen, indicating
*   whether the respective operation should be canceled.
*
*   @property EVENT_DISCOVER
*   @static
*   @final
*   @type string
*   @default <code>discover</code>
*/
Xmla.EVENT_DISCOVER = "discover";
/**
*   Indicates the <code>discoversuccess</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>discoversuccess</code> event is method-specific and fired only after receiving and processing a normal response
*   (that is, a response that does not contain a <code>SoapFault</code>)
*   to an incovation of the XML/A <code>Discover</code> method
*   (see: <code><a href="#method_discover">discover()</a></code>).
*   This is event is not cancelable.
*
*   @property EVENT_DISCOVER_SUCCESS
*   @static
*   @final
*   @type string
*   @default <code>discoversuccess</code>
*/
Xmla.EVENT_DISCOVER_SUCCESS = "discoversuccess";
/**
*   Indicates the <code>discovererror</code> event.
*   This constant can be used as en entry in the events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*   The <code>discovererror</code> is method-specific and fired when an error occurs while sending an <code>Discover</code> request,
*   or receiving a response to an <code>Discover</code method.
*   (see: <code><a href="#method_discover">discover()</a></code>).
*   This is event is not cancelable.
*
*   @property EVENT_DISCOVER_ERROR
*   @static
*   @final
*   @type string
*   @default <code>discovererror</code>
*/
Xmla.EVENT_DISCOVER_ERROR = "discovererror";

/**
*   Unifies all general events, that is, all events that are not method-specific.
*   This constant can be used as events array argument for the <code><a href="#method_addListener">addListener()</a></code> method,
*   or you can use array concatenation to combine it with other arrays of <code>EVENT_XXX</code> constants.
*   This constant is especially intended for asyncronous handling of Schema rowset data.
*
*   @property EVENT_GENERAL
*   @static
*   @final
*   @type string[]
*   @default <code>[EVENT_REQUEST,EVENT_SUCCESS,EVENT_ERROR]</code>
*/
Xmla.EVENT_GENERAL = [
    Xmla.EVENT_REQUEST,
    Xmla.EVENT_SUCCESS,
    Xmla.EVENT_ERROR
];

/**
*   Unifies all events specific for the <code>Discover</code> method.
*   This constant can be used as events array argument for the <code><a href="#method_addListener">addListener()</a></code> method,
*   or you can use array concatenation to combine it with other arrays of <code>EVENT_XXX</code> constants.
*
*   @property EVENT_DISCOVER_ALL
*   @static
*   @final
*   @type string[]
*   @default <code>[EVENT_DISCOVER,EVENT_DISCOVER_SUCCESS,EVENT_DISCOVER_ERROR]</code>
*/
Xmla.EVENT_DISCOVER_ALL = [
    Xmla.EVENT_DISCOVER,
    Xmla.EVENT_DISCOVER_SUCCESS,
    Xmla.EVENT_DISCOVER_ERROR
];

/**
*   Unifies all events specific for the <code>Execute</code> method.
*   This constant can be used as events array argument for the <code><a href="#method_addListener">addListener()</a></code> method,
*   or you can use array concatenation to combine it with other arrays of <code>EVENT_XXX</code> constants.
*
*   @property EVENT_EXECUTE_ALL
*   @static
*   @final
*   @type string[]
*   @default <code>[EVENT_EXECUTE,EVENT_EXECUTE_SUCCESS,EVENT_EXECUTE_ERROR]</code>
*/
Xmla.EVENT_EXECUTE_ALL = [
    Xmla.EVENT_EXECUTE,
    Xmla.EVENT_EXECUTE_SUCCESS,
    Xmla.EVENT_EXECUTE_ERROR
];

/**
*   Unifies all method-specific and non method-specific events.
*   This constant can be used as events array argument for the <code><a href="#method_addListener">addListener()</a></code> method.
*
*   @property EVENT_ALL
*   @static
*   @final
*   @type string[]
*   @default <code>[].concat(Xmla.EVENT_GENERAL, Xmla.EVENT_DISCOVER_ALL, Xmla.EVENT_EXECUTE_ALL)</code>
*/
Xmla.EVENT_ALL = [].concat(
    Xmla.EVENT_GENERAL,
    Xmla.EVENT_DISCOVER_ALL,
    Xmla.EVENT_EXECUTE_ALL
);

/**
*   Can be used as key in the <code>properties</code> member of the <code>options</code> object
*   passed to the <code><a href="#method_request">request()</a></code> method
*   to specify the XML/A <code>DataSourceInfo</code> property.
*   The XML/A <code>DataSourceInfo</code>, together with the XML/A service URL are required to
*   connect to a particular OLAP datasource.
*   Valid values for the <code>DataSourceInfo</code> as well as the corresponding URL should be obtained
*   by querying the <code>DataSourceInfo</code> and <code>URL</code> columns of the <code>DISCOVER_DATASOURCES</code>
*   rowset respectively (see <code><a href="method_discoverDataSources">discoverDataSources()</a></code>).
*
*   @property PROP_DATASOURCEINFO
*   @static
*   @final
*   @type string
*   @default <code>DataSourceInfo</code>
*/
Xmla.PROP_DATASOURCEINFO = "DataSourceInfo";
/**
*   Can be used as key in the <code>properties</code> member of the <code>options</code> object
*   passed to the <code><a href="#method_request">execute()</a></code> method
*   to specify the XML/A <code>Catalog</code> property.
*   The XML/A <code>Catalog</code> spefifies where to look for cubes that are referenced in th MDX statment.
*   Valid values for the <code>Catalog</code> should be obtained
*   by querying the <code>CATALOG_NAME</code> of the <code>DBSCHEMA_CATALOGS</code>
*   rowset (see <code><a href="method_discoverCatalogs">discoverCatalogs()</a></code>).
*
*   @property PROP_Catalog
*   @static
*   @final
*   @type string
*   @default <code>Catalog</code>
*/
Xmla.PROP_CATALOG = "Catalog";
Xmla.PROP_CUBE = "Cube";

/**
*   Can be used as key in the <code>properties</code> member of the <code>options</code> object
*   passed to the <code><a href="#method_execute">execute()</a></code> method
*   to specify the XML/A <code>Format</code> property.
*   This property controls the structure of the resultset.
*
*   @property PROP_FORMAT
*   @static
*   @final
*   @type string
*   @default <code>Format</code>
*/
Xmla.PROP_FORMAT = "Format";
/**
*   Can be used as value for the
*   <code><a href="#property_PROP_FORMAT>PROP_FORMAT</a></code> key of the
*   <code>properties</code> member of the
*   <code>options</code> object passed to the
*   <code><a href="#method_execute">execute()</a></code> method.
*   When used, this specifies that the multidimensional resultset should be returned in a tabular format,
*   causeing the multidimensional resultset to be represented with an instance of the
*   <code><a href="Xmla.Rowset#class_Xmla.Rowset">Xmla.Rowset</a></code> class.
*
*   @property PROP_FORMAT_TABULAR
*   @static
*   @final
*   @type string
*   @default <code>Tabular</code>
*/
Xmla.PROP_FORMAT_TABULAR = "Tabular";
/**
*   Can be used as value for the
*   <code><a href="#property_PROP_FORMAT>PROP_FORMAT</a></code> key of the
*   <code>properties</code> member of the
*   <code>options</code> object passed to the
*   <code><a href="#method_execute">execute()</a></code> method.
*   When used, this specifies that the multidimensional resultset should be returned in a multidimensional format.
*   Currently, Xmla4js does not provide a class to represent the resultset in this format.
*   However, you can access the results as xml through the
*   <code><a href="#property_responseText">responseText</a></code> and
*   <code><a href="#property_responseXML">responseXML</a></code> properties.
*
*   @property PROP_FORMAT_MULTIDIMENSIONAL
*   @static
*   @final
*   @type string
*   @default <code>Multidimensional</code>
*/
Xmla.PROP_FORMAT_MULTIDIMENSIONAL = "Multidimensional";

/**
*   Can be used as key in the <code>properties</code> member of the <code>options</code> object
*   passed to the <code><a href="#method_execute">execute()</a></code> method
*   to specify the XML/A <code>AxisFormat</code> property.
*   The XML/A <code>AxisFormat</code> property specifies how the client wants to receive the multi-dimensional resultset of a MDX query.
*   Valid values for the <code>AxisFormat</code> property are available as the static final properties
*   <code><a href="#property_PROP_AXISFORMAT_TUPLE">PROP_AXISFORMAT_TUPLE</a></code>,
*   <code><a href="#property_PROP_AXISFORMAT_CLUSTER">PROP_AXISFORMAT_CLUSTER</a></code>,
*   <code><a href="#property_PROP_AXISFORMAT_CUSTOM">PROP_AXISFORMAT_CUSTOM</a></code>.
*
*   @property PROP_AXISFORMAT
*   @static
*   @final
*   @type string
*   @default <code>AxisFormat</code>
*/
Xmla.PROP_AXISFORMAT = "AxisFormat";
/**
*   Can be used as value for the <code>AxisFormat</code> XML/A property
*   (see: <code><a href="#property_PROP_AXISFORMAT">PROP_AXISFORMAT</a></code>)
*   in invocations of the <code>Execute</code> method
*   (see: <code><a href="#method_execute">execute()</a></code>).
*
*   @property PROP_AXISFORMAT_TUPLE
*   @static
*   @final
*   @type string
*   @default <code>TupleFormat</code>
*/
Xmla.PROP_AXISFORMAT_TUPLE = "TupleFormat";
/**
*   Can be used as value for the <code>AxisFormat</code> XML/A property
*   (see: <code><a href="#property_PROP_AXISFORMAT">PROP_AXISFORMAT</a></code>)
*   in invocations of the <code>Execute</code> method
*   (see: <code><a href="#method_execute">execute()</a></code>).
*
*   @property PROP_AXISFORMAT_CLUSTER
*   @static
*   @final
*   @type string
*   @default <code>ClusterFormat</code>
*/
Xmla.PROP_AXISFORMAT_CLUSTER = "ClusterFormat";
/**
*   Can be used as value for the <code>AxisFormat</code> XML/A property
*   (see: <code><a href="#property_PROP_AXISFORMAT">PROP_AXISFORMAT</a></code>)
*   in invocations of the <code>Execute</code> method
*   (see: <code><a href="#method_execute">execute()</a></code>).
*
*   @property PROP_AXISFORMAT_CUSTOM
*   @static
*   @final
*   @type string
*   @default <code>CustomFormat</code>
*/
Xmla.PROP_AXISFORMAT_CUSTOM = "CustomFormat";

/**
*   Can be used as key in the <code>properties</code> member of the <code>options</code> object
*   passed to the <code><a href="#method_request">request()</a></code> method
*   to specify the XML/A <code>Content</code> property.
*   The XML/A <code>Content</code> property specifies whether to return data and/or XML Schema metadata by the <code>Discover</code> and <code>Execute</code> invocations.
*   Valid values for the <code>Content</code> property are available as the static final properties
*   <code><a href="#property_PROP_CONTENT_DATA">PROP_CONTENT_DATA</a></code>,
*   <code><a href="#property_PROP_CONTENT_NONE">PROP_CONTENT_NONE</a></code>,
*   <code><a href="#property_PROP_CONTENT_SCHEMA">PROP_CONTENT_SCHEMA</a></code>,
*   <code><a href="#property_PROP_CONTENT_SCHEMADATA">PROP_CONTENT_SCHEMADATA</a></code>.
*
*   Note: This key is primarily intended for clients that use the low-level <code><a href="#method_request">request()</a></code> method.
*   You should not set this property when calling the <code><a href="#method_request">discover()</a></code> method,
*   the <code><a href="#method_execute">execute()</a></code> method,
*   or any of the <code>discoverXXX()</code> methods.
*
*   @property PROP_CONTENT
*   @static
*   @final
*   @type string
*   @default <code>Content</code>
*/
Xmla.PROP_CONTENT = "Content";
/**
*   Can be used as value for the XML/A <code>Content</code> property
*   (see: <code><a href="#property_PROP_CONTENT">PROP_CONTENT</a></code>).
*   This value specifies that the response should contain only data, but no XML Schema metadata.
*
*   As the <code>Xmla</code> class relies on the XML Schema metadata to construct Rowset and Resultset instances,
*   this option is primarily useful if you know how to process the XML response directly.
*
*   @property PROP_CONTENT_DATA
*   @static
*   @final
*   @type string
*   @default <code>Data</code>
*/
Xmla.PROP_CONTENT_DATA = "Data";
/**
*   Can be used as value for the XML/A <code>Content</code> property
*   (see: <code><a href="#property_PROP_CONTENT">PROP_CONTENT</a></code>).
*   This value specifies that the response should contain neither data nor XML Schema metadata.
*   This is useful to check the validity of the request.
*
*   @property PROP_CONTENT_NONE
*   @static
*   @final
*   @type string
*   @default <code>None</code>
*/
Xmla.PROP_CONTENT_NONE = "None";
/**
*   Can be used as value for the XML/A <code>Content</code> property
*   (see: <code><a href="#property_PROP_CONTENT">PROP_CONTENT</a></code>).
*   This value specifies that the response should only return XML Schema metadata, but no data.
*
*   @property PROP_CONTENT_SCHEMA
*   @static
*   @final
*   @type string
*   @default <code>Schema</code>
*/
Xmla.PROP_CONTENT_SCHEMA = "Schema";
/**
*   Can be used as value for the XML/A <code>Content</code> property
*   (see: <code><a href="#property_PROP_CONTENT">PROP_CONTENT</a></code>).
*   This value specifies that the response should return both data as well as XML Schema metadata.
*
*   @property PROP_CONTENT_SCHEMADATA
*   @static
*   @final
*   @type string
*   @default <code>SchemaData</code>
*/
Xmla.PROP_CONTENT_SCHEMADATA = "SchemaData";

Xmla.prototype = {
/**
*   This object stores listeners.
*   Each key is a listener type (see the static final <code>EVENT_XXX</code> constants),
*   each value is an array of listener objects that are subscribed to that particular event.
*
*   @property listeners
*   @protected
*   @type Object
*   @default <pre>
{
&nbsp;     "request": []
&nbsp;,   "succss": []
&nbsp;,   "error": []
&nbsp;,   "discover": []
&nbsp;,   "discoversuccss": []
&nbsp;,   "discovererror": []
&nbsp;,   "execute": []
&nbsp;,   "executesuccss": []
&nbsp;,   "executeerror": []
}</pre>
*/
    listeners: null,
/**
*   The soap message sent in the last request to the server.
*
*   @property soapMessage
*   @type {string}
*   @default <code>null</code>
*/
    soapMessage: null,
/**
*   This property is set to <code>null</code> right before sending an XML/A request.
*   When a successfull response is received, it is processed and the response object is assigned to this property.
*   The response object is either a
*   <code><a href="Rowset.html#class_Rowset">Rowset</a></code> (after a successful invocation of XML/A <code>Discover</code> method, see: <code><a href="method_discover">discover()</a></code>) or a
*   <code><a href="Resultset.html#class_Resultset">Resultset</a></code> (after a successful invocation of the XML/A <code>Execute</code> method, see: <code><a href="method_execute">executte()</a></code>)
*   instance.
*
*   If you are interested in processing the raw response XML, see
*   <code><a href="#property_responseXML">responseXML</a></code> and
*   <code><a href="#property_responseText">responseText</a></code>.
*
*   Note that it is not safe to read this property immediately after doing an asynchronous request.
*   For asynchronous requests, you can read this property by the time the <code>XXX_SUCCESS</code> event handlers are notified (until it is set to <code>null</code> again by a subsequent request).
*
*   @property response
*   @type Xmla.Rowset|Xmla.Resultset
*   @default <code>null</code>
*/
    response: null,
/**
*   This property is set to <code>null</code> right before sending an XML/A request.
*   When a successfull response is received, the XML response is stored to this property as plain text.
*
*   If you are interested in processing a DOM document rather than the raw XML text, see the
*   <code><a href="#property_responseXML">responseXML</a></code> property.
*
*   If you are interested in traversing the dataset returned in the XML/A response, see the
*   <code><a href="#property_response">response</a></code> property.
*
*   Note that it is not safe to read this property immediately after doing an asynchronous request.
*   For asynchronous requests, you can read this property by the time the <code>XXX_SUCCESS</code> event handlers are notified (until it is set to <code>null</code> again by a subsequent request).
*
*   @property responseText
*   @type {string}
*   @default <code>null</code>
*/
    responseText: null,
/**
*   This property is set to <code>null</code> right before sending an XML/A request.
*   When a successfull response is received, the XML response is stored to this property as a DOM Document.
*
*   If you are interested in processing the raw XML text rather than a DOM document, see the
*   <code><a href="#property_responseText">responseText</a></code> property.
*
*   If you are interested in traversing the dataset returned in the XML/A response, see the
*   <code><a href="#property_response">response</a></code> property.
*
*   Note that it is not safe to read this property immediately after doing an asynchronous request.
*   For asynchronous requests, you can read this property by the time the <code>XXX_SUCCESS</code> event handlers are notified (until it is set to <code>null</code> again by a subsequent request).
*
*   @property responseXML
*   @type {DOMDocument}
*   @default <code>null</code>
*/
    responseXML: null,
/**
*    This method can be used to set a number of default options for the Xmla instance.
*    This is especially useful if you don't want to pass each and every option to each method call all the time.
*    Where appropriate, information that is missing from the parameter objects passed to the methods of the Xmla object
*   may be augmented with the values set through this method.
*    For example, if you plan to do a series of requests pertaining to one particular datasource,
*    you can set the mandatory options like url, async, datasource and catalog just once:
*    <pre>
&nbsp;   xml.setOptions({
&nbsp;       url: "http://localhost:8080/pentaho/Xmla",
&nbsp;       async: true,
&nbsp;       properties: {
&nbsp;           DataSourceInfo: "Pentaho Analysis Services",
&nbsp;           Catalog: "Foodmart"
&nbsp;       }
&nbsp;   });
*    </pre>
*    Then, a subsequent <code></code>
*    @method setOptions
*    @param Object
*/
    setOptions: function(options){
        _applyProps(
            this.options,
            options,
            true
        );
    },
/**
*   This method can be used to register one or more listeners. On such listener can listen for one or more events.
*   <p>For a single listener, you can pass a <code>listener</code> object literal with the following structure:</p><pre>{
*       events: ...event name or array of event names...,
*       handler: ...function or array of functions...,
*       scope: object
*   }</pre>
*   <p>
*       You can use <code>event</code> as an alias for <code>events</code>.
*       Likewise, you can use <code>handlers</code> as an alias for <code>handler</code>.
*   </p>
*   <p>
*       Alternatively, you can pass the element as separate arguments instead of as an object literal:
*       <code>addListener(name, func, scope)</code>
*       where name is a valid event name, func is the function that is to be called when the event occurs.
*       The last argument is optional and can be used to specify the scope that will be used as context for executing the function.
*   </p>
*   <p>
*       To register multiple listeners, pass an array of listener objects:
*       <code>addListener([listener1, ..., listenerN])</code>
*   </p>
*   <p>
*       Alternatively, pass multiple listener objects as separate arguments:
*       <code>addListener(listener1, ..., listenerN)</code>
*   </p>
*   <p>
*       Or, pass a single object literal with event names as keys and listener objects or functions as values:
*       <pre>addListener({
*           discover: function() {
*               ...handle discover event...
*           },
*           error: {
*               handler: function() {
*                  ...handle error event...
*               },
*               scope: obj
*           },
*           scope: defaultscope
*       })</pre>
*       In this case, you can use scope as a key to specify the default scope for the handler functions.
*   </p>
*   <p>Below is a more detailed description of the listener object and its components:</p>
*   <dl>
*       <dt><code>events</code></dt>
*       <dd><code>string</code>|<code>string[]</code> REQUIRED.
*       The event or events to listen to.
*       You can specify a single event by using one of the <code>EVENT_XXX</code> string constant values.
*       You can specify multiple events by using an array of <code>EVENT_XXX</code> string constant values.
*       You can also use one of the predefined <code>EVENT_XXX</code> array constant values,
*       or use array concatenation and compose a custom list of event names.
*       To listen to all events, either use <code><a href="#property_EVENT_ALL">EVENT_ALL</a></code>,
*       or otherwise the <code>string</code> value <code>"all"</code>.
*       </dd>
*       <dt><code>event</code></dt>
*       <dd><code>string</code>|<code>string[]</code> Alias for <code>events</code></dd>
*       <dt><code>handler</code></dt>
*       <dd><code>function</code>|<code>function[]</code> REQUIRED.
*       This function will be called and notified whenever one of the specified events occurs.
*       The function has the following signature: <code>boolean handler(string eventName, object eventData, Xmla xmla)</code>
*       You can also pass in an array of functions if you want multiple functions to be called when the event occurs.
*       The function is called in scope of the <code>scope</code> property of the listener object.
*       If no <code>scope</code> is specified, a global function is assumed.
*       The <code>handler</code> function has the following arguments:
*           <dl>
*               <dt><code>eventName</code></dt>
*               <dd><code>string</code> The event for which notification is given.
*               This is useful to distinguish between events in case the same handler function is used for multiple events.
*               In this case, use the <code>EVENT_XXX</code> constants to check the <code>eventName</code>.</dd>
*               <dt><code>eventData</code></dt>
*               <dd><code>Object</code> An object that conveys event-specific data.</dd>
*               <dt><code>xmla</code></dt>
*               <dd><code><a href="class_Xmla">Xmla</a></code> A reference to this <code>Xmla</code> instance that is the source of the event.
*                   Listeners can obtain the response as well as the original SOAP message sent to the server through this instance.
*                   This allows one listener to be shared across multiple <code>Xmla</code> instances without managing the context manually.
*               </dd>
*           </dl>
*       For events that are <em>cancelable</em>, the handler should return a <code>boolean</code>.
*       If the handler returns <code>false</code> the respective operation will be canceled.
*       Otherwise, the operation continues (but may be canceled by another handler).
*       Currently, the following events are cancelable:
*       <code><a href="#property_EVENT_DISCOVER">EVENT_DISCOVER</a></code>,
*       <code><a href="#property_EVENT_EXECUTE">EVENT_EXECUTE</a></code>, and
*       <code><a href="#property_EVENT_REQUEST">EVENT_REQUEST</a></code>.
*       </dd>
*       <dt><code>handlers</code></dt>
*       <dd><code>function</code>|<code>function[]</code> Alias for <code>handler</code></dd>
*       <dt><code>scope</code></dt>
*       <dd><code>Object</code> OPTIONAL When specified, this object is used as the <code>this</code> object when calling the handler.
*           When not specified, the global <code>window</code> is used.
*       </dd>
*   </dl>
*   @method addListener
*   @param {Object|Array} listener An object that defines the events and the notification function to be called, or an array of such objects.
*/
    addListener: function(){
        var n = arguments.length;
        switch(n) {
            case 0:
                Xmla.Exception._newError(
                    "NO_EVENTS_SPECIFIED",
                    "Xmla.addListener",
                    null
                )._throw();
            case 1:
                var arg = arguments[0];
                if (_isObj(arg)) {
                    var events, handlers;
                    if (_isArr(arg)) this._addListeners(arg)
                    else
                    if (events = arg.events || arg.event) {
                        if (_isStr(events)) events = (events==="all") ? Xmla.EVENT_ALL : events.split(",");
                        if (!(_isArr(events))){
                            Xmla.Exception._newError(
                                "WRONG_EVENTS_FORMAT",
                                "Xmla.addListener",
                                arg
                            )._throw();
                        }
                        var i, n = events.length;
                        for (i = 0; i < n; i++) this._addListener(events[i], arg);
                    }
                    else {
                        var scope = arg.scope, handler;
                        if (_isUnd(scope)) scope = null;
                        else delete arg.scope;
                        for (events in arg) {
                            handler = arg[events];
                            if (_isUnd(handler.scope)) handler.scope = scope;
                            this._addListener(events, handler);
                        }
                    }
                }
                else
                    Xmla.Exception._newError(
                        "WRONG_EVENTS_FORMAT",
                        "Xmla.addListener",
                        arg
                    )._throw();
                break;
            case 2:
            case 3:
                var event = arguments[0], handler = arguments[1], scope = arguments[2];
                if (_isStr(event) && (_isFun(handler)||(_isObj(handler)))) this._addListener(event, handler, scope);
                else {
                    var arr = [event, handler];
                    if (scope) arr.push(scope);
                    this.addListener(arr);
                }
                break;
            default:
                this._addListeners(arguments);
        }
    },
    _addListeners: function(listeners) {
        var i, n = listeners.length;
        for (i = 0; i < n; i++) this.addListener(listeners[i]);
    },
    _addListener: function(name, handler, scope) {
        var myListeners = this.listeners[name];
        if (!myListeners)
            Xmla.Exception._newError(
                "UNKNOWN_EVENT",
                "Xmla.addListener",
                {event: name, handler: handler, scope: scope}
            )._throw();
        if (!scope) scope = null;
        switch (typeof(handler)) {
            case "function":
                myListeners.concat({handler: handler, scope: scope});
                break;
            case "object":
                var handlers = handler.handler || handler.handlers;
                if (_isFun(handlers.handler)) {
                    if (!handlers.scope) handlers.scope = scope;
                    myListeners.concat(handler);
                }
                else
                if (_isArr(handlers)) {
                    var i, n = handlers.length;
                    for (i = 0; i < n; i++) this._addListener(name, handlers[i]);
                }
                break;
        }
    },
    _fireEvent: function(eventName, eventData, cancelable){
        var listeners = this.listeners[eventName];
        if (!listeners) {
            Xmla.Exception._newError(
                "UNKNOWN_EVENT",
                "Xmla._fireEvent",
                eventName
            )._throw();
        }
        var n = listeners.length, outcome = true;
        if (n) {
            var listener, listenerResult, i;
            for (i = 0; i < n; i++){
                listener = listeners[i];
                listenerResult = listener.handler.call(
                    listener.scope,
                    eventName,
                    eventData,
                    this
                );
                if (cancelable && listenerResult===false){
                    outcome = false;
                    break;
                }
            }
        }
        else //if there is neither a listener nor an error nor a general callback  we explicitly throw the exception.
        if (eventName === Xmla.EVENT_ERROR && !_isFun(eventData.error) && !_isFun(eventData.callback)) eventData.exception._throw();
        return outcome;
    },
/**
*   Sends a request to the XML/A server.
*   This method is rather low-level and allows full control over the request
*   by passing an options object. General properties of the options object are:
*   <ul>
*       <li><code>method</code> {string} REQUIRED the XML/A method to invoke. This should be one of the following constants:
*           <dl>
*               <dt><code><a href="#property_METHOD_DISCOVER">METHOD_DISCOVER</a></code></dt>
*               <dd>
*                   <p>
*                   This method is used to obtain metadata from the XML/A service or XML/A provider.
*                   Metadata is returned in a tabular format called Schema Rowsets, which are represented by an instance of the
*                   <code><a href="Xmla.Rowset.html#class_Xmla.Rowset">Xmla.Rowset</a></code> class.
*                   For these types of requests, you must pass the <code>requestType</code> option to specify which schema rowset you want to obtain.
*                   In addition, you can specify a <code>restrictions</code> object that is used as filter criteria to restrict which rows will be returned in the rowset.
*                   </p>
*                   <p>
*                   Instead of explicitly passing <code>METHOD_DISCOVER</code> as the <code>requestType</code>, you can also call the
*                   <code><a href="#method_discover">discover()</a></code> method (which requires you to explictly pass a <code>requestType</code> option).
*                   Finally, you can also call one of the <code>discoverXXX()</code> methods in order to request a particular schema rowset.
*                   </p>
*               </dd>
*               <dt><code><a href="#property_METHOD_EXECUTE">METHOD_EXECUTE</a></code></dt>
*               <dd>
*                   <p>
*                   This method is used to send an MDX quey to the XML/A provider.
*                   Query results are returned in a multidimentsional format which is represented by an instance of the
*                   <code><a href="Xmla.Resultset.html#class_Xmla.Resultset">Xmla.Resultset</a></code> class.
*                   For these types of requests, you must pass the <code>statement</code> option to specify the MDX query.
*                   </p>
*                   <p>
*                   Instead of explicitly passing <code>METHOD_EXECUTE</code> as the <code>requestType</code>, you can also call the
*                   <code><a href="#method_execute">execute()</a></code> method.
*                   </p>
*               </dd>
*           </dl>
*       </li>
*       <li><code>url</code> {string} REQUIRED the URL of XML/A service, or of a XML/A datasource.
*           Typically, you first use the URL of a XML/A service (like <code>http://your.pentaho.server:8080/pentaho/Xmla?userid=joe&amp;password=password</code>)
*           and use that to retrieve the <code>DISCOVER_DATASOURCES</code> rowset.
*           Then, you can connect to a XML/A datasource using the value returned by the <code>URL</code> column of the <code>DISCOVER_DATASOURCES</code> rowset
*           (typically, you also have to set a <code>DataSourceInfo</code> property using the value found in the <code>DataSourceInfo</code> column of the <code>DISCOVER_DATASOURCES</code> rowset).
*       </li>
*       <li>
*           <code>properties</code> {Object} XML/A properties.
*           The appropriate types and values of XML/A properties are dependent upon the specific method and requestType.
*           The XML/A standard defines a set of pre-defined properties.
*           The <code>Xmla</code> class defines a static final property for each of these (see the <code>PROP_XXX</code> constants).
*           The list of all valid properties can be obtained from the <code>DISCOVER_PROPERTIES</code> schema rowset
*           (see <code><a href="#method_discoverProperties()">discoverProperties()</a></code>).
*           Each javascript property of the <code>properties</code> object is mapped literally to a XML/A property.
*       </li>
*       <li><code>async</code> {boolean}
*           Determines how the request is performed:<ul>
*               <li><code>true</code>: The request is performed asynchronously: the call to <code>request()</code> will not block and return immediately.
*               In this case, the return value of the <code>request()</code> method is not defined,
*               and the response must be received by registering a listener.
*               (see <code><a href="#method_addListener">addListener()</a></code>).
*
*               As an alternative to using listeners, you can also pass
*               <code>success</code>, <code>error</code> and <code>callback</code> callback functions.
*               Callbacks are described in more detail below.
*               </li>
*               <li><code>false</code>: The request is performed synchronously: the call to <code>request()</code> will block until it receives a response from the XML/A server or times out.
*               In this case, the <code>request()</code> method returns
*               a <code>Rowset</code> (for <code>Discover</code> requests) or
*               a <code>Resultset</code> (for <code>Execute</code> requests).
*               If you registered any listeners (see <code><a href="#method_addListener">addListener()</a></code>),
*               then these will still be notified of any events (such as receiving the response).
*               </li>
*           </ul>
*       </li>
*       <li><code>success</code> (function)
*           A function that is to be called after the requests is executed and a successful response is receieved.
*           Any listeners appropriate for the request are called after this handler is executed.
*       </li>
*       <li><code>error</code> (function)
*           A function that is to be called after the requests is executed and an error was encountered.
*           Any listeners appropriate for the request are called after this handler is executed.
*       </li>
*       <li><code>callback</code> (function)
*           A function that is to be called after the requests is executed and the response is receieved,
*           and after calling any listeners that are appropriate for the request.
*           This function will be called both in case of success and of error.
*           If the options also contain a <code>success</code> and/or <code>error</code> handler, then
*           <code>callback</code> will be called after those more specific handlers are called.
*       </li>
*   </ul>
*   Other parts of the <code>options</code> object are method-specific.
*   <ul>
*       <li>The following options are applicable in case the <code>method</code> is <code>METHOD_DISCOVER</code>:
*           <ul>
*               <li><code>requestType</code> - {string} Applies to the Discover method and indicates the kind of schema rowset to retrieve.
*                   You can use one of the <code>DISCOVER_XXX</code>, <code>DBSCHEMA_XXX</code> or <code>MDSCHEMA_XXX</code> constants for this property.
*                   You can also dymically discover which values for <code>requestType</code> are supported by the XML/A provider using the
*                   <code>DISCOVER_SCHEMA_ROWSETS</code> rowset (see: <code><a href="method_discoverMDSchemaRowsets">discoverMDSchemaRowsets()</a></code>).
*                   See the <code><a href="#method_discover">discover()</a></code> method for more information.
*               </li>
*               <li>
*                   <code>restrictions</code> {Object} XML/A restrictions are used to filter the requested schema rowset.
*                   For more information on restrictions, see the <code><a href="#method_discover">discover()</a></code> method.
*               </li>
*           </ul>
*       </li>
*       <li>The following options are applicable in case the <code>method</code> is <code>METHOD_EXECUTE</code>:
*           <ul>
*               <li><code>statement</code> - {string} Applies to the Execute method and specifies the MDX query to send to the server.
*               </li>
*           </ul>
*       </li>
*   </ul>
*   Instead of calling this method directly, consider calling
*   <code><a href="#method_discover">discover()</a></code> (to obtain a schema rowset),
*   <code><a href="#method_execute">execute()</a></code> (to issue a MDX query),
*   or one of the specialized <code>discoverXXX()</code> methods (to obtain a particular schema rowset).
*   @method request
*   @param {Object} options An object whose properties convey the options for the request.
*   @return {Xmla.Rowset|Xmla.Resultset} The result of the invoking the XML/A method. For an asynchronous request, the return value is not defined. For synchronous requests, <code>Discover</code> requests return an instance of a <code>Xmla.Rowset</code>, and <code>Execute</code> results return an instance of a <code>Xmla.Resultset</code>.
*/
    request: function(options){
        var ex, xmla = this;

        this.response = null;
        this.responseText = null;
        this.responseXML = null;

        if (!options.url){
            if (this.options.url){
                options.url = this.options.url;
            }
            else {
                ex = Xmla.Exception._newError(
                    "MISSING_URL",
                    "Xmla.request",
                    options
                );
                ex._throw();
            }
        }

        options.properties = _applyProps(options.properties, this.options.properties, false);
        options.restrictions = _applyProps(options.restrictions, this.options.restrictions, false);
        if (_isUnd(options.async) && !_isUnd(this.options.async)){
            options.async = this.options.async;
        }
        if (_isUnd(options.requestTimeout) && !_isUnd(this.options.requestTimeout)) {
            options.requestTimeout = this.options.requestTimeout;
        }
        if (!options.username && this.options.username){
            options.username = this.options.username;
        }
        if (!options.password && this.options.password){
            options.password = this.options.password;
        }
        if (!options.headers && this.options.headers){
            options.headers = this.options.headers;
        }

        var soapMessage = _getXmlaSoapMessage(options);
        this.soapMessage = soapMessage;
        var myXhr;
        var ajaxOptions = {
            async: options.async,
            timeout: options.requestTimeout,
            data: soapMessage,
            error:      function(exception){
                            options.exception = exception;
                            xmla._requestError(options);
                        },
            complete:   function(xhr){
                            options.xhr = xhr;
                            xmla._requestSuccess(options);
                        },
            url: options.url
        };
        if (options.username){
            ajaxOptions.username = options.username;
        }
        if (options.password){
            ajaxOptions.password = options.password;
        }
        if (options.headers) {
            ajaxOptions.headers = options.headers;
        }

        if  (this._fireEvent(Xmla.EVENT_REQUEST, options, true) &&
                (
                    (options.method == Xmla.METHOD_DISCOVER && this._fireEvent(Xmla.EVENT_DISCOVER, options)) ||
                    (options.method == Xmla.METHOD_EXECUTE  && this._fireEvent(Xmla.EVENT_EXECUTE, options))
                )
        ) {
            myXhr = _ajax(ajaxOptions);
        }
        return this.response;
    },
    _requestError: function(options) {
        if (options.error) {
            options.error.call(
                options.scope ? options.scope : null,
                this,
                options,
                null
            );
        }
        if (options.callback) {
            options.callback.call(
                options.scope ? options.scope : null,
                Xmla.EVENT_ERROR,
                this,
                options,
                null
            );
        }
        this._fireEvent(Xmla.EVENT_ERROR, options);
    },
    _requestSuccess: function(request) {
        var xhr = request.xhr, response;
        this.responseXML = xhr.responseXML;
        this.responseText = xhr.responseText;

        var method = request.method;

        var soapFault = _getElementsByTagNameNS(this.responseXML, _xmlnsSOAPenvelope, _xmlnsSOAPenvelopePrefix, "Fault");
        if (soapFault.length) {
            //TODO: extract error info
            soapFault = soapFault.item(0);
            request.exception = new Xmla.Exception(
                Xmla.Exception.TYPE_ERROR,
                soapFault.getElementsByTagName("faultcode").item(0).childNodes.item(0).data,
                soapFault.getElementsByTagName("faultstring").item(0).childNodes.item(0).data,
                null,
                "_requestSuccess",
                request
            );
            switch(method){
                case Xmla.METHOD_DISCOVER:
                    this._fireEvent(Xmla.EVENT_DISCOVER_ERROR, request);
                    break;
                case Xmla.METHOD_EXECUTE:
                    this._fireEvent(Xmla.EVENT_EXECUTE_ERROR, request);
                    break;
            }
            if (request.error) {
                request.error.call(
                    request.scope ? request.scope : null,
                    this,
                    request,
                    request.exception
                );
            }
            if (request.callback) {
                request.callback.call(
                    request.scope ? request.scope : null,
                    Xmla.EVENT_ERROR,
                    this,
                    request,
                    request.exception
                );
            }
            this._fireEvent(Xmla.EVENT_ERROR, request);
        }
        else {
            switch(method){
                case Xmla.METHOD_DISCOVER:
                    request.rowset = this.response = response = new Xmla.Rowset(this.responseXML, request.requestType, this);
                    this._fireEvent(Xmla.EVENT_DISCOVER_SUCCESS, request);
                    break;
                case Xmla.METHOD_EXECUTE:
                    var resultset = null, dataset = null;
                    var format = request.properties[Xmla.PROP_FORMAT];
                    switch(format){
                        case Xmla.PROP_FORMAT_TABULAR:
                            response = resultset = new Xmla.Rowset(this.responseXML, null, this);
                            break;
                        case Xmla.PROP_FORMAT_MULTIDIMENSIONAL:
                            response = dataset = new Xmla.Dataset(this.responseXML);
                            break;
                    }
                    request.resultset = resultset;
                    request.dataset = dataset;
                    this.response = response;
                    this._fireEvent(Xmla.EVENT_EXECUTE_SUCCESS, request);
                    break;
            }
            if (request.success) {
                request.success.call(
                    request.scope ? request.scope : null,
                    this,
                    request,
                    response
                );
            }
            if (request.callback) {
                request.callback.call(
                    request.scope ? request.scope : null,
                    Xmla.EVENT_SUCCESS,
                    this,
                    request,
                    response
                );
            }
            this._fireEvent(Xmla.EVENT_SUCCESS, request);
        }
    },
/**
*   Sends an MDX query to a XML/A DataSource to invoke the XML/A <code>Execute</code> method and obtain the multi-dimensional resultset.
*   Options are passed using a generic <code>options</code> object.
*   Applicable properties of the <code>options</code> object are:
*   <ul>
*       <li><code>url</code> {string} REQUIRED the URL of a XML/A datasource.
*           This should be a value obtained from the <code>URL</code> column of the <code>DISCOVER_DATASOURCES</code> rowset
*           (see: <code><a href="method_discoverDataSources">discoverDataSources()</a></code>).
*       </li>
*       <li><code>statement</code> - {string} The MDX query to send to the server.
*       </li>
*       <li>
*           <code>properties</code> {Object} XML/A properties.
*           The list of all valid properties can be obtained from the <code>DISCOVER_PROPERTIES</code> schema rowset
*           (see <code><a href="#method_discoverProperties()">discoverProperties()</a></code>).
*           Typically, <code>execute()</code> requires these properties:<dl>
*               <dt><code>DataSourceInfo</code> property</dt>
*               <dd>Identifies a data source managed by the XML/A server.
*                   To specify this property, you can use the static final constant
*                   <code><a href="#property_PROP_DATASOURCEINFO">PROP_DATASOURCEINFO</a></code>
*                   as key in the <code>properties</code> object of the <code>options</code> object passed to the <code>execute()</code> method.
*                   Valid values for this property should be obtained from the <code>DataSourceInfo</code> column
*                   of the <code>DISCOVER_DATASOURCES</code> schema rowset (see: <code><a href="#method_discoverDataSources">discoverDataSources()</a></code>).
*                   Note that the values for the <code>DataSourceInfo</code> property and the <code>url</code> must both be taken from the same row of the <code>DISCOVER_DATASOURCES</code> schema rowset.
*               </dd>
*               <dt><code>Catalog</code> property</dt>
*               <dd>Identifies a catalog applicable for the datasource.
*                   To specify this property, you can use the static final constant
*                   <code><a href="#property_PROP_CATALOG">PROP_CATALOG</a></code>
*                   as key in the <code>properties</code> object of the <code>options</code> object passed to the <code>execute()</code> method.
*                   Valid values for this property should be obtained from the <code>CATALOG_NAME</code> column
*                   of the <code>DBSCHEMA_CATALOGS</code> schema rowset (see: <code><a href="#method_discoverDBCatalogs">discoverDBCatalogs()</a></code>).
*               </dd>
*           </dl>
*       </li>
*       <li><code>async</code> {boolean}
*           Determines how the request is performed:<ul>
*               <li><code>true</code>: The request is performed asynchronously: the call to <code>request()</code> will not block and return immediately.
*               In this case, the return value of the <code>request()</code> method is not defined,
*               and the response must be received by registering a listener
*               (see <code><a href="#method_addListener">addListener()</a></code>).
*               </li>
*               <li><code>false</code>: The request is performed synchronously: the call to <code>execute()</code> will block until it receives a response from the XML/A server or times out.
*               In this case, a <code>Resultset</code> is returned that represents the multi-dimensional data set.
*               If you registered any <code>REQUEST_XXX</code> and/or <code>EXECUTE_XXX</code> listeners (see <code><a href="#method_addListener">addListener()</a></code>),
*               then these will still be notified.
*               </li>
*           </ul>
*       </li>
*   </ul>
*   @method execute
*   @param {Object} options An object whose properties convey the options for the XML/A <code>Execute</code> request.
*   @return {Xmla.Resultset|Xmla.Rowset} The result of the invoking the XML/A <code>Execute</code> method. For an asynchronous request, the return value is not defined. For synchronous requests, an instance of a <code>Xmla.Resultset</code> that represents the multi-dimensional result set of the MDX query. If the <code>Format</code> property in the request was set to <code>Tabular</code>, then an instance of the
<code><a href="Xmla.Rowset#class_Xmla.Rowset">Rowset</a></code> class is returned to represent the <code>Resultset</code>.
*/
    execute: function(options) {
        var properties = options.properties;
        if (!properties){
            properties = {};
            options.properties = properties;
        }
        _applyProps(properties, this.options.properties, false)
        if (!properties[Xmla.PROP_CONTENT]){
            properties[Xmla.PROP_CONTENT] = Xmla.PROP_CONTENT_SCHEMADATA;
        }
        if (!properties[Xmla.PROP_FORMAT]){
            options.properties[Xmla.PROP_FORMAT] = Xmla.PROP_FORMAT_MULTIDIMENSIONAL;
        }
        var request = _applyProps(
            options,
            {
                method: Xmla.METHOD_EXECUTE
            },
            true
        );
        return this.request(request);
    },
/**
*   Sends an MDX query to a XML/A DataSource to invoke the <code><a href="#method_execute">execute()</a></code> method using <code><a href="#property_PROP_FORMAT_TABULAR">PROP_FORMAT_TABULAR</a></code> as value for the <code><a href="#property_PROP_FORMAT_TABULAR">PROP_FORMAT</a></code> property. This has the effect of obtaining the multi-dimensional resultset as a <code><a href="Xmla.Rowset#class_Xmla.Rowset">Rowset</a></code>.
*   @method executeTabular
*   @param {Object} options An object whose properties convey the options for the XML/A <code>Execute</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Execute</code> method. For an asynchronous request, the return value is not defined. For synchronous requests, an instance of a <code>Xmla.Rowset</code> that represents the multi-dimensional result set of the MDX query.
*/
    executeTabular: function(options){
        if (!options.properties){
            options.properties = {};
        }
        options.properties[Xmla.PROP_FORMAT] = Xmla.PROP_FORMAT_TABULAR;
        return this.execute(options);
    },
/**
*   Sends an MDX query to a XML/A DataSource to invoke the <code><a href="#method_execute</a></code> method using <code><a href="#property_PROP_FORMAT_MULTIDIMENSIONAL">PROP_FORMAT_MULTIDIMENSIONAL</a></code> as value for the <code><a href="#property_PROP_FORMAT_TABULAR">PROP_FORMAT</a></code> property. In this case, the result is available only as XML text or XML document in the <code><a href="#property_responseText">responseText</a></code>
and  <code><a href="#property_responseXML">responseXML</a></code> properties.
*   @method executeMultiDimensional
*   @param {Object} options An object whose properties convey the options for the XML/A <code>Execute</code> request.
*/
    executeMultiDimensional: function(options){
        if (!options.properties){
            options.properties = {};
        }
        options.properties[Xmla.PROP_FORMAT] = Xmla.PROP_FORMAT_MULTIDIMENSIONAL;
        return this.execute(options);
    },
/**
*   Sends a request to invoke the XML/A <code>Discover</code> method and returns a schema rowset specified by the <code>requestType</code> option.
*   Options are passed using a generic <code>options</code> object.
*   Applicable properties of the <code>options</code> object are:
*   <ul>
*       <li><code>requestType</code> - {string} Indicates the kind of schema rowset to retrieve.
*           You can use one of the following predefined XML for Analysis Schema Rowset constants:
*           <ul>
*               <li><code><a href="#property_DISCOVER_DATASOURCES">DISCOVER_DATASOURCES</a></code></li>
*               <li><code><a href="#property_DISCOVER_ENUMERATORS">DISCOVER_ENUMERATORS</a></code></li>
*               <li><code><a href="#property_DISCOVER_KEYWORDS">DISCOVER_KEYWORDS</a></code></li>
*               <li><code><a href="#property_DISCOVER_LITERALS">DISCOVER_LITERALS</a></code></li>
*               <li><code><a href="#property_DISCOVER_PROPERTIES">DISCOVER_PROPERTIES</a></code></li>
*               <li><code><a href="#property_DISCOVER_SCHEMA_ROWSETS">DISCOVER_SCHEMA_ROWSETS</a></code></li>
*           </ul>
*           Or one of the applicable OLE DB Schema Rowset constants:
*           <ul>
*               <li><code><a href="#property_DBSCHEMA_CATALOGS">DBSCHEMA_CATALOGS</a></code></li>
*               <li><code><a href="#property_DBSCHEMA_COLUMNS">DBSCHEMA_COLUMNS</a></code></li>
*               <li><code><a href="#property_DBSCHEMA_PROVIDER_TYPES">DBSCHEMA_PROVIDER_TYPES</a></code></li>
*               <li><code><a href="#property_DBSCHEMA_SCHEMATA">DBSCHEMA_SCHEMATA</a></code></li>
*               <li><code><a href="#property_DBSCHEMA_TABLES">DBSCHEMA_TABLES</a></code></li>
*               <li><code><a href="#property_DBSCHEMA_TABLES_INFO">DBSCHEMA_TABLES_INFO</a></code></li>
*           </ul>
*           Or one of the applicable OLE DB for OLAP Schema Rowset constants:
*           <ul>
*               <li><code><a href="#property_MDSCHEMA_ACTIONS">MDSCHEMA_ACTIONS</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_CUBES">MDSCHEMA_CUBES</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_DIMENSIONS">MDSCHEMA_DIMENSIONS</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_FUNCTIONS">MDSCHEMA_FUNCTIONS</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_HIERARCHIES">MDSCHEMA_HIERARCHIES</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_MEASURES">MDSCHEMA_MEASURES</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_MEMBERS">MDSCHEMA_MEMBERS</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_PROPERTIES">MDSCHEMA_PROPERTIES</a></code></li>
*               <li><code><a href="#property_MDSCHEMA_SETS">MDSCHEMA_SETS</a></code></li>
*           </ul>
*           You can also dymically discover which values for <code>requestType</code> are supported by the XML/A provider.
*           To do that, refer to the <code>SchemaName</code> column of the <code>DISCOVER_SCHEMA_ROWSETS</code> rowset
*           (see: <code><a href="method_discoverMDSchemaRowsets">discoverMDSchemaRowsets()</a></code>).
*       </li>
*       <li><code>url</code> {string} REQUIRED the url of the XML/A service or XML/A datasource.
*           If the value for the <code>requestType</code> option is one of the predefined XML/A <code><a href="">DISCOVER_XXX</a></code> constants,
*           then this should be the url of the XML/A service.
*       </li>
*       <li>
*           <code>properties</code> {Object} XML/A properties.
*           The appropriate types and values of XML/A properties are dependent upon the value passed as <code>requestType</code>.
*           The XML/A standard defines a set of pre-defined properties.
*           The <code>Xmla</code> class defines a static final property for each of these (see the <code>PROP_XXX</code> constants).
*           The list of all valid properties can be obtained from the <code>DISCOVER_PROPERTIES</code> schema rowset
*           (see <code><a href="#method_discoverProperties()">discoverProperties()</a></code>).
*           Each javascript property of the <code>properties</code> object is mapped literally to a XML/A property.
*       </li>
*       <li>
*           <code>restrictions</code> {Object} XML/A restrictions.
*           These are used to specify a filter that will be applied to the data in the schema rowset.
*           Each javascript property of the <code>restrictions</code> object is mapped to a column of the requested schema rowset.
*           The value for the restriction is sent with the request, and processed by the XML/A server to only return matching rows from the requested schema dataset.
*           The name, types and values of the restrictions are dependent upon which schema rowset is requested.
*           The available restrictions are specified by the <code>Restrictions</code> column of the <code>DISCOVER_SCHEMA_ROWSETS</code> schema rowset.
*           For a number of schema rowsets, the available restrictions are pre-defined.
*           These are documented together with each particular <code>discoverXXX()</code> method.
*       </li>
*       <li><code>async</code> {boolean}
*           Determines how the request is performed:<ul>
*               <li><code>true</code>: The request is performed asynchronously: the call to <code>request()</code> will not block and return immediately.
*               In this case, the return value of the <code>request()</code> method is not defined,
*               and the response must be received by registering a listener
*               (see <code><a href="#method_addListener">addListener()</a></code>).
*               </li>
*               <li><code>false</code>: The request is performed synchronously: the call to <code>execute()</code> will block until it receives a response from the XML/A server or times out.
*               In this case, a <code>Resultset</code> is returned that represents the multi-dimensional data set.
*               If you registered any <code>REQUEST_XXX</code> and/or <code>EXECUTE_XXX</code> listeners (see <code><a href="#method_addListener">addListener()</a></code>),
*               then these will still be notified.
*               </li>
*           </ul>
*       </li>
*   </ul>
*   Instead of calling this method directly, consider calling
*   or one of the specialized <code>discoverXXX()</code> methods to obtain a particular schema rowset.
*   @method discover
*   @param {Object} options An object whose properties convey the options for the XML/A <code>Discover</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the requested schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discover: function(options) {
        var request = _applyProps(
            options,
            {
                method: Xmla.METHOD_DISCOVER
            },
            true
        );
        if (!request.requestType){
            request.requestType = this.options.requestType;
        }
        return this.request(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using <code><a href="#property_DISCOVER_DATASOURCES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DISCOVER_DATASOURCES</code> schema rowset.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>
*               DataSourceName
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               A name that identifies this data source.
*           </td>
*           <td>
*               Yes
*           </td>
*           <td>
*               No
*           </td>
*       </tr>
*       <tr>
*           <td>
*               DataSourceDescription
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               Human readable description of the datasource
*           </td>
*           <td>
*               No
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*       <tr>
*           <td>
*               URL
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               URL to use to submit requests to this provider.
*           </td>
*           <td>
*               Yes
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*       <tr>
*           <td>
*               DataSourceInfo
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               Connectstring
*           </td>
*           <td>
*               No
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*       <tr>
*           <td>
*               ProviderName
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               A name indicating the product providing the XML/A implementation
*           </td>
*           <td>
*               Yes
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*       <tr>
*           <td>
*               ProviderType
*           </td>
*           <td>
*               string[]
*           </td>
*           <td>
*               The kind of data sets supported by this provider.
*               The following values are defined by the XML/A specification:
*               <dl>
*                   <dt>TDP</dt><dd>tabular data provider.</dd>
*                   <dt>MDP</dt><dd>multidimensiona data provider.</dd>
*                   <dt>DMP</dt><dd>data mining provider.</dd>
*               </dl>
*               Note: multiple values are possible.
*           </td>
*           <td>
*               Yes
*           </td>
*           <td>
*               No
*           </td>
*       </tr>
*       <tr>
*           <td>
*               AuthenticationMode
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               Type of security offered by the provider
*               The following values are defined by the XML/A specification:
*               <dl>
*                   <dt>Unauthenticated</dt><dd>no user ID or password needs to be sent.</dd>
*                   <dt>Authenticated</dt><dd>User ID and password must be included in the information required for the connection.</dd>
*                   <dt>Integrated</dt><dd> the data source uses the underlying security to determine authorization</dd>
*               </dl>
*           </td>
*           <td>
*               Yes
*           </td>
*           <td>
*               No
*           </td>
*       </tr>
*   </table>
*
*   @method discoverDataSources
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DISCOVER_DATASOURCES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DISCOVER_DATASOURCES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverDataSources: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DISCOVER_DATASOURCES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using <code><a href="#property_DISCOVER_PROPERTIES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DISCOVER_PROPERTIES</code> schema rowset.
*   This rowset provides information on the properties that are supported by the XML/A provider.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>
*               PropertyName
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               The name of the property
*           </td>
*           <td>
*               Yes (array)
*           </td>
*           <td>
*               No
*           </td>
*       </tr>
*       <tr>
*           <td>
*               PropertyDescription
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               Human readable description of the property
*           </td>
*           <td>
*               No
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*       <tr>
*           <td>
*               PropertyType
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               The property's datatype (as an XML Schema data type)
*           </td>
*           <td>
*               No
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*       <tr>
*           <td>
*               PropertyAccessType
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               How the property may be accessed. Values defined by the XML/A spec are:
*               <ul>
*                   <li>Read</li>
*                   <li>Write</li>
*                   <li>ReadWrite</li>
*               </ul>
*           </td>
*           <td>
*               No
*           </td>
*           <td>
*               No
*           </td>
*       </tr>
*       <tr>
*           <td>
*               IsRequired
*           </td>
*           <td>
*               boolean
*           </td>
*           <td>
*               <code>true</code> if the property is required, <code>false</code> if not.
*           </td>
*           <td>
*               No
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*       <tr>
*           <td>
*               Value
*           </td>
*           <td>
*               string
*           </td>
*           <td>
*               The property's current value.
*           </td>
*           <td>
*               No
*           </td>
*           <td>
*               Yes
*           </td>
*       </tr>
*   </table>
*
*   @method discoverProperties
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DISCOVER_DATASOURCES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DISCOVER_DATASOURCES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverProperties: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DISCOVER_PROPERTIES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using <code><a href="#property_DISCOVER_SCHEMA_ROWSETS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DISCOVER_SCHEMA_ROWSETS</code> schema rowset.
*   This rowset lists all possible request types supported by this provider.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>SchemaName</td>
*           <td>string</td>
*           <td>The requestType. </td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>Restrictions</td>
*           <td>array</td>
*           <td>A list of columns that may be used to filter the schema rowset.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>Description</td>
*           <td>string</td>
*           <td>A human readable description of the schema rowset that is returned when using this requestType</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*   </table>
*
*   @method discoverSchemaRowsets
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DISCOVER_SCHEMA_ROWSETS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DISCOVER_DATASOURCES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverSchemaRowsets: function(options){
        var request = _applyProps(
           options,
            {
                requestType: Xmla.DISCOVER_SCHEMA_ROWSETS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using <code><a href="#property_DISCOVER_ENUMERATORS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DISCOVER_ENUMERATORS</code> schema rowset.
*   This rowset lists the names, data types, and enumeration values of enumerators supported by the XMLA Provider for a specific data source.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>EnumName</td>
*           <td>string</td>
*           <td>Name of the enumerator. </td>
*           <td>Yes (array)</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>EnumDescription</td>
*           <td>string</td>
*           <td>A human readable description of the enumerator</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>EnumType</td>
*           <td>string</td>
*           <td>The XML Schema data type of this enumerator</td>
*           <td>No</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>ElementName</td>
*           <td>string</td>
*           <td>The name of the enumerator entry</td>
*           <td>No</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>ElementDescription</td>
*           <td>string</td>
*           <td>A human readable description of this enumerator entry</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>ElementValue</td>
*           <td>string</td>
*           <td>The value of this enumerator entry</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*   </table>
*
*   @method discoverEnumerators
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DISCOVER_ENUMERATORS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DISCOVER_ENUMERATORS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverEnumerators: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DISCOVER_ENUMERATORS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using <code><a href="#property_DISCOVER_KEYWORDS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DISCOVER_KEYWORDS</code> schema rowset.
*   This rowset is a list of reserved words for this XML/A provider.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>Keyword</td>
*           <td>string</td>
*           <td>Name of the enumerator. </td>
*           <td>Yes (array)</td>
*           <td>No</td>
*       </tr>
*   </table>
*
*   @method discoverKeywords
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DISCOVER_KEYWORDS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DISCOVER_ENUMERATORS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverKeywords: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DISCOVER_KEYWORDS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using <code><a href="#property_DISCOVER_LITERALS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DISCOVER_LITERALS</code> schema rowset.
*   This rowset is a list of reserved words for this XML/A provider.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>LiteralName</td>
*           <td>string</td>
*           <td>Name of the literal. </td>
*           <td>Yes (array)</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>LiteralValue</td>
*           <td>string</td>
*           <td>The actual literal value. </td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LiteralInvalidChars</td>
*           <td>string</td>
*           <td>Characters that may not appear in the literal </td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LiteralInvalidStartingChars</td>
*           <td>string</td>
*           <td>Characters that may not appear as first character in the literal </td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LiteralMaxLength</td>
*           <td>int</td>
*           <td>maximum number of characters for this literal, or -1 in case there is no maximum, or the maximum is unknown</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*   </table>
*
*   @method discoverLiterals
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DISCOVER_LITERALS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DISCOVER_LITERALS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverLiterals: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DISCOVER_LITERALS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_DBSCHEMA_CATALOGS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DBSCHEMA_CATALOGS</code> schema rowset.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>CATALOG_NAME</td>
*           <td>string</td>
*           <td>Name of the catalog</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DESCRIPTION</td>
*           <td>string</td>
*           <td>Human readable description</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>ROLES</td>
*           <td>string</td>
*           <td>A comma-separatd list of roles available to the current user.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DATE_MODIFIED</td>
*           <td>Date</td>
*           <td>The date this catalog was modified</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*   </table>
*   @method discoverDBCatalogs
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DBSCHEMA_CATALOGS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DBSCHEMA_CATALOGS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverDBCatalogs: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DBSCHEMA_CATALOGS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_DBSCHEMA_COLUMNS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DBSCHEMA_COLUMNS</code> schema rowset.
*   Provides column information for all columns meeting the provided restriction criteria.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*        <tr>
*            <td>TABLE_CATALOG</td>
*            <td>string</td>
*            <td>The name of the Database.</td>
*            <td>Yes</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>TABLE_SCHEMA</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>Yes</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>TABLE_NAME</td>
*            <td>string</td>
*            <td>The name of the cube.</td>
*            <td>Yes</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLUMN_NAME</td>
*            <td>string</td>
*            <td>The name of the attribute hierarchy or measure.</td>
*            <td>Yes</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLUMN_GUID</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLUMN_PROPID</td>
*            <td>int</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>ORDINAL_POSITION</td>
*            <td>int</td>
*            <td>The position of the column, beginning with 1.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLUMN_HAS_DEFAULT</td>
*            <td>boolean</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLUMN_DEFAULT</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLUMN_FLAGS</td>
*            <td>int</td>
*            <td>A DBCOLUMNFLAGS bitmask indicating column properties. See 'DBCOLUMNFLAGS Enumerated Type' in IColumnsInfo::GetColumnInfo</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>IS_NULLABLE</td>
*            <td>boolean</td>
*            <td>Always returns false.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>DATA_TYPE</td>
*            <td>string</td>
*            <td>The data type of the column. Returns a string for dimension columns and a variant for measures.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>TYPE_GUID
*            <td>srring</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>CHARACTER_MAXIMUM_LENGTH</td>
*            <td>int</td>
*            <td>The maximum possible length of a value within the column. This is retrieved from the DataSize property in the DataItem.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>CHARACTER_OCTET_LENGTH</td>
*            <td>int</td>
*            <td>The maximum possible length of a value within the column, in bytes, for character or binary columns. A value of zero (0) indicates the column has no maximum length. NULL will be returned for columns that do not return binary or character data types.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>NUMERIC_PRECISION</td>
*            <td>int</td>
*            <td>The maximum precision of the column for numeric data types other than DBTYPE_VARNUMERIC.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>NUMERIC_SCALE</td>
*            <td>int</td>
*            <td>The number of digits to the right of the decimal point for DBTYPE_DECIMAL, DBTYPE_NUMERIC, DBTYPE_VARNUMERIC. Otherwise, this is NULL.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>DATETIME_PRECISION</td>
*            <td>int</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>CHARACTER_SET_CATALOG</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>CHARACTER_SET_SCHEMA</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>CHARACTER_SET_NAME</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLLATION_CATALOG</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLLATION_SCHEMA</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLLATION_NAME</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>DOMAIN_CATALOG</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>DOMAIN_SCHEMA</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>DOMAIN_NAME</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>DESCRIPTION</td>
*            <td>string</td>
*            <td>Not supported.</td>
*            <td>No</td>
*            <td>No</td>
*        </tr>
*        <tr>
*            <td>COLUMN_OLAP_TYPE</td>
*            <td>string</td>
*            <td>The OLAP type of the object. MEASURE indicates the object is a measure. ATTRIBUTE indicates the object is a dimension attribute.</td>
*            <td>Yes</td>
*            <td>No</td>
*        </tr>
*   </table>
*    The rowset is sorted on TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME.
*   @method discoverDBColumns
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DBSCHEMA_COLUMNS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DBSCHEMA_COLUMNS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverDBColumns: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DBSCHEMA_COLUMNS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_DBSCHEMA_PROVIDER_TYPES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DBSCHEMA_PROVIDER_TYPES</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*        <tr>
*            <td>TYPE_NAME</td>
*            <td>string</td>
*            <td>The provider-specific data type name.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>DATA_TYPE</td>
*            <td>int</td>
*            <td>The indicator of the data type.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>COLUMN_SIZE</td>
*            <td>int</td>
*            <td> The length of a non-numeric column or parameter that refers to either the maximum or the length defined for this type by the provider. For character data, this is the maximum or defined length in characters. For DateTime data types, this is the length of the string representation (assuming the maximum allowed precision of the fractional seconds component). If the data type is numeric, this is the upper bound on the maximum precision of the data type. </td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>LITERAL_PREFIX</td>
*            <td>string</td>
*            <td>The character or characters used to prefix a literal of this type in a text command.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>LITERAL_SUFFIX</td>
*            <td>string</td>
*            <td>The character or characters used to suffix a literal of this type in a text command.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>CREATE_PARAMS
*            <td>string</td>
*            <td>The creation parameters specified by the consumer when creating a column of this data type. For example, the SQL data type, DECIMAL, needs a precision and a scale. In this case, the creation parameters might be the string "precision,scale". In a text command to create a DECIMAL column with a precision of 10 and a scale of 2, the value of the TYPE_NAME column might be DECIMAL() and the complete type specification would be DECIMAL(10,2). The creation parameters appear as a comma-separated list of values, in the order they are to be supplied and with no surrounding parentheses. If a creation parameter is length, maximum length, precision, scale, seed, or increment, use "length", "max length", "precision", "scale", "seed", and "increment", respectively. If the creation parameter is some other value, the provider determines what text is to be used to describe the creation parameter. If the data type requires creation parameters, "()" usually appears in the type name. This indicates the position at which to insert the creation parameters. If the type name does not include "()", the creation parameters are enclosed in parentheses and appended to the data type name. </td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>IS_NULLABLE</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the data type is nullable. VARIANT_TRUE indicates that the data type is nullable. VARIANT_FALSE indicates that the data type is not nullable. NULL indicates that it is not known whether the data type is nullable.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>CASE_SENSITIVE</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the data type is a characters type and case-sensitive. VARIANT_TRUE indicates that the data type is a character type and is case-sensitive. VARIANT_FALSE indicates that the data type is not a character type or is not case-sensitive.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>SEARCHABLE</td>
*            <td>int</td>
*            <td>An integer indicating how the data type can be used in searches if the provider supports ICommandText; otherwise, NULL. This column can have the following values: DB_UNSEARCHABLE indicates that the data type cannot be used in a WHERE clause. DB_LIKE_ONLY indicates that the data type can be used in a WHERE clause only with the LIKE predicate.DB_ALL_EXCEPT_LIKE indicates that the data type can be used in a WHERE clause with all comparison operators except LIKE. DB_SEARCHABLE indicates that the data type can be used in a WHERE clause with any comparison operator.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>UNSIGNED_ATTRIBUTE</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the data type is unsigned.   VARIANT_TRUE indicates that the data type is unsigned. VARIANT_FALSE indicates that the data type is signed.NULL indicates that this is not applicable to the data type.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>FIXED_PREC_SCALE</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the data type has a fixed precision and scale.  VARIANT_TRUE indicates that the data type has a fixed precision and scale. VARIANT_FALSE indicates that the data type does not have a fixed precision and scale.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>AUTO_UNIQUE_VALUE</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the data type is autoincrementing. VARIANT_TRUE indicates that values of this type can be autoincrementing. VARIANT_FALSE indicates that values of this type cannot be autoincrementing. If this value is VARIANT_TRUE, whether or not a column of this type is always autoincrementing depends on the provider's DBPROP_COL_AUTOINCREMENT column property. If the DBPROP_COL_AUTOINCREMENT property is read/write, whether or not a column of this type is autoincrementing depends on the setting of the DBPROP_COL_AUTOINCREMENT property. If DBPROP_COL_AUTOINCREMENT is a read-only property, either all or none of the columns of this type are autoincrementing. </td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>LOCAL_TYPE_NAME</td>
*            <td>string</td>
*            <td>The localized version of TYPE_NAME. NULL is returned if a localized name is not supported by the data provider.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>MINIMUM_SCALE</td>
*            <td>int</td>
*            <td>If the type indicator is DBTYPE_VARNUMERIC, DBTYPE_DECIMAL, or DBTYPE_NUMERIC, the minimum number of digits allowed to the right of the decimal point. Otherwise, NULL.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>MAXIMUM_SCALE</td>
*            <td>int</td>
*            <td>The maximum number of digits allowed to the right of the decimal point if the type indicator is DBTYPE_VARNUMERIC, DBTYPE_DECIMAL, or DBTYPE_NUMERIC; otherwise, NULL.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>GUID</td>
*            <td>string</td>
*            <td>(Intended for future use) The GUID of the type, if the type is described in a type library. Otherwise, NULL.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>TYPELIB
*            <td>string</td>
*            <td>(Intended for future use) The type library containing the description of the type, if the type is described in a type library. Otherwise, NULL.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>VERSION</td>
*            <td>string</td>
*            <td>(Intended for future use) The version of the type definition. Providers might want to version type definitions. Different providers might use different versioning schemes, such as a timestamp or number (integer or float). NULL if not supported.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>IS_LONG</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the data type is a binary large object (BLOB) and has very long data. VARIANT_TRUE indicates that the data type is a BLOB that contains very long data; the definition of very long data is provider-specific. VARIANT_FALSE indicates that the data type is a BLOB that does not contain very long data or is not a BLOB. This value determines the setting of the DBCOLUMNFLAGS_ISLONG flag returned by GetColumnInfo in IColumnsInfo and GetParameterInfo in ICommandWithParameters.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>BEST_MATCH</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the data type is a best match. VARIANT_TRUE indicates that the data type is the best match between all data types in the data store and the OLE DB data type indicated by the value in the DATA_TYPE column. VARIANT_FALSE indicates that the data type is not the best match. For each set of rows in which the value of the DATA_TYPE column is the same, the BEST_MATCH column is set to VARIANT_TRUE in only one row.</td>
*            <td>false</td>
*            <td>true</td>
*        </tr>
*        <tr>
*            <td>IS_FIXEDLENGTH</td>
*            <td>boolean</td>
*            <td>A Boolean that indicates whether the column is fixed in length. VARIANT_TRUE indicates that columns of this type created by the data definition language (DDL) will be of fixed length. VARIANT_FALSE indicates that columns of this type created by the DDL will be of variable length. If the field is NULL, it is not known whether the provider will map this field with a fixed-length or variable-length column.
*            <td>false</td>
*            <td>true</td>
*        </tr>
*    </table>
*   @method discoverDBProviderTypes
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DBSCHEMA_PROVIDER_TYPES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DBSCHEMA_PROVIDER_TYPES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverDBProviderTypes: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DBSCHEMA_PROVIDER_TYPES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_DBSCHEMA_SCHEMATA"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DBSCHEMA_SCHEMATA</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*   </table>
*   @method discoverDBSchemata
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DBSCHEMA_SCHEMATA</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DBSCHEMA_SCHEMATA</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverDBSchemata: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DBSCHEMA_SCHEMATA
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_DBSCHEMA_TABLES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DBSCHEMA_TABLES</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*   </table>
*   @method discoverDBTables
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DBSCHEMA_TABLES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DBSCHEMA_TABLES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverDBTables: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DBSCHEMA_TABLES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_DBSCHEMA_TABLES_INFO"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>DBSCHEMA_TABLES_INFO</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*   </table>
*   @method discoverDBTablesInfo
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>DBSCHEMA_TABLES_INFO</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>DBSCHEMA_TABLES_INFO</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverDBTablesInfo: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.DBSCHEMA_TABLES_INFO
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_ACTIONS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_ACTIONS</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*   </table>
*   @method discoverMDActions
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_ACTIONS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_ACTIONS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDActions: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_ACTIONS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_CUBES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_CUBES</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>CATALOG_NAME</td>
*           <td>string</td>
*           <td>Name of the catalog</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>SCHEMA_NAME</td>
*           <td>string</td>
*           <td>Not supported</td>
*           <td>Yes</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>CUBE_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>CUBE_TYPE</td>
*           <td>string</td>
*           <td>Type of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>CUBE_GUID</td>
*           <td>string</td>
*           <td>Not supported</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>CREATED_ON</td>
*           <td>Date</td>
*           <td>Not supported</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>LAST_SCHEMA_UPDATE</td>
*           <td>Date</td>
*           <td>The time that the cube was last processed.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>SCHEMA_UPDATED_BY</td>
*           <td>string</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>LAST_DATA_UPDATE</td>
*           <td>Date</td>
*           <td>The time that the cube was last processed.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DATA_UPDATED_BY</td>
*           <td>string</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DESCRIPTION</td>
*           <td>string</td>
*           <td>A Human-readable description of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>IS_DRILLTHROUGH_ENABLED</td>
*           <td>boolean</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>IS_LINKABLE</td>
*           <td>boolean</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>IS_WRITE_ENABLED</td>
*           <td>boolean</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>IS_SQL_ENABLED</td>
*           <td>boolean</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>CUBE_CAPTION</td>
*           <td>string</td>
*           <td>Caption for this cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>BASE_CUBE_NAME</td>
*           <td>string</td>
*           <td>Name of the source cube (if this cube is a perspective cube).</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>ANNOTATIONS</td>
*           <td>string</td>
*           <td>Notes in xml format</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*   </table>
*   @method discoverMDCubes
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_CUBES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_CUBES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDCubes: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_CUBES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_DIMENSIONS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_DIMENSIONS</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>CATALOG_NAME</td>
*           <td>string</td>
*           <td>Name of the catalog</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>SCHEMA_NAME</td>
*           <td>string</td>
*           <td>Not supported</td>
*           <td>Yes</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>CUBE_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_NAME</td>
*           <td>string</td>
*           <td>Name of the dimension.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_UNIQE_NAME</td>
*           <td>string</td>
*           <td>Unique name for this dimension.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_GUID</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_CAPTION</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_ORDINAL</td>
*           <td>int</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_TYPE</td>
*           <td>string</td>
*           <td>
*                <ul>
*                    <li>MD_DIMTYPE_UNKNOWN (0)</li>
*                    <li>MD_DIMTYPE_TIME (1)</li>
*                    <li>MD_DIMTYPE_MEASURE (2)</li>
*                    <li>MD_DIMTYPE_OTHER (3)</li>
*                    <li>MD_DIMTYPE_QUANTITATIVE (5)</li>
*                    <li>MD_DIMTYPE_ACCOUNTS (6)</li>
*                    <li>MD_DIMTYPE_CUSTOMERS (7)</li>
*                    <li>MD_DIMTYPE_PRODUCTS (8)</li>
*                    <li>MD_DIMTYPE_SCENARIO (9)</li>
*                    <li>MD_DIMTYPE_UTILIY (10)</li>
*                    <li>MD_DIMTYPE_CURRENCY (11)</li>
*                    <li>MD_DIMTYPE_RATES (12)</li>
*                    <li>MD_DIMTYPE_CHANNEL (13)</li>
*                    <li>MD_DIMTYPE_PROMOTION (14)</li>
*                    <li>MD_DIMTYPE_ORGANIZATION (15)</li>
*                    <li>MD_DIMTYPE_BILL_OF_MATERIALS (16)</li>
*                    <li>MD_DIMTYPE_GEOGRAPHY (17)</li>
*                </ul>
*            </td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_CARDINALITY</td>
*           <td>int</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DEFAULT_HIERARCHY</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DESCRIPTION</td>
*           <td>string</td>
*           <td>A Human-readable description of the dimension.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>IS_VIRTUAL</td>
*           <td>boolean</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>IS_READWRITE</td>
*           <td>boolean</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_UNIQUE_SETTINGS</td>
*           <td></td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_MASTER_UNIQUE_NAME</td>
*           <td></td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>IS_VISIBLE</td>
*           <td>boolean</td>
*           <td></td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*   </table>
*   @method discoverMDDimensions
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_DIMENSIONS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_DIMENSIONS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDDimensions: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_DIMENSIONS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_FUNCTIONS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_FUNCTIONS</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*   </table>
*   @method discoverMDFunctions
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_FUNCTIONS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_FUNCTIONS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDFunctions: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_FUNCTIONS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_HIERARCHIES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_HIERARCHIES</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>CATALOG_NAME</td>
*           <td>string</td>
*           <td>Name of the catalog</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>SCHEMA_NAME</td>
*           <td>string</td>
*           <td>Not supported</td>
*           <td>Yes</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>CUBE_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_UNIQE_NAME</td>
*           <td>string</td>
*           <td>Unique name for this dimension.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_NAME</td>
*           <td>string</td>
*           <td>Name of the hierarchy.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_UNIQE_NAME</td>
*           <td>string</td>
*           <td>Unique name for this hierarchy.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_GUID</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_CAPTION</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_TYPE</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_CARDINALITY</td>
*           <td>int</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DEFAULT_MEMBER</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>ALL_MEMBER</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DESCRIPTION</td>
*           <td>string</td>
*           <td>A Human-readable description of the dimension.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>STRUCTURE</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>IS_VIRTUAL</td>
*           <td>boolean</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>IS_READWRITE</td>
*           <td>boolean</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_UNIQUE_SETTINGS</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_MASTER_UNIQUE_NAME</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_IS_VISIBLE</td>
*           <td>boolean</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_ORDINAL</td>
*           <td>int</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_IS_SHARED</td>
*           <td>boolean</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_IS_VISIBLE</td>
*           <td>boolean</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_ORIGIN</td>
*           <td></td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_DISPLAY_FOLDER</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>INSTANCE_SELECTION</td>
*           <td>string</td>
*           <td></td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*   </table>
*   @method discoverMDHierarchies
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_HIERARCHIES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_HIERARCHIES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDHierarchies: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_HIERARCHIES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_LEVELS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_LEVELS</code> schema rowset.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>CATALOG_NAME</td>
*           <td>string</td>
*           <td>The name of the catalog to which this level belongs. NULL if the provider does not support catalogs.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>SCHEMA_NAME</td>
*           <td>string</td>
*           <td>The name of the schema to which this level belongs. NULL if the provider does not support schemas.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>CUBE_NAME</td>
*           <td>string</td>
*           <td>The name of the cube to which this level belongs.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>The unique name of the dimension to which this level belongs. For providers that generate unique names by qualification, each component of this name is delimited.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>The unique name of the hierarchy. If the level belongs to more than one hierarchy, there is one row for each hierarchy to which it belongs. For providers that generate unique names by qualification, each component of this name is delimited.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_NAME</td>
*           <td>string</td>
*           <td>The name of the level.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>The properly escaped unique name of the level.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_GUID</td>
*           <td>string</td>
*           <td>Not supported.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_CAPTION</td>
*           <td>string</td>
*           <td>A label or caption associated with the hierarchy. Used primarily for display purposes. If a caption does not exist, LEVEL_NAME is returned.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_NUMBER</td>
*           <td>int</td>
*           <td>The distance of the level from the root of the hierarchy. Root level is zero (0).</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_CARDINALITY</td>
*           <td>int</td>
*           <td>The number of members in the level.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_TYPE</td>
*           <td>int</td>
*           <td>Type of the level:
*                <ul>
*                   <li>MDLEVEL_TYPE_GEO_CONTINENT (0x2001)</li>
*                   <li>MDLEVEL_TYPE_GEO_REGION (0x2002)</li>
*                   <li>MDLEVEL_TYPE_GEO_COUNTRY (0x2003)</li>
*                   <li>MDLEVEL_TYPE_GEO_STATE_OR_PROVINCE (0x2004)</li>
*                   <li>MDLEVEL_TYPE_GEO_COUNTY (0x2005)</li>
*                   <li>MDLEVEL_TYPE_GEO_CITY (0x2006)</li>
*                   <li>MDLEVEL_TYPE_GEO_POSTALCODE (0x2007)</li>
*                   <li>MDLEVEL_TYPE_GEO_POINT (0x2008)</li>
*                   <li>MDLEVEL_TYPE_ORG_UNIT (0x1011)</li>
*                   <li>MDLEVEL_TYPE_BOM_RESOURCE (0x1012)</li>
*                   <li>MDLEVEL_TYPE_QUANTITATIVE (0x1013)</li>
*                   <li>MDLEVEL_TYPE_ACCOUNT (0x1014)</li>
*                   <li>MDLEVEL_TYPE_CUSTOMER (0x1021)</li>
*                   <li>MDLEVEL_TYPE_CUSTOMER_GROUP (0x1022)</li>
*                   <li>MDLEVEL_TYPE_CUSTOMER_HOUSEHOLD (0x1023)</li>
*                   <li>MDLEVEL_TYPE_PRODUCT (0x1031)</li>
*                   <li>MDLEVEL_TYPE_PRODUCT_GROUP (0x1032)</li>
*                   <li>MDLEVEL_TYPE_SCENARIO (0x1015)</li>
*                   <li>MDLEVEL_TYPE_UTILITY (0x1016)</li>
*                   <li>MDLEVEL_TYPE_PERSON (0x1041)</li>
*                   <li>MDLEVEL_TYPE_COMPANY (0x1042)</li>
*                   <li>MDLEVEL_TYPE_CURRENCY_SOURCE (0x1051)</li>
*                   <li>MDLEVEL_TYPE_CURRENCY_DESTINATION (0x1052)</li>
*                   <li>MDLEVEL_TYPE_CHANNEL (0x1061)</li>
*                   <li>MDLEVEL_TYPE_REPRESENTATIVE (0x1062)</li>
*                   <li>MDLEVEL_TYPE_PROMOTION (0x1071)</li>
*                </ul>
*           <td>No</td>
*           <td>Yes</td>
*       <tr>
*           <td>DESCRIPTION</td>
*           <td>string</td>
*           <td>A human-readable description of the level. NULL if no description exists.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>CUSTOM_ROLLUP_SETTINGS</td>
*           <td>int</td>
*           <td>A bitmap that specifies the custom rollup options: MDLEVELS_CUSTOM_ROLLUP_EXPRESSION (0x01) indicates an expression exists for this level. (Deprecated) MDLEVELS_CUSTOM_ROLLUP_COLUMN (0x02) indicates that there is a custom rollup column for this level. MDLEVELS_SKIPPED_LEVELS (0x04) indicates that there is a skipped level associated with members of this level.MDLEVELS_CUSTOM_MEMBER_PROPERTIES (0x08) indicates that members of the level have custom member properties. MDLEVELS_UNARY_OPERATOR (0x10) indicates that members on the level have unary operators.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_UNIQUE_SETTINGS</td>
*           <td>int</td>
*           <td>A bitmap that specifies which columns contain unique values, if the level only has members with unique names or keys. The Msmd.h file defines the following bit value constants for this bitmap: MDDIMENSIONS_MEMBER_KEY_UNIQUE (1) MDDIMENSIONS_MEMBER_NAME_UNIQUE (2)The key is always unique in Microsoft SQL Server 2005 Analysis Services (SSAS). The name will be unique if the setting on the attribute is UniqueInDimension or UniqueInAttribute</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_IS_VISIBLE</td>
*           <td>bool</td>
*           <td>A Boolean that indicates whether the level is visible. Always returns True. If the level is not visible, it will not be included in the schema rowset.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_ORDERING_PROPERTY</td>
*           <td>string</td>
*           <td>The ID of the attribute that the level is sorted on.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_DBTYPE</td>
*           <td>int</td>
*           <td>The DBTYPE enumeration of the member key column that is used for the level attribute. Null if concatenated keys are used as the member key column.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_MASTER_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>Always returns NULL.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_NAME_SQL_COLUMN_NAME</td>
*           <td>string</td>
*           <td>The SQL representation of the level member names.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_KEY_SQL_COLUMN_NAME</td>
*           <td>string</td>
*           <td>The SQL representation of the level member key values.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_UNIQUE_NAME_SQL_COLUMN_NAME</td>
*           <td>string</td>
*           <td>The SQL representation of the member unique names.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_ATTRIBUTE_HIERARCHY_NAME</td>
*           <td>string</td>
*            <td>The name of the attribute hierarchy providing the source of the level.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_KEY_CARDINALITY</td>
*           <td>int</td>
*            <td>The number of columns in the level key.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>LEVEL_ORIGIN</td>
*           <td>int</td>
*            <td>A bit map that defines how the level was sourced:MD_ORIGIN_USER_DEFINED identifies levels in a user defined hierarchy.MD_ORIGIN_ATTRIBUTE identifies levels in an attribute hierarchy.MD_ORIGIN_KEY_ATTRIBUTE identifies levels in a key attribute hierarchy.MD_ORIGIN_INTERNAL identifies levels in attribute hierarchies that are not enabled.</td>
*           <td>No</td>
*           <td>Yes</td>
*       </tr>
*   </table>
*   @method discoverMDLevels
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_LEVELS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_LEVELS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDLevels: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_LEVELS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_MEASURES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_MEASURES</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>CATALOG_NAME</td>
*           <td>string</td>
*           <td>Name of the catalog</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>SCHEMA_NAME</td>
*           <td>string</td>
*           <td>Not supported</td>
*           <td>Yes</td>
*           <td>Yes</td>
*       </tr>
*       <tr>
*           <td>CUBE_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_CAPTION</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_GUID</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_AGGREGATOR</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DATA_TYPE</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>NUMERIC_PRECISION</td>
*           <td>int</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>NUMERIC_SCALE</td>
*           <td>int</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DESCRIPTION</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>EXPRESSION</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_IS_VISIBLE</td>
*           <td>boolean</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>LEVELS_LIST</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_NAME_SQL_COLUMN_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_UNQUALIFIED_CAPTION</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASUREGROUP_NAME</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEASURE_DISPLAY_FOLDER</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DEFAULT_FORMAT_STRING</td>
*           <td>string</td>
*           <td>Name of the cube.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*   </table>
*   @method discoverMDMeasures
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_MEASURES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_MEASURES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDMeasures: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_MEASURES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_MEMBERS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_MEMBERS</code> schema rowset.
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*       <tr>
*           <td>CATALOG_NAME</td>
*           <td>string</td>
*           <td>The name of the catalog</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>SCHEMA_NAME</td>
*           <td>string</td>
*           <td>The name of the schema</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>CUBE_NAME</td>
*           <td>string</td>
*           <td>The name of the cube</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DIMENSION_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>The unique name of the dimension</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>HIERARCHY_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>The unique name of the hierarchy</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>LEVEL_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>The unique name of the level</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>LEVEL_NUMBERr</td>
*           <td>int</td>
*           <td>Distance of this level to the root</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEMBER_ORDINAL</td>
*           <td>int</td>
*           <td>Deprecated: always 0</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEMBER_NAME</td>
*           <td>string</td>
*           <td>The name of this member</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEMBER_UNIQUE_NAME</td>
*           <td>string</td>
*           <td>The unique name of this member</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEMBER_TYPE</td>
*           <td>int</td>
*           <td>An integer constant indicating the type of this member. Can take on one of the following values:
*               <ul>
*                   <li><a href="Xmla.Rowset.html#property_MDMEMBER_TYPE_REGULAR">MDMEMBER_TYPE_REGULAR</a></li>
*                   <li><a href="Xmla.Rowset.html#property_MDMEMBER_TYPE_ALL">MDMEMBER_TYPE_ALL</a></li>
*                   <li><a href="Xmla.Rowset.html#property_MDMEMBER_TYPE_MEASURE">MDMEMBER_TYPE_MEASURE</a></li>
*                   <li><a href="Xmla.Rowset.html#property_MDMEMBER_TYPE_FORMULA">MDMEMBER_TYPE_FORMULA</a></li>
*                   <li><a href="Xmla.Rowset.html#property_MDMEMBER_TYPE_UNKNOWN">MDMEMBER_TYPE_UNKNOWN</a></li>
*                   <li><a href="Xmla.Rowset.html#property_MDMEMBER_TYPE_FORMULA">MDMEMBER_TYPE_FORMULA</a></li>
*               </ul>
*           </td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEMBER_GUID</td>
*           <td>string</td>
*           <td>The guid of this member</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEMBER_CAPTION</td>
*           <td>string</td>
*           <td>A label or caption associated with the member. Used primarily for display purposes. If a caption does not exist, MEMBER_NAME is returned.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>CHILDREN_CARDINALITY</td>
*           <td>int</td>
*           <td>The number of childrend for this member</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>PARENT_LEVEL</td>
*           <td>int</td>
*           <td>The distance of the member's parent from the root level of the hierarchy. The root level is zero (0).</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>DESCRIPTION</td>
*           <td>string</td>
*           <td>This column always returns a NULL value. This column exists for backwards compatibility</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>EXPRESSION</td>
*           <td>string</td>
*           <td>The expression for calculations, if the member is of type MDMEMBER_TYPE_FORMULA.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*       <tr>
*           <td>MEMBER_KEY</td>
*           <td>string</td>
*           <td>The value of the member's key column. Returns NULL if the member has a composite key.</td>
*           <td>Yes</td>
*           <td>No</td>
*       </tr>
*   </table>
*   @method discoverMDMembers
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_MEMBERS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_MEMBERS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDMembers: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_MEMBERS
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_PROPERTIES"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_PROPERTIES</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*   </table>
*   @method discoverMDProperties
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_PROPERTIES</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_PROPERTIES</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDProperties: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_PROPERTIES
            },
            true
        );
        return this.discover(request);
    },
/**
*   Invokes the <code><a href="#method_discover">discover()</a></code> method using
*   <code><a href="#property_MDSCHEMA_SETS"></a></code> as value for the <code>requestType</code>,
*   and retrieves the <code>MDSCHEMA_SETS</code> schema rowset.
*   ...todo...
*   The rowset has the following columns:
*   <table border="1" class="schema-rowset">
*       <tr>
*           <th>Column Name</th>
*           <th>Type</th>
*           <th>Description</th>
*           <th>Restriction</th>
*           <th>Nullable</th>
*       </tr>
*   </table>
*   @method discoverMDSets
*   @param {Object} options An object whose properties convey the options for the XML/A a <code>MDSCHEMA_SETS</code> request.
*   @return {Xmla.Rowset} The result of the invoking the XML/A <code>Discover</code> method. For synchronous requests, an instance of a <code><a href="Xmla.Rowset.html#Xmla.Rowset">Xmla.Rowset</a></code> that represents the <code>MDSCHEMA_SETS</code> schema rowset. For an asynchronous request, the return value is not defined: you should add a listener (see: <code><a href="#method_addListener">addListener()</a></code>) and listen for the <code>success</code> (see: <code><a href="#property_EVENT_SUCCESS">EVENT_SUCCESS</a></code>) or <code>discoversuccess</code> (see: <code><a href="#property_EVENT_DISCOVER_SUCCESS">EVENT_DISCOVER_SUCCESS</a></code>) events.
*/
    discoverMDSets: function(options){
        var request = _applyProps(
            options,
            {
                requestType: Xmla.MDSCHEMA_SETS
            },
            true
        );
        return this.discover(request);
    }
};

function _getComplexType(node, name){
    var types = _getElementsByTagNameNS(
            node, _xmlnsSchema, _xmlnsSchemaPrefix, "complexType"
        ),
        numTypes = types.length,
        type, i
    ;
    for (i=0; i<numTypes; i ++){
        type = types.item(i);
        if (type.getAttribute("name")===name) return type;
    }
    return null;
}

/**
*   <p>
*   This class implements an XML/A Rowset object.
*   </p>
*   <p>
*   You do not need to instantiate objects of this class yourself.
*   Rather, the <code><a href="Xmla.html#class_Xmla">Xmla</a></code> class will instantiate this class to convey the result of any of the various <code>discoverXXX()</code> methods
*   (see <code><a href="Xmla.html#method_discover">discover()</a></code>).
*   In addition, this class is also used to instantiate a Resultset for the
*   <code><a name="Xmla.html#method_execute">execute()</code> method in case the
*   <code>Format</code> property is set to <code>Tabular</code>
*   (see <code><a name="Xmla.html#property_OPTION_FORMAT">OPTION_FORMAT</a></code> and <code><a name="Xmla.html#property_OPTION_FORMAT_TABULAR">OPTION_FORMAT_TABULAR</a></code>).
*   The <code><a href="Xmla.html#method_request">request()</a></code> method itself will also return an instance of this class in case the <code>method</code> is used to do a
*   <code>Discover</code> request, or in case it is used to do a <code>Execute</code> request and the <code>Format</code> property is set to <code>Tabular</code>.
*   </p>
*   <p>
*   An instance of the <code>Xmla.Rowset</code> class is returned immediately as return value from the <code>disoverXXX()</code> or <code>execute()</code> method when doing a synchronous request.
*   In addition, the rowset is available in the eventdata passed to any registered listeners
*   (see <code><a href="Xmla.html#method_addListener">addListener()</a></code>).
*   Note that for asynchronous requests, the only way to obtain the returned <code>Rowset</code> instance is through the listeners.
*   </p>
*
*   @class Xmla.Rowset
*   @constructor
*   @param {DOMDocument} node The responseXML result returned by server in response to a <code>Discover</code> request.
*   @param {string} requestTtype The requestType identifying the particular schema rowset to construct. This facilitates implementing field getters for a few complex types.
*   @param {Xmla} xmla The Xmla instance that created this Rowset. This is mainly used to allow the Rowset to access the options passed to the Xmla constructor.
*/
Xmla.Rowset = function (node, requestType, xmla){
    this._node = node;
    this._type = requestType;
    this._xmla = xmla;
    this._initData();
    return this;
};

/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_UNKNOWN
*   @static
*   @final
*   @type int
*   @default <code>0</code>
*/
Xmla.Rowset.MD_DIMTYPE_UNKNOWN = 0;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_TIME
*   @static
*   @final
*   @type int
*   @default <code>1</code>
*/
Xmla.Rowset.MD_DIMTYPE_TIME = 1;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_MEASURE
*   @static
*   @final
*   @type int
*   @default <code>2</code>
*/
Xmla.Rowset.MD_DIMTYPE_MEASURE = 2;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_OTHER
*   @static
*   @final
*   @type int
*   @default <code>3</code>
*/
Xmla.Rowset.MD_DIMTYPE_OTHER = 3;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_QUANTITATIVE
*   @static
*   @final
*   @type int
*   @default <code>5</code>
*/
Xmla.Rowset.MD_DIMTYPE_QUANTITATIVE = 5;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_ACCOUNTS
*   @static
*   @final
*   @type int
*   @default <code>6</code>
*/
Xmla.Rowset.MD_DIMTYPE_ACCOUNTS = 6;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_CUSTOMERS
*   @static
*   @final
*   @type int
*   @default <code>7</code>
*/
Xmla.Rowset.MD_DIMTYPE_CUSTOMERS = 7;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_PRODUCTS
*   @static
*   @final
*   @type int
*   @default <code>8</code>
*/
Xmla.Rowset.MD_DIMTYPE_PRODUCTS = 8;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_SCENARIO
*   @static
*   @final
*   @type int
*   @default <code>9</code>
*/
Xmla.Rowset.MD_DIMTYPE_SCENARIO = 9;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_UTILIY
*   @static
*   @final
*   @type int
*   @default <code>10</code>
*/
Xmla.Rowset.MD_DIMTYPE_UTILIY = 10;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_CURRENCY
*   @static
*   @final
*   @type int
*   @default <code>11</code>
*/
Xmla.Rowset.MD_DIMTYPE_CURRENCY = 11;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_RATES
*   @static
*   @final
*   @type int
*   @default <code>12</code>
*/
Xmla.Rowset.MD_DIMTYPE_RATES = 12;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_CHANNEL
*   @static
*   @final
*   @type int
*   @default <code>13</code>
*/
Xmla.Rowset.MD_DIMTYPE_CHANNEL = 13;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_PROMOTION
*   @static
*   @final
*   @type int
*   @default <code>14</code>
*/
Xmla.Rowset.MD_DIMTYPE_PROMOTION = 14;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_ORGANIZATION
*   @static
*   @final
*   @type int
*   @default <code>15</code>
*/
Xmla.Rowset.MD_DIMTYPE_ORGANIZATION = 15;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_BILL_OF_MATERIALS
*   @static
*   @final
*   @type int
*   @default <code>16</code>
*/
Xmla.Rowset.MD_DIMTYPE_BILL_OF_MATERIALS = 16;
/**
*   A possible value for the <code>DIMENSION_TYPE</code> column that appears in the
*   <code>MDSCHEMA_DIMENSIONS</code> (See: <code><a href="Xmla.html#method_discoverMDDimensions">discoverMDDimensions()</a></code>) and
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowsets.
*
*   @property MD_DIMTYPE_GEOGRAPHY
*   @static
*   @final
*   @type int
*   @default <code>17</code>
*/
Xmla.Rowset.MD_DIMTYPE_GEOGRAPHY = 17;

/**
*    A possible value for the <code>STRUCTURE</code> column of the
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowset.
*    @property MD_STRUCTURE_FULLYBALANCED
*   @static
*   @final
*   @type int
*   @default <code>0</code>
*/
Xmla.Rowset.MD_STRUCTURE_FULLYBALANCED = 0;
/**
*    A possible value for the <code>STRUCTURE</code> column of the
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowset.
*    @property MD_STRUCTURE_RAGGEDBALANCED
*   @static
*   @final
*   @type int
*   @default <code>1</code>
*/
Xmla.Rowset.MD_STRUCTURE_RAGGEDBALANCED = 1;
/**
*    A possible value for the <code>STRUCTURE</code> column of the
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowset.
*    @property MD_STRUCTURE_UNBALANCED
*   @static
*   @final
*   @type int
*   @default <code>2</code>
*/
Xmla.Rowset.MD_STRUCTURE_UNBALANCED = 2;
/**
*    A possible value for the <code>STRUCTURE</code> column of the
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowset.
*    @property MD_STRUCTURE_NETWORK
*   @static
*   @final
*   @type int
*   @default <code>3</code>
*/
Xmla.Rowset.MD_STRUCTURE_NETWORK = 3;

/**
*    A  bitmap value for the <code>HIERARCHY_ORIGIN</code> column of the
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowset.
*    Identifies user defined hierarchies.
*    @property MD_USER_DEFINED
*   @static
*   @final
*   @type int
*   @default <code>1</code>
*/
Xmla.Rowset.MD_USER_DEFINED = 1
/**
*    A  bitmap value for the <code>HIERARCHY_ORIGIN</code> column of the
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowset.
*    identifies attribute hierarchies.
*    @property MD_SYSTEM_ENABLED
*   @static
*   @final
*   @type int
*   @default <code>2</code>
*/
Xmla.Rowset.MD_SYSTEM_ENABLED = 2
/**
*    A  bitmap value for the <code>HIERARCHY_ORIGIN</code> column of the
*   <code>MDSCHEMA_HIERARCHIES</code> (See: <code><a href="Xmla.html#method_discoverMDHierarchies">discoverMDHierarchies()</a></code>)rowset.
*    identifies attributes with no attribute hierarchies.
*    @property MD_SYSTEM_INTERNAL
*   @static
*   @final
*   @type int
*   @default <code>4</code>
*/
Xmla.Rowset.MD_SYSTEM_INTERNAL = 4

/**
*   A possible value for the <code>MEMBER_TYPE</code> column of the
*   <code>MDSCHEMA_MEMBERS</code> rowset (see: <code><a href="Xmla.html#method_discoverMDMembers">discoverMDMembers()</a></code>),
*   indicating a regular member.
*    @property MDMEMBER_TYPE_REGULAR
*   @static
*   @final
*   @type int
*   @default <code>1</code>
*/
Xmla.Rowset.MDMEMBER_TYPE_REGULAR = 1;
/**
*   A possible value for the <code>MEMBER_TYPE</code> column of the
*   <code>MDSCHEMA_MEMBERS</code> rowset (see: <code><a href="Xmla.html#method_discoverMDMembers">discoverMDMembers()</a></code>),
*   indicating an all member.
*    @property MDMEMBER_TYPE_ALL
*   @static
*   @final
*   @type int
*   @default <code>2</code>
*/
Xmla.Rowset.MDMEMBER_TYPE_ALL = 2;
/**
*   A possible value for the <code>MEMBER_TYPE</code> column of the
*   <code>MDSCHEMA_MEMBERS</code> rowset (see: <code><a href="Xmla.html#method_discoverMDMembers">discoverMDMembers()</a></code>),
*   indicating a formula member.
*    @property MDMEMBER_TYPE_FORMULA
*   @static
*   @final
*   @type int
*   @default <code>3</code>
*/
Xmla.Rowset.MDMEMBER_TYPE_FORMULA = 3;
/**
*   A possible value for the <code>MEMBER_TYPE</code> column of the
*   <code>MDSCHEMA_MEMBERS</code> rowset (see: <code><a href="Xmla.html#method_discoverMDMembers">discoverMDMembers()</a></code>),
*   indicating a measure member.
*    @property MDMEMBER_TYPE_MEASURE
*   @static
*   @final
*   @type int
*   @default <code>4</code>
*/
Xmla.Rowset.MDMEMBER_TYPE_MEASURE = 4;
/**
*   A possible value for the <code>MEMBER_TYPE</code> column of the
*   <code>MDSCHEMA_MEMBERS</code> rowset (see: <code><a href="Xmla.html#method_discoverMDMembers">discoverMDMembers()</a></code>),
*   indicating a member of unknown type
*    @property MDMEMBER_TYPE_UNKNOWN
*   @static
*   @final
*   @type int
*   @default <code>0</code>
*/
Xmla.Rowset.MDMEMBER_TYPE_UNKNOWN = 0;

Xmla.Rowset.KEYS = {};
Xmla.Rowset.KEYS[Xmla.DBSCHEMA_CATALOGS] = ["CATALOG_NAME"];
Xmla.Rowset.KEYS[Xmla.DBSCHEMA_COLUMNS] = ["TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME", "COLUMN_NAME"];
Xmla.Rowset.KEYS[Xmla.DBSCHEMA_PROVIDER_TYPES] = ["TYPE_NAME"];
Xmla.Rowset.KEYS[Xmla.DBSCHEMA_SCHEMATA] = ["CATALOG_NAME", "SCHEMA_NAME"];
Xmla.Rowset.KEYS[Xmla.DBSCHEMA_TABLES] = ["TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"];
Xmla.Rowset.KEYS[Xmla.DBSCHEMA_TABLES_INFO] = ["TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"];
Xmla.Rowset.KEYS[Xmla.DISCOVER_DATASOURCES] = ["DataSourceName"];
Xmla.Rowset.KEYS[Xmla.DISCOVER_ENUMERATORS] = ["EnumName", "ElementName"];
Xmla.Rowset.KEYS[Xmla.DISCOVER_KEYWORDS] = ["Keyword"];
Xmla.Rowset.KEYS[Xmla.DISCOVER_LITERALS] = ["LiteralName"];
Xmla.Rowset.KEYS[Xmla.DISCOVER_PROPERTIES] = ["PropertyName"];
Xmla.Rowset.KEYS[Xmla.DISCOVER_SCHEMA_ROWSETS] = ["SchemaName"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_ACTIONS] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "ACTION_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_CUBES] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_DIMENSIONS] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "DIMENSION_UNIQUE_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_FUNCTIONS] = ["FUNCTION_NAME", "PARAMETER_LIST"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_HIERARCHIES] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "DIMENSION_UNIQUE_NAME", "HIERARCHY_UNIQUE_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_LEVELS] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "DIMENSION_UNIQUE_NAME", "HIERARCHY_UNIQUE_NAME", "LEVEL_UNIQUE_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_MEASURES] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "MEASURE_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_MEMBERS] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "DIMENSION_UNIQUE_NAME", "HIERARCHY_UNIQUE_NAME", "LEVEL_UNIQUE_NAME", "MEMBER_UNIQUE_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_PROPERTIES] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "DIMENSION_UNIQUE_NAME", "HIERARCHY_UNIQUE_NAME", "LEVEL_UNIQUE_NAME", "MEMBER_UNIQUE_NAME", "PROPERTY_NAME"];
Xmla.Rowset.KEYS[Xmla.MDSCHEMA_SETS] = ["CATALOG_NAME", "SCHEMA_NAME", "CUBE_NAME", "SET_NAME"];


function _boolConverter(val){
    return val==="true"?true:false;
}
_boolConverter.jsType = "boolean";

function _intConverter(val){
    return parseInt(val, 10);
}
_intConverter.jsType = "number";

function _floatConverter(val){
    return parseFloat(val, 10);
}
_floatConverter.jsType = "number";

function _textConverter (val){
    return val;
}
_textConverter.jsType = "string";

function _dateTimeConverter (val){
    return Date.parse(val);
}
_dateTimeConverter.jsType = "object";

function _restrictionsConverter(val){
    return val;
}
_restrictionsConverter.jsType = "object";

function _arrayConverter(nodes, valueConverter){
    var arr = [],
        n = nodes.length,
        i, node
    ;
    for (i = 0; i < n; i++){
        node = nodes.item(i);
        arr.push(valueConverter(_getElementText(node)));
    }
    return arr;
}
_arrayConverter.jsType = "object";

var _typeConverterMap = {
    "xsd:boolean": _boolConverter,
    "xsd:decimal": _floatConverter,
    "xsd:double": _floatConverter,
    "xsd:float": _floatConverter,
    "xsd:int": _intConverter,
    "xsd:integer": _intConverter,
    "xsd:nonPositiveInteger": _intConverter,
    "xsd:negativeInteger": _intConverter,
    "xsd:nonNegativeInteger": _intConverter,
    "xsd:positiveInteger": _intConverter,
    "xsd:short": _intConverter,
    "xsd:byte": _intConverter,
    "xsd:long": _intConverter,
    "xsd:unsignedLong": _intConverter,
    "xsd:unsignedInt": _intConverter,
    "xsd:unsignedShort": _intConverter,
    "xsd:unsignedByte": _intConverter,
    "xsd:string": _textConverter,
    "xsd:dateTime": _dateTimeConverter,
    "Restrictions": _restrictionsConverter
}

function _getValueConverter(type){
    var func = _typeConverterMap[type], valueConverter;
    if (!func) {
        func = _textConverter;
    }
    return func;
}

function _getElementValue(el) {
    var txt = _getElementText(el),
        type = _getAttributeNS(el, _xmlnsSchemaInstance, _xmlnsSchemaInstancePrefix, "type"),
        converter
        ;
    if (type){
        converter = _typeConverterMap[type];
        if (converter){
            return converter(txt);
        }
    }
    return txt;
}

function _getterNameForColumnName(columnName){
    //sample: _getterNameForColumnName("DBLITERAL_CATALOG_NAME") returns "getDbLiteralCatalogName"
    return "get" +
           (/^[A-Z]+[a-z]+[A-Za-z]*$/g.test(columnName) ? columnName :
                columnName.charAt(0).toUpperCase() +
                columnName.substr(1).toLowerCase().replace(
                    /_[a-z]/g,
                    function(a){
                        return a.charAt(1).toUpperCase();
                    }
                )
           );
}

Xmla.Rowset.prototype = {
    _node:  null,
    _type: null,
    _row: null,
    _rows: null,
    numRows: null,
    fieldOrder: null,
    fields: null,
    _fieldCount: null,
    _initData: function(){
        this._rows = _getElementsByTagNameNS(this._node, _xmlnsRowset, null, "row");
        this.numRows = this._rows? this._rows.length : 0;
        this.reset();
        this.fieldOrder = [];
        this.fields = {};
        this._fieldCount = 0;
        var rowSchema = _getComplexType(this._node, "row");
        if (rowSchema){
            var seq = _getElementsByTagNameNS(rowSchema, _xmlnsSchema, _xmlnsSchemaPrefix, "sequence").item(0),
                seqChildren = seq.childNodes, numChildren = seqChildren.length, seqChild,
                fieldLabel, fieldName, minOccurs, maxOccurs, type, valueConverter, getter,
                addFieldGetters = this._xmla.options.addFieldGetters, i, val;
            for (i = 0; i < numChildren; i++){
                seqChild = seqChildren.item(i);
                if (seqChild.nodeType !== 1) {  //element node
                    continue;
                }
                fieldLabel = _getAttributeNS(seqChild, _xmlnsSQL, _xmlnsSQLPrefix, "field");
                fieldName = seqChild.getAttribute("name");
                type = seqChild.getAttribute("type");   //get the type from the xsd
                if (type===null && this._row) {           //bummer, not defined there try to get it from xsi:type in the row
                    val = this._row.getElementsByTagName(fieldName);
                    if (val.length){
                        type = _getAttributeNS(
                            val.item(0),
                            _xmlnsSchemaInstance,
                            _xmlnsSchemaInstancePrefix,
                            "type"
                        );
                    }
                }
                if (!type &&
                    this._type==Xmla.DISCOVER_SCHEMA_ROWSETS &&
                    fieldName==="Restrictions"
                ) type = "Restrictions";
                minOccurs = seqChild.getAttribute("minOccurs");
                if (minOccurs) minOccurs = parseInt(minOccurs, 10);
                else minOccurs = 1;
                maxOccurs = seqChild.getAttribute("maxOccurs");
                if (maxOccurs) {
                    if (maxOccurs === "unbounded") maxOccurs = Infinity;
                    else minOccurs=parseInt(maxOccurs,10);
                }
                else maxOccurs = 1;
                valueConverter = _getValueConverter(type);
                getter = this._createFieldGetter(fieldName, valueConverter, minOccurs, maxOccurs);
                if (addFieldGetters) this[_getterNameForColumnName(fieldName)] = getter;
                this.fields[fieldLabel] = {
                    name: fieldName,
                    label: fieldLabel,
                    index: this._fieldCount++,
                    type: type,
                    jsType: valueConverter.jsType,
                    minOccurs: minOccurs,
                    maxOccurs: maxOccurs,
                    getter: getter
                };
                this.fieldOrder.push(fieldLabel);
            }
        }
        else {
            Xmla.Exception._newError(
                "ERROR_PARSING_RESPONSE",
                "Xmla.Rowset",
                this._node
            )._throw();
        }
    },
    _createFieldGetter: function(fieldName, valueConverter, minOccurs, maxOccurs){
        var me = this;
        var getter;
        if (maxOccurs===1) {
            if(minOccurs===1)
                getter = function(){
                    var els = _getElementsByTagNameNS (this._row, _xmlnsRowset, null, fieldName);
                    return valueConverter(_getElementText(els.item(0)));
                };
            else
            if (minOccurs === 0)
                getter = function(){
                    var els = _getElementsByTagNameNS (this._row, _xmlnsRowset, null, fieldName);
                    if (els.length) {
                        return valueConverter(_getElementText(els.item(0)));
                    }
                    else {
                        return null;
                    }
                };
        }
        else
        if(minOccurs === 1)
            getter = function(){
                var els = _getElementsByTagNameNS (this._row, _xmlnsRowset, null, fieldName);
                return _arrayConverter(els, valueConverter);
            };
        else
        if (minOccurs === 0)
            getter = function(){
                var els = _getElementsByTagNameNS (this._row, _xmlnsRowset, null, fieldName);
                if (els.length) {
                    return _arrayConverter(els, valueConverter);
                }
                else {
                    return null;
                }
            };
        return getter;
    },
/**
*   Indicates the type of rowset. In most cases, this will be identical to the <code>requestType</code> value that was used in the
*   <code>Discover</code> request
*
*   @method getType
*   @return <code>int</code> One of the <code>DISCOVER_XXX</code>, <code>DBSCHEMA_XXX</code> or <code>MDSCHEMA_XXX</code> constants
*/
    getType: function(){
        return this._type;
    },
/**
*   Retrieve an array of <code>fieldDef</code> objects that describes the fields of the rows in this rowset.
*   The position of the <code>fieldDef</code> objects in the array corresponds to the column order of the rowset.
*   For a description of the <code>fieldDef</code> object, see the
*   <code><a href="#method_fieldDef">fieldDef()</a></code> method.
*
*   @method getFields
*   @return {[fieldDef]} An (ordered) array of field definition objects.
*/
    getFields: function(){
        var f = [],
            i, n = this._fieldCount,
            fieldOrder = this.fieldOrder
        ;
        for (i = 0; i < n; i++) f[i] = this.fieldDef(fieldOrder[i]);
        return f;
    },
/**
*   Retrieve an array of field names.
*   The position of the names in the array corresponds to the column order of the rowset.
*
*   @method getFieldNames
*   @return {[string]} An (ordered) array of field names.
*/
    getFieldNames: function(){
        var fieldNames = [], i, n = this._fieldCount;
        for (i = 0; i < n; i++) fieldNames[i] = this.fieldOrder[i];
        return fieldNames;
    },
/**
*   Indicates wheter the rowset can still be traversed.
*   You can use this method together with the
*   <code><a href="#method_nextRow">nextRow()</a></code> method
*   to drive a <code>while</code> loop to traverse all rows in the rowset, like so:
    <pre>
&nbsp;while(rowset.hasMoreRows()){
&nbsp;    ...process row...
&nbsp;    rowsete.nextRow();
&nbsp;}
    </pre>
*   @method hasMoreRows
*   @return {bool} true in case there are more rows to traverse. false if all rows have been traversed.
*/
    hasMoreRows: function(){
        return this.numRows > this.rowIndex;
    },
/**
*   Moves the internal row index to the next row.
*   You can use this method together with the
*   <code><a href="#method_next">hasMoreRows()</a></code> method
*   to drive a <code>while</code> loop to traverse all rows in the rowset.
*
*   @method nextRow
*/
    nextRow: function(){
        this.rowIndex++;
        this._row = this._rows.item(this.rowIndex);
        return this.rowIndex;
    },
/**
*   This method is deprecated and may be removed in the future.
*   Use <code><a href="#method_nextRow">nextRow()</a></code> instead.
*   @method next
*/
    next: function(){
        return this.nextRow();
    },
/**
*   <p>Walks through all rows, and calls the callback function for each row.</p>
*
*   <p>The callback function gets passed an object that represents the row.
*   The keys of the row object are the column names, and the values are the respective column values.</p>
*   <p>The scope for calling the callback can be passed  as the second argument to this method.
*   If the scope is not defined (or if it is <code>null</code>), the Rowset's <code>this</code> pointer is used instead.</p>
*   <p>You can pass additional data to the callback by passing in a third argument. This is then passed as is as second argument to the callback.</p>
*
*   <p>The <code>eachRow</code> method will iterate untill the callback returns <code>false</code>, or until all rows have been traversed.
*   If the callback returns <code>false</code>, iteration is aborted and <code>eachRow</code> as a whole returns <code>false</code> too.
*   If iteration is not aborted, then eachRow returns <code>true</code>.</p>
*
*   @method eachRow
*   @param {function()} callback Function to be called for each row.
*   @param {Object} scope Optional. Scope in which the callback is called. Defaults to this, that is, the Rowset.
*   @param {Object} args Optional. Object that is passed as extra argument to the callback.
*   @return {bool} true if all rows were itereated. If the callback returns false, iteration stops and false is returned.
*/
    eachRow: function(rowCallback, scope, args){
        if (_isUnd(scope)) scope = this;
        var mArgs = [null];
        if (!_isUnd(args)) {
            if (!_isArr(args)) args = [args];
            mArgs = mArgs.concat(args);
        }
        while (this.hasMoreRows()){
            mArgs[0] = this.readAsObject();
            if (rowCallback.apply(scope, mArgs)===false) return false;
            this.nextRow();
        }
        return true;
    },
/**
*   Gets the value of the internal row index.
*   Note that no check is performed to ensure this points to a valid row:
*   you should call this function only when it is safe to do so.
*   This can be determined by calling <code><a href="method_hasMoreRows">hasMoreRows()</a></code>.
*
*   @method curr
*   @return int
*/
    currRow: function(){
        return this.rowIndex;
    },
/**
*   Returns the number of rows in the set.
*
*   @method rowCount
*   @return int
*/
    rowCount: function(){
        return this.numRows;
    },
/**
*   Resets the internal row pointer so the resultset can be traversed again.
*
*   @method reset
*/
    reset: function(){
        this.rowIndex = 0;
        this._row = (this.hasMoreRows()) ? this._rows.item(this.rowIndex) : null;
    },
/**
*   Retrieves a <code>fieldDef</code> object by name.
*   A fieldDef describes a field (column). It has the following properties:
*   <dl>
*       <dt>label</dt><dd>string. This is the human readable name for this field. You should use this name for display purposes and for building restrictions. This is also the name used for matching againstt the <code>name</code> argument passed to the <code>fieldDef()</code> method.</dd>
*       <dt>name</dt><dd>string. This is the (possibly escaped) name of the field as it appears in the XML document</dd>
*       <dt>index</dt><dd>int. The ordinal position of this field. Fields are numbered starting from 0.</dd>
*       <dt>type</dt><dd>string. The name of the XML data type for the values that appear in this column</dd>
*       <dt>minOccurs</dt><dd>string. The minimal number of occurrences of a value. "0" means the field is optional.</dd>
*       <dt>maxOccurs</dt><dd>string. If this is parseable as an integer, that integer specifies the number of times a value can appear in this column. "unbounded" means there is no declared limit.</dd>
*       <dt>getter</dt><dd>function. This function is used to extract a value from the XML document for this field.</dd>
*   </dl>
*   @method fieldDef
*   @param {string} name The name of the field to retrieve.
*   @return {fieldDef} The <code>fieldDef</code> object that matches the argument.
*/
    fieldDef: function(name){
        var field = this.fields[name];
        if (!field)
            Xmla.Exception._newError(
                "INVALID_FIELD",
                "Xmla.Rowset.fieldDef",
                name
            )._throw();
        return field;
    },
/**
*   Retrieves the index of a field by name.
*   Field indexes start at 0.
*   @method fieldIndex
*   @param {string} name The name of the field for which you want to retrieve the index.
*   @return {int} The ordinal position (starting at 0) of the field that matches the argument.
*/
    fieldIndex: function(name){
        return this.fieldDef(name).index;
    },
/**
*   Retrieves the name of a field by field Index.
*   Field indexes start at 0.
*   @method fieldName
*   @param {string} name The name of the field for which you want to retrieve the index.
*   @return {int} The ordinal position (starting at 0) of the field that matches the argument.
*/
    fieldName: function(index){
        var fieldName = this.fieldOrder[index];
        if (!fieldName)
            Xmla.Exception._newError(
                "INVALID_FIELD",
                "Xmla.Rowset.fieldDef",
                index
            )._throw();
        return fieldName;
    },
/**
*   Retrieves a value from the current row for the field having the name specified by the argument.
*   @method fieldVal
*   @param {string} name The name of the field for which you want to retrieve the value.
*   @return {array|boolean|float|int|string} From the current row, the value of the field that matches the argument.
*/
    fieldVal: function(name){
        if (_isNum(name)) name = this.fieldName(name);
        return this.fieldDef(name).getter.call(this);
    },
/**
*   Returns the number of fields in this rowset.
*   @method fieldCount
*   @return {int} The number of fields in this rowset.
*/
    fieldCount: function(){
        return this._fieldCount;
    },
/**
*   Releases references to the DomDocument passed to the Rowset constructor.
*   This should facilitate automatic garbage collection by the browser.
*   @method close
*/
    close: function(){
        this._node = null;
        this._row = null;
        this._rows = null;
    },
/**
*   Reads the current row and returns the result as a new array.
*   This method does not advance the internal row pointer, and does not check if there is a valid row.
*   This method exists mainly as a convience in case you want to use a custom way to extract data from the resultset using the
*   <code><a href="#method_fetchCustom">fetchCustom()</a></code> method.
*   If you just want to obtain the results as arrays, see
*   <code><a href="#method_fetchAsArray">fetchAsArray()</a></code>
*   and
*   <code><a href="#method_fetchAllAsArray">fetchAllAsArray()</a></code>.
*   @method readAsArray
*   @return {array}
*/
    readAsArray: function(array){
        var fields = this.fields, fieldName, fieldDef;
        if (!array) array = [];
        for (fieldName in fields){
            if (fields.hasOwnProperty(fieldName)){
                fieldDef = fields[fieldName];
                array[fieldDef.index] = fieldDef.getter.call(this);
            }
        }
        return array;
    },
/**
*   Fetch all values from all fields from the current row, and return it in an array.
*   The position of the values in the array corresponds to the column order of the rowset.
*   The internal row pointer is also increased so the next call will read the next row.
*   The method returns false when there are no more rows to traverse.
*   You can use this method to drive a loop to travere all rows in the Rowset:
<pre>
while (rowArray = rowset.fetchAsArray()){
&nbsp;   ...process array...
}
</pre>
*   @method fetchAsArray
*   @return {array}
*/
    fetchAsArray: function(array){
        if (this.hasMoreRows()) {
            array = this.readAsArray(array);
            this.nextRow();
        }
        else array = false;
        return array;
    },
/**
*   Reads the current row and returns the result as a new object.
*   This method does not advance the internal row pointer, and does not check if there is a valid row.
*   This method exists mainly as a convience in case you want to use a custom way to extract data from the resultset using the
*   <code><a href="#method_fetchCustom">fetchCustom()</a></code> method.
*   If you just want to obtain the results as objects, see
*   <code><a href="#method_fetchAsObject">fetchAsObject()</a></code>
*   and
*   <code><a href="#method_fetchAllAsObject">fetchAllAsObject()</a></code>.
*   @method readAsObject
*   @return {object}
*/
    readAsObject: function(object){
        var fields = this.fields, fieldName, fieldDef;
        if (!object) object = {};
        for (fieldName in fields) {
            if (fields.hasOwnProperty(fieldName)) {
                fieldDef = fields[fieldName];
                object[fieldName] = fieldDef.getter.call(this);
            }
        }
        return object;
    },
/**
*   Fetch all values from all fields from the current row, and return it in an Object literal.
*   The property names of the returned object correspond to the fieldName (actually the fieldLabel), and the field value is assigned to its respective property.
*   The internal row pointer is also increased so the next call will read the next row.
*   The method returns false when there are no more rows to traverse.
*   You can use this method to drive a loop to travere all rows in the Rowset:
<pre>
while (rowObject = rowset.fetchAsObject()){
&nbsp;   ...process object...
}
</pre>
*   @method fetchAsObject
*   @return {Object|boolean}
*/
    fetchAsObject: function(object){
        if (this.hasMoreRows()){
            object = this.readAsObject(object);
            this.nextRow();
        }
        else object = false;
        return object;
    },
/**
*   Fetch the values using a custom callback function.
*   If there are rows to fetch, the custom function is called in scope of the rowset, so you can use <code>this</code> inside the custom function to refer to the rowset object.
*   Then, the internal row pointer is increased so the next call will read the next row.
*   The method returns whatever object or value is returned by the custom function, or false when there are no more rows to traverse.
*
*   @method fetchCustom
*   @param func {function} a custom function to extract and return the data from the current row of the xml result.
*   @param args {object} an object that will be passed to the function. Useful to hold any data required in addition to the rowset itself (which can be referred to as this inside the function).
*   @return {mixed|boolean}
*/
    fetchCustom: function(func, args){
        var object;
        if (this.hasMoreRows()){
            object = func.call(this, args);
            this.nextRow();
        }
        else object = false;
        return object;
    },
/**
*   Fetch all values from all fields from all rows, and return it as an array of arrays.
*   See <code><a href="#method_fetchAsArray">fetchAsArray()</a></code>.
*   @method fetchAllAsArray
*   @param rows {array[]} OPTIONAL. An array to append the rows to. If not specified, a new array is created
*   @return {array}
*/
    fetchAllAsArray: function(rows){
        var row;
        if (!rows) rows = [];
        while((row = this.fetchAsArray())) rows.push(row);
        return rows;
    },
/**
*   Fetch all values from all fields from all rows, and return it as an array of objects.
*   See <code><a href="#method_fetchAsObject">fetchAsObject()</a></code>.
*   @method fetchAllAsObject
*   @param rows {array[]} OPTIONAL. An array to append the rows to. If not specified, a new array is created
*   @return {array}
*/
    fetchAllAsObject: function(rows){
        var row;
        if (!rows) rows = [];
        while((row = this.fetchAsObject())) rows.push(row);
        return rows;
    },
/**
*   Fetch all rows using a custom function, and return the return values as an array.
*   See <code><a href="#method_fetchCustom">fetchCustom()</a></code>.
*   @method fetchAllCustom
*   @param rows {array[]} OPTIONAL. An array to append the rows to. If not specified, a new array is created
*   @param func {function} a callback function to extract the fields.
*   @param args {object} an object to pass data to the callback.
*   @return {array}
*/
    fetchAllCustom: function(rows, func, args){
        var row;
        if (!rows) rows = [];
        while((row = this.fetchCustom(func, args))) rows.push(row);
        return rows;
    },
/**
*   Fetch all row as an object, store it in nested objects according to values in the column identified by the key argument.
*   This method should typically not be called directly, rather it is a helper method for <code><a href="#method_mapAllAsObject">mapAllAsObject()</a></code>.
*
*   @method mapAsObject
*   @param map
*   @param key
*   @param row
*   @returns {object} a tree using column values as branch names, and storing a row or an array of rows at the leaves.
*/
    mapAsObject: function(map, key, row){
        var k, v, p, i, len = key.length, last = len - 1, m = map;
        for (i = 0; i < len; i++){
            k = key[i]; //get the keypart
            v = row[k]; //get the value for the key part
            p = m[v];   //get the property from the map for this keypart.
            if (p) {
                if (i === last) {   //last, we need to store the row now.
                    if (_isArr(p)) p.push(row); //already entries here, append
                    else m[v] = [p, row]; //single row store here. since we need multiple rows, add an array
                }
                else m = p;
            }
            else                        //property didnt exist for this key yet.
            if (i === last) m[v] = row; //last keypart: store the row here
            else m = m[v] = {};         //more keyparts to go: add a new map for this keypart
        }
    },
/**
*   Fetch all rows as an object, store them as proprties in an object (which acts as map).
*   @method mapAllAsObject
*   @key {string|array} OPTIONAL. A column name or an array of column names that will be used to generate property names for the map. If not specified, the default key is used. If there is no default key, all column names will be used.
*   @param map {object} OPTIONAL. The object that is used as map. Rows are added as properties to this map. If not specified, a new object is created
*   @return {object}
*/
    mapAllAsObject: function(key, map){
        if (!map) map = {};
        if (!key) key = this.getKey();
        var row;
        while (row = this.fetchAsObject()) this.mapAsObject(map, key, row);
        return map;
    },

/*
*   Find a key for the resultset type.
*/
    getKey: function(){
        return (this._type) ? Xmla.Rowset.KEYS[this._type] : this.getFieldNames();
    }
};

/**
*   <p>
*   This class implements an XML/A multidimensional Dataset object.
*   </p>
*   <p>
*   You do not need to instantiate objects of this class yourself.
*   Rather, the <code><a href="Xmla.html#class_Xmla">Xmla</a></code> class will instantiate this class
*   to convey the result of the <code>executeMultiDimensional</code> method
*   (see <code><a href="Xmla.html#method_executeMultiDimensional">executeMultiDimensional()</a></code>),
*   and possibly the <code>execute</code> method.
*   (Note that the <code><a name="Xmla.html#method_execute">execute()</code> instantiates either the
*   <code><a href="Xmla.html#class_Xmla.Rowset">Xmla.Rowset</a></code> or the <code><a href="Xmla.html#class_Xmla.Rowset">Xmla.Dataset</a></code> class
*   depending on the value of the <code>Format</code> property in the options passed to the <code><a href="Xmla.html#method_execute">execute()</a></code> method.)
*   </p>
*   <p>
*   An instance of the <code>Xmla.Dataset</code> class may be returned immediately as return value from these methods when doing a synchronous request.
*   In addition, the <code>Xmla.Dataset</code> object is available in the eventdata passed to any registered listeners
*   (see <code><a href="Xmla.html#method_addListener">addListener()</a></code>).
*   </p>
*
*   @class Xmla.Dataset
*   @constructor
*   @param {DOMDocument} doc The responseXML result returned by server in response to a <code>Execute</code> request.
*/
Xmla.Dataset = function(doc){
    this._initDataset(doc);
    return this;
}

/**
*   Can be used as argument for <code><a href="#method_getAxis">getAxis()</a></code> to get the first axis (the column axis).
*   Alternatively you can simply call <code><a href="#method_getColumnAxis">getColumnAxis()</a></code>
*   @property AXIS_COLUMNS
*   @static
*   @final
*   @type int
*   @default <code>0</code>
*/
Xmla.Dataset.AXIS_COLUMNS = 0;
/**
*   Can be used as argument for <code><a href="#method_getAxis">getAxis()</a></code> to get the second axis (the row axis).
*   Alternatively you can simply call <code><a href="#method_getRowAxis">getRowAxis()</a></code>
*   @property AXIS_ROWS
*   @static
*   @final
*   @type int
*   @default <code>1</code>
*/
Xmla.Dataset.AXIS_ROWS = 1;
/**
*   Can be used as argument for <code><a href="#method_getAxis">getAxis()</a></code> to get the third axis (the page axis).
*   Alternatively you can simply call <code><a href="#method_getPageAxis">getPageAxis()</a></code>
*   @property AXIS_PAGES
*   @static
*   @final
*   @type int
*   @default <code>2</code>
*/
Xmla.Dataset.AXIS_PAGES = 2;
/**
*   Can be used as argument for <code><a href="#method_getAxis">getAxis()</a></code> to get the fourth axis (the section axis).
*   Alternatively you can simply call <code><a href="#method_getSectionAxis">getSectionAxis()</a></code>
*   @property AXIS_SECTIONS
*   @static
*   @final
*   @type int
*   @default <code>3</code>
*/
Xmla.Dataset.AXIS_SECTIONS = 3;
/**
*   Can be used as argument for <code><a href="#method_getAxis">getAxis()</a></code> to get the fifth axis (the chapters axis).
*   Alternatively you can simply call <code><a href="#method_getChapterAxis">getChapterAxis()</a></code>
*   @property AXIS_CHAPTERS
*   @static
*   @final
*   @type int
*   @default <code>4</code>
*/
Xmla.Dataset.AXIS_CHAPTERS = 4;
/**
*   Can be used as argument for <code><a href="#method_getAxis">getAxis()</a></code> to get the slicer axis
*   (the axis that appears in the <code>WHERE</code> clause of an MDX-<code>SELECT</code> statement).
*   Alternatively you can simply call <code><a href="#method_getSlicerAxis">getSlicerAxis()</a></code>
*   @property AXIS_SLICER
*   @static
*   @final
*   @type string
*   @default <code>SlicerAxis</code>
*/
Xmla.Dataset.AXIS_SLICER = "SlicerAxis";

Xmla.Dataset.prototype = {
    _root:  null,
    _axes: null,
    _axesOrder: null,
    _numAxes: null,
    _slicer: null,
    _cellset:null,
    _initDataset: function(doc){
        this._initRoot(doc);
        this.cubeName = _getElementText(
            _getElementsByTagNameNS(
                this._root, _xmlnsDataset, "", "CubeName"
            ).item(0)
        );
        this._initAxes();
        this._initCells();

        var a, i, j, axis, func, funcBody = "", mul;
        func = "var ordinal = 0, a;" +
            "\nif (arguments.length !== " + this._numAxes + ") new Xmla.Exception._newError(\"ERROR_ILLEGAL_ARGUMENT\", \"cellOrdinalForTupleIndexes\", this)._throw();"
        for (a = 0, i = this._numAxes-1; i >= 0; i--, a++) {
            func += "\nif (typeof(a = arguments[" + a + "])!==\"number\") new Xmla.Exception._newError(\"ERROR_ILLEGAL_ARGUMENT\", \"cellOrdinalForTupleIndexes\", this)._throw();";
            mul = 1;
            for (j = i-1; j >= 0; j--) mul *= this._axesOrder[j].tupleCount();
            func += "\nordinal += a ";
            if (i) func += "* " + mul + ";";
        }
        func += funcBody + "\nreturn ordinal;"
        this._cellset.cellOrdinalForTupleIndexes = this.cellOrdinalForTupleIndexes = new Function(func);
    },
    _initRoot: function(doc){
        var root = _getElementsByTagNameNS(doc, _xmlnsDataset, "", "root");
        if (root.length) this._root = root.item(0);
        else
            Xmla.Exception._newError(
                "ERROR_PARSING_RESPONSE",
                "Xmla.Dataset._initData",
                doc
            )._throw();
    },
    _initAxes: function(){
        var i, axis, axisNode, axisName, axisNodes, numAxisNodes, tmpAxes = {};

        this._axes = {};
        this._axesOrder = [];

        //collect the axisInfo nodes
        axisNodes = _getElementsByTagNameNS(this._root, _xmlnsDataset, "", "AxisInfo");
        numAxisNodes = axisNodes.length;
        for (i = 0; i < numAxisNodes; i++) {
            axisNode = axisNodes.item(i);
            axisName = axisNode.getAttribute("name");
            tmpAxes[axisName] = axisNode;
        }
        //collect the axis nodes
        axisNodes = _getElementsByTagNameNS(this._root, _xmlnsDataset, "", "Axis");
        numAxisNodes = axisNodes.length;
        for (i = 0; i < numAxisNodes; i++){
            axisNode = axisNodes.item(i);
            axisName = axisNode.getAttribute("name");
            axis = new Xmla.Dataset.Axis(tmpAxes[axisName], axisNode, axisName, i);
            if (axisName === Xmla.Dataset.AXIS_SLICER) this._slicer = axis;
            else {
                this._axes[axisName] = axis;
                this._axesOrder.push(axis);
            }
        }
        this._numAxes = this._axesOrder.length;
    },
    _initCells: function(){
        this._cellset = new Xmla.Dataset.Cellset(this);
    },
/**
*   Get the number of proper axes in this Dataset. This is the number of axes that appears in the <code>SELECT</code> list, and excludes the slicer axis.
*   @method axisCount
*   @return {int}
*/
    axisCount: function(){
        return this._numAxes;
    },
    _getAxis: function(nameOrIndex) {
        var name, axis;
        switch (typeof(nameOrIndex)) {
            case "number":
                axis = this._axesOrder[nameOrIndex];
                break;
            case "string":
                axis = (name === Xmla.Dataset.AXIS_SLICER) ? this._slicer : this._axes[name];
                break;
        }
        return axis;
    },
/**
*   Get the axis specified by the argument index or name.
*   If the axis does not exist, an <code>INVALID_AXIS</code> exception is thrown.
*   To prevent an exception from being thrown, you should call the <code><a href="#method_hasAxis">hasAxis()</a></code> method to determine if the axis exists.
*   Alternatively, you can call <code><a href="#method_axisCount">axisCount()</a></code>, and use an integer argument between zero (inclusive) and axis count (exclusive).
*   @method getAxis
*   @param nameOrIndex {string | int} For int arguments, a value of 0 up to the number of axes. You can also use one of the <code>AXIS_xxx</code> constants. For string arguments, this method will match the name of the axis as it is returned in the XML/A response. These names are of the form <code>AxisN</code> where N is an ordinal that identifies the axis.
*   @return {Xmla.Dataset.Axis} The <code><a href="Xmla.Dataset.Axis.html#class_Axis">Xmla.Dataset.Axis</a></code> object that corresponds to the argument.
*/
    getAxis: function(nameOrIndex){
        if (nameOrIndex === Xmla.Dataset.AXIS_SLICER) return this._slicer;
        var axis = this._getAxis(nameOrIndex);
        if (!axis)
            Xmla.Exception._newError(
                "INVALID_AXIS",
                "Xmla.Dataset.getAxis",
                nameOrIndex
            )._throw();
        return axis;
    },
/**
*   Determine if the axis specified by the argument exists.
*   @method hasAxis
*   @param nameOrIndex {string | int} For int arguments, a value of 0 up to the number of axes. You can also use one of the <code>AXIS_xxx</code> constants. For string arguments, this method will match the name of the axis as it is returned in the XML/A response. These names are of the form <code>AxisN</code> where N is an ordinal that identifies the axis.
*   @return {boolean} <code>true</code> if the specified axis exists, <code>false</code> if it doesn't exist.
*/
    hasAxis: function(nameOrIndex) {
        var axis = this._getAxis(nameOrIndex);
        return !_isUnd(axis);
    },
/**
*   Get the Column axis. This is the first axis, and has ordinal 0. If the column axis doesn't exist, an <code>INVALID_AXIS</code> exception is thrown.
*   To prevent an exception from being thrown, you should call the <code><a href="#method_hasColumnAxis">hasColumnAxis()</a></code> method to determine if the axis exists.
*   @method getColumnAxis
*   @return {Xmla.Dataset.Axis} The column <code><a href="Xmla.Dataset.Axis.html#class_Axis">Xmla.Dataset.Axis</a></code> object.
*/
    getColumnAxis: function(){
        return this.getAxis(Xmla.Dataset.AXIS_COLUMNS);
    },
/**
*   Determine if the column axis exists.
*   @method hasColumnAxis
*   @return {boolean} <code>true</code> if the column axis exists, <code>false</code> if it doesn't exist.
*/
    hasColumnAxis: function(){
        return this.hasAxis(Xmla.Dataset.AXIS_COLUMNS);
    },
/**
*   Get the Row axis. This is the second axis, and has ordinal 1. If the row axis doesn't exist, an <code>INVALID_AXIS</code> exception is thrown.
*   To prevent an exception from being thrown, you should call the <code><a href="#method_hasRowAxis">hasRowAxis()</a></code> method to determine if the axis exists.
*   @method getRowAxis
*   @return {Xmla.Dataset.Axis} The row <code><a href="Xmla.Dataset.Axis.html#class_Axis">Xmla.Dataset.Axis</a></code> object.
*/
    getRowAxis: function(){
        return this.getAxis(Xmla.Dataset.AXIS_ROWS);
    },
/**
*   Determine if the row axis exists.
*   @method hasRowAxis
*   @return {boolean} <code>true</code> if the row axis exists, <code>false</code> if it doesn't exist.
*/
    hasRowAxis: function(){
        return this.hasAxis(Xmla.Dataset.AXIS_ROWS);
    },
/**
*   Get the Page axis. This is the third axis, and has ordinal 2. If the page axis doesn't exist, an <code>INVALID_AXIS</code> exception is thrown.
*   To prevent an exception from being thrown, you should call the <code><a href="#method_hasPageAxis">hasPageAxis()</a></code> method to determine if the axis exists.
*   @method getPageAxis
*   @return {Xmla.Dataset.Axis} The page <code><a href="Xmla.Dataset.Axis.html#class_Axis">Xmla.Dataset.Axis</a></code> object.
*/
    getPageAxis: function(){
        return this.getAxis(Xmla.Dataset.AXIS_PAGES);
    },
/**
*   Determine if the page axis exists.
*   @method hasPageAxis
*   @return {boolean} <code>true</code> if the page axis exists, <code>false</code> if it doesn't exist.
*/
    hasPageAxis: function(){
        return this.hasAxis(Xmla.Dataset.AXIS_PAGES);
    },
/**
*   Get the Section axis. This is the fourth axis, and has ordinal 3. If the section axis doesn't exist, an <code>INVALID_AXIS</code> exception is thrown.
*   To prevent an exception from being thrown, you should call the <code><a href="#method_hasPageAxis">hasSectionAxis()</a></code> method to determine if the axis exists.
*   @method getSectionAxis
*   @return {Xmla.Dataset.Axis} The section <code><a href="Xmla.Dataset.Axis.html#class_Axis">Xmla.Dataset.Axis</a></code> object.
*/
    getSectionAxis: function(){
        return this.getAxis(Xmla.Dataset.AXIS_SECTIONS);
    },
/**
*   Determine if the section axis exists.
*   @method hasSectionAxis
*   @return {boolean} <code>true</code> if the section axis exists, <code>false</code> if it doesn't exist.
*/
    hasSectionAxis: function(){
        return this.hasAxis(Xmla.Dataset.AXIS_SECTIONS);
    },
/**
*   Get the Chapter axis. This is the fifth axis, and has ordinal 4. If the chapter axis doesn't exist, an <code>INVALID_AXIS</code> exception is thrown.
*   To prevent an exception from being thrown, you should call the <code><a href="#method_hasChapterAxis">hasChapterAxis()</a></code> method to determine if the axis exists.
*   @method getChapterAxis
*   @return {Xmla.Dataset.Axis} The chapter <code><a href="Xmla.Dataset.Axis.html#class_Axis">Xmla.Dataset.Axis</a></code> object.
*/
    getChapterAxis: function(){
        return this.getAxis(Xmla.Dataset.AXIS_CHAPTERS);
    },
/**
*   Determine if the chapter axis exists.
*   @method hasChapterAxis
*   @return {boolean} <code>true</code> if the chapter axis exists, <code>false</code> if it doesn't exist.
*/
    hasChapterAxis: function(){
        return this.hasAxis(Xmla.Dataset.AXIS_CHAPTERS);
    },
/**
*   Get the Slicer axis. This is the axis that appears in the <code>WHERE</code> clause of the MDX statement.
*   @method getSlicerAxis
*   @return {Xmla.Dataset.Axis} The slicer <code><a href="Xmla.Dataset.Axis.html#class_Axis">Xmla.Dataset.Axis</a></code> object.
*/
    getSlicerAxis: function(){
        return this._slicer;
    },
/**
*   Get the Cellset object.
*   @method getCellset
*   @return {Xmla.Dataset.Cellset} The <code><a href="Xmla.Dataset.Cellset.html#class_Cellset">Xmla.Dataset.Cellset</a></code> object.
*/
    getCellset: function(){
        return this._cellset;
    },
/**
*   <p>Calculate the cellset ordinal for the argument tuple indexes.</p>
*   <p>This method accepts a variable number of tuple indexes. One integer argument must be passed for each proper axis (excluding the slicer axis).
*   Each integer arguments represent the index of a tuple on the respective axis.</p>
*   <p>The arguments must be specified by descending axis order. So if the data set has two axes (a row and a column axis),
*   this method expects the tuple index of a tuple on the row axis first, and after that, the tuple index on the column axis.</p>
*   <p>The method returns an integer that represents the ordinal of the cell identified by the tuples specified by the tuple index arguments.
*   One could use this ordinal as argument to the <code><a href="Xmla.Dataset.Cellset.html#method_getByOrdinal">getByOrdinal()</a></code> method of this Dataset's <code><a href="Xmla.Dataset.Cellset.html#class_Cellset">Cellset</a></code>.</p>
*   <p>Instead of calling this method and passing the result into the Cellsets <code><a href="Xmla.Dataset.Cellset.html#method_getByOrdinal">getByOrdinal()</a></code> method,
*   you can call the <code><a href="Xmla.Dataset.Cellset.html#method_getByTupleIndexes">getByTupleIndexes()</a></code> method  of this Dataset's <code><a href="Xmla.Dataset.Cellset.html#class_Cellset">Cellset</a></code>.</p>
*   @method cellOrdinalForTupleIndexes
*   @param {int} A variable number of integer tuple indexes. Tuple indexes should be passed in descending order of axes.
*   @return {int} The ordinal number that identifies the cell from this Dataset's <code><a href="Xmla.Dataset.Cellset.html#class_Cellset">Xmla.Dataset.Cellset</a></code> that belongs to the tuples identified by the arguments.
*/
    cellOrdinalForTupleIndexes: function() {
        throw "Not implemented"
    },
/**
*   Cleanup this Dataset object.
*   @method close
*/
    close: function(){
        if (this._slicer) this._slicer.close();
        var i, n = this._numAxes;
        for (i = 0; i < n; i++) this.getAxis(i).close();
        this._cellset.close();
        this._root = null;
        this._axes = null;
        this._axesOrder = null;
        this._numAxes = null;
        this._slicer = null;
    }
};

/**
*   <p>
*   This class implements an Axis object.
*   </p>
*   <p>
*   You do not need to instantiate objects of this class yourself.
*   Rather, the <code><a href="Xmla.Dataset.html#class_Xmla.Dataset">Xmla.Dataset</a></code> class creates instances of this class to represent the axes of an MDX query.
*   (see <code><a href="Xmla.Dataset.html#method_getAxis">getAxis()</a></code>.)
*
*   @class Xmla.Dataset.Axis
*   @constructor
*/
Xmla.Dataset.Axis = function(_axisInfoNode, _axisNode, name, id){
    this._initAxis(_axisInfoNode, _axisNode);
    this.name = name;
    this.id = id;
    return this;
}

Xmla.Dataset.Axis.MEMBER_UNIQUE_NAME = "UName";
Xmla.Dataset.Axis.MEMBER_CAPTION = "Caption";
Xmla.Dataset.Axis.MEMBER_LEVEL_NAME = "LName";
Xmla.Dataset.Axis.MEMBER_LEVEL_NUMBER = "LNum";
Xmla.Dataset.Axis.MEMBER_DISPLAY_INFO = "DisplayInfo";

Xmla.Dataset.Axis.prototype = {
    _tuples: null,
    _members: null,
    numTuples: null,
    numHierarchies: null,
    _tupleIndex: null,
    _hierarchyIndex: null,
    _hierarchyOrder: null,
    _hierarchyDefs: null,
    _hierarchyIndexes: null,
    _initHierarchies: function(_axisInfoNode){
        var hierarchyInfoNodes = _getElementsByTagNameNS(
                _axisInfoNode,
                _xmlnsDataset,
                "",
                "HierarchyInfo"
            ),
            numHierarchies = hierarchyInfoNodes.length,
            i, j, hierarchyInfoNode, hierarchyName,
            properties, numPropertyNodes, propertyNodes, propertyNode
        ;
        this._hierarchyDefs = {};
        this._hierarchyOrder = [];
        this._hierarchyIndexes = {};
        this.numHierarchies = numHierarchies;
        for (i = 0; i < numHierarchies; i++){
            hierarchyInfoNode = hierarchyInfoNodes.item(i);
            hierarchyName = hierarchyInfoNode.getAttribute("name");
            this._hierarchyOrder[i] = hierarchyName;
            this._hierarchyIndexes[hierarchyName] = i;
            properties = {
                index: i,
                name: hierarchyName
            };
            propertyNodes = _getElementsByTagNameNS(
                _axisInfoNode,
                _xmlnsDataset,
                "",
                "*"
            );
            numPropertyNodes = propertyNodes.length;
            for (j = 0; j < numPropertyNodes; j++) {
                propertyNode = propertyNodes.item(j);
                properties[propertyNode.tagName] = null;
            }
            this._hierarchyDefs[hierarchyName] = properties;
        }

    },
    _initAxis: function(_axisInfoNode, _axisNode){
        this.name = _axisNode.getAttribute("name");

        this._initHierarchies(_axisInfoNode);
        this._tuples = _getElementsByTagNameNS(_axisNode, _xmlnsDataset, "", "Tuple");
        this.numTuples = this._tuples.length;
        this.reset();
    },
    _getMembers: function(){
        if (!this.hasMoreTuples()) return null;
        return _getElementsByTagNameNS(
            this._tuples.item(this._tupleIndex),
            _xmlnsDataset, "", "Member"
        );
    },
/**
*   Resets this axis object.
*   This resets internal counters for iterating through the hierarchies and tuples of this Axis object.
*   When using hierarchy and tuple iterators to traverse the entire axis, you typically won't need to call this method yourself.
*   @method reset
*/
    reset: function(){
        this._hierarchyIndex = 0;
        this._tupleIndex = 0;
        this._members = this._getMembers();
    },
/**
*   Checks if there are more hierarchies to iterate through.
*   You can use this method along with the <code><a href="#method_nextHierarchy">nextHierarchy()</a></code> method to drive a loop
*   to iterate through the hierarchies contained in this axis object.
*   @method hasMoreHierarchies
*   @return {boolean} Returns <code>true</code> if there are more hierarchies to vist, <code>false</code> if all hierarchies are traversed.
*/
    hasMoreHierarchies: function(){
        return this.numHierarchies > this._hierarchyIndex;
    },
/**
*   Moves the internal hierarchy pointer forward.
*   You can use this method along with the <code><a href="#method_hasMoreHierarchies">hasMoreHierarchies()</a></code> method to drive a loop
*   to iterate through the hierarchies contained in this axis object.
*   @method nextHierarchy
*   @return {int} Returns the index of current hierarchy.
*/
    nextHierarchy: function(){
        return this._hierarchyIndex++;
    },
/**
*   <p>Calls a callback function for each hierarchy in this Axis object.</p>
*   <p>The callback function is passed an object that represents the current hierarchy. This object has the following structure:</p><ul>
*     <li><code>index</code> <code>int</code> The ordinal identifying this hierarchy</li>
*     <li><code>name</code> <code>string</code> The name of this hierarchy</li>
*   </ul>
*   <p>The callback may return <code>false</code> to abort iteration. If the callback does not return <code>false</code>, iteration will resume until all hierarchies are traversed.</p>
*   @param {function()} callback. A function that will be called for each hierarchy. The hierarchy is passed as an object as the first argument to the callback.
*   @param {object} scope. The object that will be used as scope when executing the callback function. If this is undefined or <code>null</code>, the Axis' <code>this</code> pointer will be used.
*   @param {object} args. Additional data to be passed to the callback function..
*   @method eachHierarchy
*   @return {boolean} Returns <code>true</code> if all hierarchies were visited and the callback did not return <code>false</code>. Returns <code>false</code> if the callback returned <code>false</code> and further iteration was aborted.
*/
    eachHierarchy: function(callback, scope, args){
        var mArgs = [null];
        if (!scope) scope = this;
        if (args) {
            if (!_isArr(args)) args = [args];
            mArgs = mArgs.concat(args);
        }
        while (this.hasMoreHierarchies()){
            mArgs[0] = this._hierarchyDefs[this._hierarchyOrder[this._hierarchyIndex]];
            if (callback.apply(scope, mArgs)===false) return false;
            this.nextHierarchy();
        }
        this._hierarchyIndex = 0;
        return true;
    },
/**
*   Checks if there are more tuples to iterate through.
*   You can use this method along with the <code><a href="#method_nextTuple">nextTuple()</a></code> method to drive a loop
*   to iterate through the tuples contained in this axis object.
*   @method hasMoreTuples
*   @return {boolean} Returns <code>true</code> if there are more tuples to vist, <code>false</code> if all tuples are traversed.
*/
    hasMoreTuples: function(){
        return this.numTuples > this._tupleIndex;
    },
/**
*   Moves the internal tuple pointer forward.
*   You can use this method along with the <code><a href="#method_nextTuple">nextTuple()</a></code> method to drive a loop
*   to iterate through the tuples contained in this axis object.
*   @method nextTuple
*   @return {int} Returns the index of current tuple.
*/
    nextTuple: function(){
        this._tupleIndex++;
        this._members = this._getMembers();
        return this._tupleIndex;
    },
/**
*   Gets the number of tuples in this axis object.
*   @method tupleCount
*   @return {int} Returns the number of tuples in this Axis object.
*/
    tupleCount: function(){
        return this.numTuples;
    },
/**
*   Returns the current value of the tuple pointer.
*   @method tupleIndex
*   @return {int} Returns the current value of the tuple pointer.
*/
    tupleIndex: function() {
        return this._tupleIndex;
    },
/**
*   Get the current tuple as an object. The tuple object has the following structure: <ul>
*       <li><code>index</code> <code>int</code>: the ordinal of this tuple within its axis</li>
*       <li><code>hierarchies</code> <code>object</code>: A map of members using hierarchy names as keys, and member objects as values</li>
*       <li><code>members</code> <code>array</code>: An array of members in order of hierarchy order.</li>
*   </ul>
*   @method getTuple
*   @return {object} An object representing the current tuple..
*/
    getTuple: function() {
        var i, n = this.numHierarchies,
            hierarchies = {}, members = [],
            tuple = {
                index: this._tupleIndex,
                hierarchies: hierarchies,
                members: members
            }
        ;
        for (i=0; i < n; i++) members.push(hierarchies[this._hierarchyOrder[i]] = this._member(i));
        return tuple;
    },
/**
*   <p>Calls a callback function for each tuple in this Axis object.</p>
*   <p>The callback function is passed an object that represents the current tuple. (see <code><a href="#method_getTuple">getTuple()</a></code> for a description of the tuple format.)</p>
*   <p>The callback may return <code>false</code> to abort iteration. If the callback does not return <code>false</code>, iteration will resume until all tuples are traversed.</p>
*   @param {function()} callback. A function that will be called for each tuple. The tuple is passed as an object as the first argument to the callback.
*   @param {object} scope. The object that will be used as scope when executing the callback function. If this is undefined or <code>null</code>, the Axis' <code>this</code> pointer will be used.
*   @param {object} args. Additional data to be passed as the second argument to the callback function.
*   @method eachTuple
*   @return {boolean} Returns <code>true</code> if all tuples were visited and the callback did not return <code>false</code>. Returns <code>false</code> if the callback returned <code>false</code> and further iteration was aborted.
*/
    eachTuple: function(callback, scope, args){
        var mArgs = [null];
        if (!scope) scope = this;
        if (args) {
            if (_isArr(args)) mArgs.concat(args)
            else mArgs.push(args);
        }
        while (this.hasMoreTuples()){
            mArgs[0] = this.getTuple();
            if (callback.apply(scope, mArgs) === false) return false;
            this.nextTuple();
        }
        this._tupleIndex = 0;
        this._members = this._getMembers();
        return true;
    },
/**
 *  Returns the hierarchies of this Axis object.
*   @method getHierarchies
*   @return {array} An array of hierarchies contained in this Axis.
 **/
    getHierarchies: function(){
        return this._hierarchyDefs;
    },
/**
 *  Returns the names of the hierarchies of this Axis object.
*   @method getHierarchyNames
*   @return {array} An array of names of the hierarchies contained in this Axis.
 **/
    getHierarchyNames: function(){
        var hierarchyNames = [], i, n = this.numHierarchies;
        for (i = 0; i < n; i++) hierarchyNames[i] = this._hierarchyOrder[i];
        return hierarchyNames;
    },
/**
*   Gets the number of hierarchies in this axis object.
*   @method hierarchyCount
*   @return {int} Returns the number of hierarchies in this Axis object.
*/
    hierarchyCount: function(){
        return this.numHierarchies;
    },
/**
*   Gets the index of the hierarchy identified by the specified name, or the index of the current hierarchy (in case the name argument is omitted).
*   @method hierarchyIndex
*   @param hierarchyName {string} The name of the hierarchy for which the index is to be retrieved. When omitted, the index of the current hierarchy is returned.
*   @return {int} The index of the hierarchy specified by the name passed as argument, or the index of the current hierarchy if the name argument is omitted.
*/
    hierarchyIndex: function(hierarchyName){
        if (_isUnd(hierarchyName)) return this._hierarchyIndex;
        var index = this._hierarchyIndexes[hierarchyName];
        if (_isUnd(index))
            Xmla.Exception._newError(
                "INVALID_HIERARCHY",
                "Xmla.Dataset.Axis.hierarchyDef",
                hierarchyName
            )._throw();
        return index;
    },
/**
*   Gets the name of the hierarchy identified by the specified index, or the name of the current hierarchy (in case the index argument is omitted).
*   @method hierarchyName
*   @param hierarchyIndex {int} The ordinal of the hierarchy for which the name is to be retrieved. When omitted, the name of the current hierarchy is returned.
*   @return {string} The name of the hierarchy specified by the argument index, or the name of the current hierarchy if the index argument is omitted.
*/
    hierarchyName: function(index){
        if (_isUnd(index)) index = this._hierarchyIndex;
        if (index !== parseInt(index, 10) ||
            index >= this.numHierarchies
        )
            Xmla.Exception._newError(
                "INVALID_HIERARCHY",
                "Xmla.Dataset.Axis.hierarchyDef",
                index
            )._throw();
        return this._hierarchyOrder[index];
    },
/**
*   Gets the hierarchy identified by the specified index or hierarchyName, or the current hierarchy (in case the argument is omitted).
*   @method hierarchy
*   @param hierarchyIndexOrName {int|string} The ordinal or name of the hierarchy that is to be retrieved. When omitted, the the current hierarchy is returned.
*   @return {string} The hierarchy specified by the argument index or name, or the current hierarchy if the argument is omitted.
*/
    hierarchy: function(hierarchyIndexOrName){
        if (_isUnd(hierarchyIndexOrName)) index = this._hierarchyIndex;
        var index, hierarchyName, hierarchy;
        if (_isNum(hierarchyIndexOrName)) {
            if (hierarchyIndexOrName !== parseInt(hierarchyIndexOrName, 10)
            ||  hierarchyIndexOrName >= this.numHierarchies
            )
                Xmla.Exception._newError(
                    "INVALID_HIERARCHY",
                    "Xmla.Dataset.Axis.hierarchyDef",
                    hierarchyIndexOrName
                )._throw();
            hierarchyName = this.hierarchyName(hierarchyIndexOrName);
        }
        else hierarchyName = hierarchyIndexOrName;
        hierarchy = this._hierarchyDefs[hierarchyName];
        if (_isUnd(hierarchy))
            Xmla.Exception._newError(
                "INVALID_HIERARCHY",
                "Xmla.Dataset.Axis.hierarchyDef",
                hierarchyName
            )._throw();
        return hierarchy;
    },
/**
*   Gets the member for the specified hierarchy from the current tuple. The member has the following structure: <ul>
*     <li><code>index</code> - <code>int</code></li>
*     <li><code>hierarchy</code> - <code>string</code>. Name of the hiearchy to which this member belongs.</li>
*     <li><code>UName</code> - <code>string</code>. Unique name of this member.</li>
*     <li><code>Caption</code> - <code>string</code>. Human friendly name for this member.</li>
*     <li><code>LName</code> - <code>string</code>. Name of the level to which this member belongs.</li>
*     <li><code>LNum</code> - <code>int</code>. Number of the level to which this member belongs. Typically, the top-level is level 0, its children are level 1 and so on.</li>
*     <li><code>DisplayInfo</code> - <code>int</code>.</li>
*   </ul>
*   <p>
*   The <code>index</code> and <code>hierarchy</code> properties are non standard and always added by Xmla4js.
*   The properties <code>UName</code>, <code>Caption</code>, <code>LName</code> and <code>LNum</code> are defined by the XML/A standard, and should always be present.
*   The property <code>DisplayInfo</code> is non-standard, but often available.
*   Other properties may be present depending on the specific XML/A provider.
*   </p>
*   @method member
*   @param hierarchyIndexOrName {int|string} The ordinal or name of the hierarchy from which the member is to be retrieved. When omitted, the the current hierarchy is returned.
*   @return {object} The member of the current tuple that belongs to the specified hierarchy, If the argument is omitted the member that belongs current hierarchy is retrieved from the current tuple.
*/
    member: function(hierarchyIndexOrName){
        if (_isUnd(hierarchyIndexOrName)) index = this._hierarchyIndex;
        var index, hierarchyName, hierarchy;
        switch(typeof(hierarchyIndexOrName)){
            case "string":
                index = this.hierarchyIndex(hierarchyIndexOrName);
                hierarchyName = hierarchyIndexOrName;
                break;
            case "number":
                if (hierarchyIndexOrName !== parseInt(hierarchyIndexOrName, 10) ||
                    hierarchyIndexOrName >= this.numHierarchies
                )
                    Xmla.Exception._newError(
                        "INVALID_HIERARCHY",
                        "Xmla.Dataset.Axis.hierarchyDef",
                        hierarchyIndexOrName
                    )._throw();
                index = hierarchyIndexOrName;
                break;
        }
        return this._member(index);
    },
    _member: function(index){
        var memberNode = this._members.item(index),
            hierarchyName = this.hierarchyName(index),
            hierarchy = this.hierarchy(hierarchyName),
            property,
            member = {
                index: index,
                hierarchy: hierarchyName
            },
            el
        ;
        for (property in hierarchy){
            if (property === "index" || property === "name") continue;
            el = _getElementsByTagNameNS(memberNode, _xmlnsDataset, "", property);
            switch (el.length) {
                case 0: //no element found for property, use the default
                    member[property] = hierarchy[property]
                    break;
                case 1: //this is expected, single element for property, get value
                    member[property] = _getElementText(el.item(0));
                    break;
                default:
                    Xmla.Exception._newError(
                        "UNEXPECTED_ERROR_READING_MEMBER",
                        "Xmla.Dataset.Axis.member",
                        property
                    )._throw();
            }
        }
        return member;
    },
/**
*   Gets the current tuple as an array of members.
*   For a description of the structure of the member elements, see <code><a href="#method_member">member()</a></code>.
*   @method readAsArray
*   @param array {array} An existing array to store the members in. If omitted, a new array is returned.
*   @return {array} An array of members that represents the current tuple.
*/
    readAsArray: function(array){
        if (!array) array = [];
        var i, n = this.numHierarchies;
        for (i = 0; i < n; i++) array[i] = this._member(i);
        return array;
    },
/**
*   Gets the current tuple as an object.
*   The object's keys are the hierarchy names, and the members of the current tuple are used as values for the keys.
*   For a description of the structure of the member elements, see <code><a href="#method_member">member()</a></code>.
*   @method readAsObject
*   @param object {object} An existing object to store the tuple data in. If omitted, a new object is returned.
*   @return {object} An object that represents the current tuple.
*/
    readAsObject: function(object){
        if (!object) object = {};
        var i, n = this.numHierarchies;
        for (i = 0; i < n; i++) object[this._hierarchyOrder[i]] = this._member(i);
        return object;
    },
/**
*   Gets the current tuple as an array of members and advances the internal tuple pointer.
*   For a description of the structure of the member elements, see <code><a href="#method_member">member()</a></code>.
*   @method fetchAsArray
*   @param array {array} An existing array to store the members in. If omitted, a new array is returned.
*   @return {array|false} An array of members that represents the current tuple, or <code>false</code> if there are no more tuples.
*/
    fetchAsArray: function(array){
        if (this.hasMoreTuples()) {
            array = this.readAsArray(array);
            this.nextTuple();
        }
        else array = false;
        return array;
    },
/**
*   Gets the current tuple as an object and advances the current tuple pointer.
*   The object's keys are the hierarchy names, and the members of the current tuple are used as values for the keys.
*   For a description of the structure of the member elements, see <code><a href="#method_member">member()</a></code>.
*   @method fetchAsObject
*   @param object {object} An existing object to store the tuple data in. If omitted, a new object is returned.
*   @return {object} An object that represents the current tuple.
*/
    fetchAsObject: function(object){
        if (this.hasMoreTuples(object)){
            object = this.readAsObject();
            this.nextTuple();
        }
        else object = false;
        return object;
    },
/**
*   Fetches all tuples and returns them as an array of arrays.
*   Each element of the returned array is an array of member objects.
*   For a description of the structure of the member elements, see <code><a href="#method_member">member()</a></code>.
*   @method fetchAllAsArray
*   @param rows {array} An existing array to store the tuples in. If omitted, a new array is returned.
*   @return {[[array]]} An array of arrays representing all tuples that belong to this axis.
**/
    fetchAllAsArray: function(rows){
        var row;
        if (!rows) rows = [];
        while((row = this.fetchAsArray())) rows.push(row);
        return rows;
    },
/**
*   Fetches all tuples and returns them as an array of objects.
*   Each element of the returned array is a tuple object.
*   The object's keys are the hierarchy names, and the members of the current tuple are used as values for the keys.
*   For a description of the structure of the member elements, see <code><a href="#method_member">member()</a></code>.
*   @method fetchAllAsObject
*   @param rows {array} An existing array to store the tuples in. If omitted, a new array is returned.
*   @return {[[object]]} An array of arrays representing all tuples that belong to this axis.
**/
    fetchAllAsObject: function(rows){
        var row;
        if (!rows) rows = [];
        while((row = this.fetchAsObject())) rows.push(row);
        return rows;
    }
}

/**
*   <p>
*   This class implements a Cellset object.
*   </p>
*   <p>
*   You do not need to instantiate objects of this class yourself.
*   Rather, the <code><a href="Xmla.Dataset.html#class_Xmla.Dataset">Xmla.Dataset</a></code> class creates instances of this class to represent the cells (the value of the measures) of an MDX query.
*   (see <code><a href="Xmla.Dataset.html#method_getCellset">getCellset()</a></code>.)
*
*   @class Xmla.Dataset.Cellset
*   @constructor
*/
Xmla.Dataset.Cellset = function(dataset){
    this._dataset = dataset;
    this._initCellset();
    return this;
}

Xmla.Dataset.Cellset.prototype = {
    _dataset: null,
    _cellNodes: null,
    _cellCount: null,
    _cellNode: null,
    _cellProperties: null,
    _idx: null,
    _cellOrd: null,
    _initCellset: function(){
        var root = this._dataset._root,
            cellSchema, cellSchemaElements, numCellSchemaElements, cellSchemaElement,
            cellInfoNodes, cellInfoNode, cellNodes, type,
            propertyNodes, propertyNode, propertyNodeTagName, numPropertyNodes, i, j
        ;
        cellSchema = _getComplexType(root, "CellData");
        if (!cellSchema)
            Xmla.Exception._newError(
                "ERROR_PARSING_RESPONSE",
                "Xmla.Rowset",
                root
            )._throw();
        cellSchemaElements = _getElementsByTagNameNS(
            cellSchema, _xmlnsSchema, _xmlnsSchemaPrefix, "element"
        );
        numCellSchemaElements = cellSchemaElements.length;
        cellInfoNodes = _getElementsByTagNameNS(
            root, _xmlnsDataset, "", "CellInfo"
        );
        if (!cellInfoNodes || cellInfoNodes.length===0)
            Xmla.Exception._newError(
                "ERROR_PARSING_RESPONSE",
                "Xmla.Rowset",
                root
            )._throw();

        cellInfoNode = cellInfoNodes.item(0);
        propertyNodes = _getElementsByTagNameNS(
            cellInfoNode, _xmlnsDataset, "", "*"
        );
        this._cellProperties = {};
        //examine cell property info so we can parse them
        numPropertyNodes = propertyNodes.length;
        for(i = 0; i < numPropertyNodes; i++) {
            propertyNode = propertyNodes.item(i);
            propertyNodeTagName = propertyNode.tagName;
            //find the xsd:element node that describes this property
            for (j = 0; j < numCellSchemaElements; j++) {
                cellSchemaElement = cellSchemaElements.item(j);
                if (cellSchemaElement.getAttribute("name") !== propertyNodeTagName) continue;
                type = cellSchemaElement.getAttribute("type");
                this._cellProperties[propertyNodeTagName] = _typeConverterMap[type];
                this["cell" + propertyNodeTagName] = new Function("return this.cellProperty(\"" + propertyNodeTagName + "\")");
                break;
            }
        }
        this._cellNodes = _getElementsByTagNameNS(
            root, _xmlnsDataset, "", "Cell"
        );
        this._cellCount = this._cellNodes.length;
        this.reset();
    },
    _getCellNode: function(index){
        if (!_isUnd(index)) this._idx = index;
        this._cellNode = this._cellNodes.item(this._idx);
        this._cellOrd = this._getCellOrdinal(this._cellNode);
    },
    _getCellOrdinal: function(node){
        return parseInt(node.getAttribute("CellOrdinal"), 10);
    },
/**
*   Returns the number of cells contained in this cellset.
*   This is the number of cells that is actually present in the cellset - not the number of logical cells.
*   The nuber of logical cells can be be calculated by multiplying the tuple counts of all axes of the data set.
*   The XML/A provider will typically not return empty cells, hence, the cellCount may be less than the logical cell count.
*   @method cellCount
*   @return {int} The number of cells in this cellset.
*/
    cellCount: function() {
        return this._cellNodes.length;
    },
/**
*   Resets the internal cell pointer to the argument, or to 0 if the argument is omitted.
*   Normally, you shouldn't have to call this method yourself.
*   @method reset
*   @param idx {int}
*/
    reset: function(idx){
        this._idx = idx ? idx : 0;
        this._getCellNode();
    },
/**
*   Check if there are cells to iterate through.
*   @method hasMoreCells
*   @return {boolean} <code>true</code> if there are more cells to iterate, <code>false</code> if there are no more cells to iterate.
*/
    hasMoreCells: function(){
        return this._idx < this._cellCount;
    },
/**
*   Advance to the next (physical) cell.
*   Note that this method may appear to be skipping cells. This happens when the XML/A provider omits empty cells in the response.
*   @method nextCell
*   @return {int} returns the ordinal of the next cell, or -1 if there was no next cell.
*/
    nextCell: function(){
        this._idx += 1;
        if (this.hasMoreCells()) {
            this._getCellNode();
            return this._cellOrd;
        }
        else {
            this._idx = 0;
            return -1;
        }
    },
/**
*   Returns the internal cell pointer. This is the fysical cell pointer.
*   To get the logical cell pointer, see <code><a href="#method_cellOrdinal">cellOrdinal()</a></code>
*   @method curr
*   @return {int} returns the internal cell pointer.
*/
    curr: function(){
        return this._idx;
    },
/**
*   Check if the cell has the specified property.
*   XML/A defines these standard properties:<ul>
*     <li><code>Value</code></li>
*     <li><code>FmtValue</code></li>
*     <li><code>ForeColor</code></li>
*     <li><code>BackColor</code></li>
*   </ul>
*   Whether all these properties are returned depends on the XML/A provider and on the query.
*   The XML/A provider may return specific additional properties.
*   @method hasCellProperty
*   @param propertyName {string} The name of the property to check for.
*   @return {boolean} returns <code>true</code> if the current cell has the specified property, <code>false</code> if it doesn't.
*/
    hasCellProperty: function(propertyName) {
        return !_isUnd(this._cellProperties[propertyName]);
    },
/**
*   Return the value of the current property of the current cell.
*   XML/A defines these standard properties:<ul>
*     <li><code>Value</code></li>
*     <li><code>FmtValue</code></li>
*     <li><code>ForeColor</code></li>
*     <li><code>BackColor</code></li>
*   </ul>
*   Whether all these properties are returned depends on the XML/A provider and on the query.
*   The XML/A provider may return specific additional properties.
*   @method cellProperty
*   @param propertyName {string} The name of the property to retrieve.
*   @return {mixed} returns the value of the specified property of the current cell.
*/
    cellProperty: function(propertyName){
        var text, type, valueConverter,
            valueEl = _getElementsByTagNameNS(
              this._cellNode, _xmlnsDataset, "", propertyName
            ).item(0);
        text = _getElementValue(valueEl);
        valueConverter = this._cellProperties[propertyName];
        if (!valueConverter) {
            type = _getAttributeNS(
                valueEl,
                _xmlnsSchemaInstance,
                _xmlnsSchemaInstancePrefix,
                "type"
            );
            valueConverter = _getValueConverter(type);
        }
        return valueConverter(text);
    },
/**
*   Returns the cell ordinal. This is the logical cell pointer.
*   To get the physical cell pointer, see <code><a href="#method_curr">curr()</a></code>
*   @method cellOrdinal
*   @return {int} returns the logical cell pointer.
*/
    cellOrdinal: function() {
        return this._cellOrd;
    },
    fetchAsArrayOfValues: function(){
        var colArray = [];

        for (var c=0, cols=this._dataset.getAxis(Xmla.Dataset.AXIS_COLUMNS).numTuples;c<cols;c++){
            colArray[colArray.length] = this.cellValue();
            this.nextCell();
        }
        return colArray;
    },
    fetchAllAsArrayOfValues: function(){
        var row, rows=[];
        while((row = this.fetchAsArrayOfValues()) && (this.hasMoreCells())){
            rows.push(row);
        }
        return rows;
    },
    eachRow: function(rowCallback, scope, args){
        if (_isUnd(scope)) scope = this;
        var mArgs = [null];
        if (!_isUnd(args)) {
            if (!_isArr(args)) args = [args];
            mArgs = mArgs.concat(args);
        }
        var row, rows=[];
        while((row = this.fetchAsArrayOfValues()) && (this.hasMoreCells())){
            mArgs[0] = row;
            if (rowCallback.apply(scope, mArgs)===false) return false;
        }
        return true;
    },
    _readCell: function(node, object){
        var p, cellProp, cellProperty;
        for (p in this._cellProperties){
            cellProp = _getElementsByTagNameNS(
                node, _xmlnsDataset, "", p
            ).item(0);
            if (!cellProp) continue;
            cellProperty = this._cellProperties[p];
            if (cellProperty) object[p] = cellProperty(_getElementText(cellProp));
            else if (p === "Value") object[p] = _getElementValue(cellProp);
            else object[p] = _getElementText(cellProp);
        }
        object.ordinal = this._getCellOrdinal(node);
        return object;
    },
/**
 *  Reads the current cell into the specified object.
*   @method readCell
*   @param {object} object An existing object to use for the current cell. If omitted, a new object will be created.
*   @return {object} An object that represents the current cell.
*/
    readCell: function(object) {
        if (!object) object = {};
        return this._readCell(this._cellNode, object);
    },
/**
 *  Iterate through each cell.
*   @method eachCell
*   @param {function()} callback
*   @param {object} scope
*   @param {object} args
*   @return {boolean}
*/
    eachCell: function(callback, scope, args) {
        var mArgs = [null];
        if (!scope) scope = this;
        if (args) {
            if (!_isArr(args)) args = [args];
            mArgs = mArgs.concat(args);
        }
        while (this.hasMoreCells()){
            this.nextCell();
            mArgs[0] = this.readCell();
            if (callback.apply(scope, mArgs)===false) return false;
        }
        this._idx = 0;
        return true;
    },
/**
 *  Get a cell by its physical index.
*   @method getByIndex
*   @param {int} index
*   @param {object} object
*   @return {object}
*/
    getByIndex: function(index, object) {
        this._getCellNode(index);
        return this.readCell(object);
    },
/**
 *  Get a cell by its logical index.
*   @method getByOrdinal
*   @param {int} ordinal
*   @param {object} object
*   @return {object}
*/
    getByOrdinal: function(ordinal, object) {
        var node, ord, idx, lastIndex = this.cellCount() - 1;
        idx = ordinal > lastIndex ? lastIndex : ordinal;
        while(true) {
            node = this._cellNodes.item(idx);
            ord = this._getCellOrdinal(node);
            if (ord === ordinal) return this.getByIndex(idx, object);
            else
            if (ord > ordinal) idx--;
            else return null;
        }
    },
/**
 *  Calculate the ordinal based on the specified tuple indexes.
*   @method cellOrdinalForTupleIndexes
*   @param {int...} ordinal
*   @return {int}
*/
    cellOrdinalForTupleIndexes: function() {
        throw "Not implemented";
    },
/**
 *  Get the cell corresponding to the specified tuple indexes.
*   @method getByTupleIndexes
*   @param {int...} ordinal
*   @return {object}
*/
    getByTupleIndexes: function() {
        return this.getByOrdinal(this.cellOrdinalForTupleIndexes.apply(this, arguments));
    },
/**
 *  Close this cellset.
*   @method close
*/
    close: function(){
        this._dataset = null;
        this._cellNodes = null;
        this._cellNode = null;
    }
}


/**
*   <p>
*   This class is used to indicate an runtime errors occurring in any of the methods of the xmla4js classes.
*   </p>
*   <p>
*   You do not need to instantiate objects of this class yourself.
*   Rather, instances of this class are created and thrown at runtime whenever an error occurs.
*   The purpose is to provide a clean and clear way for applications that use xmla4js to recognize and handle Xmla4js specific runtime errors.
*   </p>
*   <p>
*   To handle Xmla4js errors, you can use a <code>try...catch</code> block like this:
*   </p>
<pre>
&nbsp;try {
&nbsp;    ...general xmla4js work...
&nbsp;} catch (exception) {
&nbsp;    if (exception instanceof Xmla.Exception) {
&nbsp;        ...use exception.code, exception.message and exception.data to handle the exception.
&nbsp;    } else {
&nbsp;        ...handle other errors...
&nbsp;    }
&nbsp;}
</pre>
*
*   @class Xmla.Exception
*   @constructor
*/
Xmla.Exception = function(type, code, message, helpfile, source, data, args){
    this.type = type;
    this.code = code;
    this.message = message;
    this.source = source;
    this.helpfile = helpfile;
    this.data = data;
    this.args = args;
    return this;
};

/**
*   Can appear as value for the <code><a href="#property_type">type</a></code> property of instances of the <code><a href="#class_Xmla.Exception">Xmla.Exception</a></code> class,
*   and indicates that this <code>Xmla.Exception</code> signals a warning.
*
*   @property TYPE_WARNING
*   @static
*   @final
*   @type string
*   @default <code>warning</code>
*/
Xmla.Exception.TYPE_WARNING = "warning";
/**
*   Can appear as value for the <code><a href="#property_type">type</a></code> property of instances of the <code><a href="#class_Xmla.Exception">Xmla.Exception</a></code> class,
*   and indicates that this <code>Xmla.Exception</code> signals an error.
*
*   @property TYPE_ERROR
*   @static
*   @final
*   @type string
*   @default <code>error</code>
*/
Xmla.Exception.TYPE_ERROR = "error";

var _exceptionHlp = "http://code.google.com/p/xmla4js/wiki/ExceptionCodes";

/**
*   Exception code indicating a <code>requestType</code> option was expected but ommitted.
*
*   @property MISSING_REQUEST_TYPE_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-1</code>
*/
Xmla.Exception.MISSING_REQUEST_TYPE_CDE = -1;
Xmla.Exception.MISSING_REQUEST_TYPE_MSG = "Missing_Request_Type";
Xmla.Exception.MISSING_REQUEST_TYPE_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.MISSING_REQUEST_TYPE_CDE +
                                    "_" + Xmla.Exception.MISSING_REQUEST_TYPE_MSG;
/**
*   Exception code indicating a <code>statement</code> option was expected but ommitted.
*
*   @property MISSING_STATEMENT_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-2</code>
*/
Xmla.Exception.MISSING_STATEMENT_CDE = -2;
Xmla.Exception.MISSING_STATEMENT_MSG = "Missing_Statement";
Xmla.Exception.MISSING_STATEMENT_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.MISSING_STATEMENT_CDE +
                                    "_" + Xmla.Exception.MISSING_STATEMENT_MSG;

/**
*   Exception code indicating a <code>url</code> option was expected but ommitted.
*
*   @property MISSING_URL_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-3</code>
*/
Xmla.Exception.MISSING_URL_CDE = -3;
Xmla.Exception.MISSING_URL_MSG = "Missing_URL";
Xmla.Exception.MISSING_URL_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.MISSING_URL_CDE +
                                    "_" + Xmla.Exception.MISSING_URL_MSG;

/**
*   Exception code indicating a <code>events</code> were expected but ommitted.
*
*   @property NO_EVENTS_SPECIFIED_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-4</code>
*/
Xmla.Exception.NO_EVENTS_SPECIFIED_CDE = -4;
Xmla.Exception.NO_EVENTS_SPECIFIED_MSG = "No_Events_Specified";
Xmla.Exception.NO_EVENTS_SPECIFIED_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.NO_EVENTS_SPECIFIED_CDE  +
                                    "_" + Xmla.Exception.NO_EVENTS_SPECIFIED_MSG;

/**
*   Exception code indicating a <code>events</code> were specifeid in the wrong format.
*
*   @property WRONG_EVENTS_FORMAT_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-5</code>
*/
Xmla.Exception.WRONG_EVENTS_FORMAT_CDE = -5;
Xmla.Exception.WRONG_EVENTS_FORMAT_MSG = "Wrong_Events_Format";
Xmla.Exception.WRONG_EVENTS_FORMAT_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.NO_EVENTS_SPECIFIED_CDE  +
                                    "_" + Xmla.Exception.NO_EVENTS_SPECIFIED_MSG;

/**
*   Exception code indicating that the event name was unrecognized.
*
*   @property UNKNOWN_EVENT_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-6</code>
*/
Xmla.Exception.UNKNOWN_EVENT_CDE = -6;
Xmla.Exception.UNKNOWN_EVENT_MSG = "Unknown_Event";
Xmla.Exception.UNKNOWN_EVENT_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.UNKNOWN_EVENT_CDE  +
                                    "_" + Xmla.Exception.UNKNOWN_EVENT_MSG;
/**
*   Exception code indicating that no proper handler was passed for the events.
*
*   @property INVALID_EVENT_HANDLER_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-7</code>
*/
Xmla.Exception.INVALID_EVENT_HANDLER_CDE = -7;
Xmla.Exception.INVALID_EVENT_HANDLER_MSG = "Invalid_Events_Handler";
Xmla.Exception.INVALID_EVENT_HANDLER_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.INVALID_EVENT_HANDLER_CDE  +
                                    "_" + Xmla.Exception.INVALID_EVENT_HANDLER_MSG;
/**
*   Exception code indicating that the rrepsonse could not be parsed
*
*   @property ERROR_PARSING_RESPONSE_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-8</code>
*/
Xmla.Exception.ERROR_PARSING_RESPONSE_CDE = -8;
Xmla.Exception.ERROR_PARSING_RESPONSE_MSG = "Error_Parsing_Response";
Xmla.Exception.ERROR_PARSING_RESPONSE_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.ERROR_PARSING_RESPONSE_CDE  +
                                    "_" + Xmla.Exception.ERROR_PARSING_RESPONSE_MSG ;
/**
*   Exception code indicating the field name is not valid.
*
*   @property INVALID_FIELD_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-9</code>
*/
Xmla.Exception.INVALID_FIELD_CDE = -9;
Xmla.Exception.INVALID_FIELD_MSG = "Invalid_Field";
Xmla.Exception.INVALID_FIELD_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.INVALID_FIELD_CDE  +
                                    "_" + Xmla.Exception.INVALID_FIELD_MSG;

/**
*   Exception code indicating a general XMLHttpRequest error.
*   If this error occurs, the data object of the exception will have these members:
*   <ul>
*       <li>request: the options that make up the original HTTP request</li>
*       <li>status: the HTTP status code</li>
*       <li>statusText: the HTTP status text</li>
*   </ul>
*   @property HTTP_ERROR_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-10</code>
*/
Xmla.Exception.HTTP_ERROR_CDE = -10;
Xmla.Exception.HTTP_ERROR_MSG = "HTTP Error";
Xmla.Exception.HTTP_ERROR_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.HTTP_ERROR_CDE  +
                                    "_" + Xmla.Exception.HTTP_ERROR_MSG;

/**
*   Exception code indicating the hierarchy name is not valid.
*
*   @property INVALID_HIERARCHY_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-11</code>
*/
Xmla.Exception.INVALID_HIERARCHY_CDE = -11;
Xmla.Exception.INVALID_HIERARCHY_MSG = "Invalid_Hierarchy";
Xmla.Exception.INVALID_HIERARCHY_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.INVALID_HIERARCHY_CDE  +
                                    "_" + Xmla.Exception.INVALID_HIERARCHY_MSG;

/**
*   Exception code indicating a problem reading a member property
*
*   @property UNEXPECTED_ERROR_READING_MEMBER_CDE
*   @static
*   @final
*   @type {int}
*   @default <code>-12</code>
*/
Xmla.Exception.UNEXPECTED_ERROR_READING_MEMBER_CDE = -12;
Xmla.Exception.UNEXPECTED_ERROR_READING_MEMBER_MSG = "Error_Reading_Member";
Xmla.Exception.UNEXPECTED_ERROR_READING_MEMBER_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.UNEXPECTED_ERROR_READING_MEMBER_CDE  +
                                    "_" + Xmla.Exception.UNEXPECTED_ERROR_READING_MEMBER_MSG;

/**
*   Exception code indicating the requested axis does not exist
*
*   @property INVALID_AXIS
*   @static
*   @final
*   @type {int}
*   @default <code>-13</code>
*/
Xmla.Exception.INVALID_AXIS_CDE = -13;
Xmla.Exception.INVALID_AXIS_MSG = "The requested axis does not exist.";
Xmla.Exception.INVALID_AXIS_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.INVALID_AXIS_CDE  +
                                    "_" + Xmla.Exception.INVALID_AXIS_MSG;

/**
*   Exception code indicating illegal number of axis arguments
*
*   @property ILLEGAL_ARGUMENT
*   @static
*   @final
*   @type {int}
*   @default <code>-14</code>
*/
Xmla.Exception.ILLEGAL_ARGUMENT_CDE = -14;
Xmla.Exception.ILLEGAL_ARGUMENT_MSG = "Illegal arguments";
Xmla.Exception.ILLEGAL_ARGUMENT_HLP = _exceptionHlp +
                                    "#" + Xmla.Exception.ILLEGAL_ARGUMENT_CDE  +
                                    "_" + Xmla.Exception.ILLEGAL_ARGUMENT_MSG;

Xmla.Exception._newError = function(codeName, source, data){
    return new Xmla.Exception(
        Xmla.Exception.TYPE_ERROR,
        Xmla.Exception[codeName + "_CDE"],
        Xmla.Exception[codeName + "_MSG"],
        Xmla.Exception[codeName + "_HLP"],
        source,
        data
    );
};

Xmla.Exception.prototype = {
/**
*   This propery indicates what kind of exception occurred. It can have one of the following values: <dl>
*       <dt><code><a href="property_TYPE_WARNING">TYPE_WARNING</a></code></dt><dd>Indicates a warning</dd>
*       <dt><code><a href="property_TYPE_ERROR">TYPE_ERROR</a></code></dt><dd>Indicates an error</dd>
*   </dl>
*   @property type
*   @type {string}
*   @default {null}
*/
    type: null,
/**
*   A code that can be used to identify this particular kind of exception.
*   @property code
*   @type {int}
*   @default {null}
*/
    code: null,
/**
*   A human readable message that describes the nature of the error or warning.
*   @property message
*   @type {string}
*   @default {null}
*/
    message: null,
/**
*   A name that indicates in what component (on the client or server side) this error or warning occurred.
*   @property source
*   @type {string}
*   @default {null}
*/
    source: null,
/**
*   A path or url that points to a document that contains more information about this error.
*   @property helpfile
*   @type {string}
*   @default {null}
*/
    helpfile: null,
/**
*   Additional data captured when the exception was instantiated.
*   The type of information stored here is dependent upon the nature of the error.
*   @property data
*   @type {string}
*   @default {null}
*/
    data: null,
    _throw: function(){
        throw this;
    },
/**
*   A reference to the built-in <code>arguments</code> array of the function that is throwing the exception
*   This can be used to get a "stack trace"
*   @property args
*   @type {array}
*/
    args: null,
/**
 *  Returns a string representing this exception
*   @method toString
*   @return a string representing this exception
*/
    toString: function(){
        return this.type + " " + this.code + ": " + this.message;
    },
/**
 *  Get a stack trace.
*   @method getStackTrace
*   @return an array of objects describing the function on the stack
*/
    getStackTrace: function(){
        var funcstring, stack = "", regexp = /^\sfunction\s*([^\(]+)?\s*\(\)$/;
        if (this.args) {
            var func = this.args.callee;
            while (func){
                funcstring = String(func);
                func = func.caller;
            }
        }
        return stack;
    }
};

}());
; /* ************************ new file ************************ */
/*
 * queryTypes.js
 *
 * Registers several query types and sets the base query class.
 * 
 * Additional query types can be registered at any time using the Dashboards method:
 *    Dashboards.registerQuery( name, query )
 * The second argument, the query definition, can be one of two things:
 *    1. An object, which will be used to extend the BaseQuery class, and the resulting class used
 *       to create new query instances.
 *    2. A class constructor function, which will be used directly to create new query instances
 *       without depending on BaseQuery.
 *
 * Additionally, the BaseQuery class can be set to something other than the default by using:
 *    Dashboards.setBaseQuery( constructor )
 * but this is a risky operation which considerable implications. Use at your own risk!
 *
 */
;
(function() {

    var BaseQuery = Base.extend({
        name: "baseQuery",
        label: "Base Query",
        deepProperties: [ 'defaults' , 'interfaces' ],
        defaults: {
            successCallback: function(){ 
                Dashboards.log('Query callback not defined. Override.');
            },
            errorCallback: Dashboards.handleServerError,
            lastResultSet: null,
            page: 0,
            pageSize: 0,
            params: {},
            ajaxOptions: {
                async: false,
                type:'POST'
            },
            url: ''
        },
        interfaces:{
            params: { reader:'propertiesObject', validator:'isObjectOrPropertiesArray'},
            successCallback: { validator:'isFunction'},
            errorCallback: { validator:'isFunction'},
            pageSize: { validator:'isPositive'}

        },
        constructor: function (config ){
            if ( Dashboards && Dashboards.OptionsManager ) {
                this._optionsManager = new Dashboards.OptionsManager( this );
                this._optionsManager.mixin( this );
            }
            this.init(config);
        },
        // Default options interface in case there is no options manager defined.
        getOption: function (prop){
            // Fallback for when Dashboards.OptionManager is not available
            return this.defaults[prop];
        },
        setOption: function (prop, value){
            // Fallback for when Dashboards.OptionManager is not available
            this.defaults[prop] = value;
        },
        init: function (opts){
            // Override
        },
        getSuccessHandler: function (callback){
            var myself = this;
            return function(json) {
                myself.setOption('lastResultSet' , json );
                var clone = $.extend(true,{}, myself.getOption('lastResultSet') );
                callback(clone);
            }
        },
        getErrorHandler: function (callback){
            return function(resp, txtStatus, error ) {      
                if (callback){
                    callback(resp, txtStatus, error );
                }
            }
        },
        doQuery: function(outsideCallback){
            if (typeof this.getOption('successCallback') != 'function') {
                throw 'QueryNotInitialized';
            }
            var url = this.getOption('url'),
                    callback = (outsideCallback ? outsideCallback : this.getOption('successCallback')),
                    errorCallback = this.getOption('errorCallback') ,
                    queryDefinition = this.buildQueryDefinition();

            var settings = _.extend({}, this.getOption('ajaxOptions'), {
                data: queryDefinition,
                url: url,
                success: this.getSuccessHandler(callback),
                error: this.getErrorHandler(errorCallback) 
            });
            
            $.ajax(settings);
        },
        exportData: function() {
            // Override 
        },
        setAjaxOptions: function(newOptions) {
                this.setOption( 'ajaxOptions' , _.extend({}, this.getOption('ajaxOptions') , newOptions) );
        },
        setSortBy: function(sortBy) {
            // Override 
        },
        sortBy: function(sortBy,outsideCallback) {
            // Override 
        },
        fetchData: function(params, successCallback, errorCallback) {
            switch(arguments.length) {
                case 0:
                    if( this.getOption('params') &&  this.getOption('successCallback') ) {
                        return this.doQuery();
                    }
                break;
                case 1:
                    if (typeof arguments[0] == "function"){
                        /* If we're receiving _only_ the callback, we're not
                        * going to change the internal callback
                        */
                        return this.doQuery(arguments[0]);
                    } else if(  !_.isEmpty(arguments[0]) && 
                            (_.isObject(arguments[0]) || _.isArray(arguments[0]) ) ) {
                        this.setOption('params' , arguments[0] || {} );
                        return this.doQuery();
                    }
                    break;
                case 2:
                    if (typeof arguments[0] == "function"){
                        this.setOption( 'successCallback' , arguments[0] );
                        this.setOption('errorCallback'  , arguments[1] );
                        return this.doQuery();
                    } else {
                        this.setOption('params' , arguments[0] || {} );
                        this.setOption('successCallback' , arguments[1] );
                        return this.doQuery();
                    }
                    break;
                default:
                    /* We're just going to discard anything over two params */
                    this.setOption('params' , params );
                    this.setOption('successCallback' , successCallback );
                    this.setOption('errorCallback' , errorCallback );
                    return this.doQuery();
            }
            /* If we haven't hit a return by this time,
             * the user gave us some wrong input
             */
            throw "InvalidInput";
        },

        // Result caching
        lastResults: function(){
            if ( this.getOption('lastResultSet') !== null) {
                return $.extend(true,{}, this.getOption('lastResultSet') );
            } else {
                throw "NoCachedResults";
            }
        },
        reprocessLastResults: function(outerCallback){
            if ( this.getOption('lastResultSet') !== null) {
                var clone = $.extend(true,{}, this.getOption('lastResultSet') );
                var callback = outerCallback || this.getOption('successCallback') ;
                return callback(clone);
            } else {
                throw "NoCachedResults";
            }
        },
        reprocessResults: function(outsideCallback) {
            if ( this.getOption('lastResultSet') !== null) {
                var clone = $.extend(true,{}, this.getOption('lastResultSet') );
                var callback = (outsideCallback ? outsideCallback : this.getOption('successCallback'));
                callback( clone );
            } else {
                throw "NoCachedResults";
            }
        },
        setParameters: function (params) {
            this.setOption('params', params);
        },
        setCallback: function(callback) {
            this.setOption('successCallback' , callback);
        },
        setErrorCallback: function(callback) {
            this.setOption('errorCallback', callback);
        },
        setSearchPattern: function (pattern){
            this.setOption('searchPattern', pattern);
        },

        /* Pagination
         *
         * We paginate by having an initial position ( page ) and page size ( pageSize )
         * Paginating consists of incrementing/decrementing the initial position by
         * the page size. All paging operations change the paging cursor.
         */

        // Gets the next _pageSize results
        nextPage: function(outsideCallback) {
            var page = this.getOption('page'),
                    pageSize = this.getOption('pageSize');
            if ( pageSize > 0) {
                page += pageSize;
                this.setOption('page' , page );
                return this.doQuery(outsideCallback);
            } else {
                throw "InvalidPageSize";
            }
        },
        // Gets the previous _pageSize results
        previousPage: function(outsideCallback) {
            var page = this.getOption('page'),
                    pageSize = this.getOption('pageSize');
            if (page > pageSize) {
                page -= pageSize;
                this.setOption('page' , page );
                return this.doQuery(outsideCallback);
            } else if (_pageSize > 0) {
                this.setOption('page' , 0 );
                return this.doQuery(outsideCallback);
            } else {
                throw "AtBeggining";
            }
        },
        // Gets the page-th set of _pageSize results (0-indexed)
        getPage: function( targetPage, outsideCallback) {
            var page = this.getOption('page'),
                    pageSize = this.getOption('pageSize');
            if (targetPage * pageSize == page) {
                return false;
            } else if (typeof targetPage == 'number' && targetPage >= 0) {
                this.setOption('page' , targetPage * pageSize );
                return this.doQuery(outsideCallback);
            } else {
                throw "InvalidPage";
            }
        },

        // Gets pageSize results starting at page
        setPageStartingAt: function(targetPage) {
            if (targetPage == this.getOption('page')) {
                return false;
            } else if (typeof targetPage == 'number' && targetPage >= 0) {
                this.setOption('page' , targetPage );
            } else {
                throw "InvalidPage";
            }
        },

        pageStartingAt: function(page,outsideCallback) {
            if(this.setPageStartingAt(page) !== false) {
                return this.doQuery(outsideCallback);
            } else {
                return false;
            }
        },

        // Sets the page size
        setPageSize: function(pageSize) {
            this.setOption('pageSize', pageSize);
        },

        // sets _pageSize to pageSize, and gets the first page of results
        initPage: function(pageSize,outsideCallback) {
            if (pageSize == this.getOption('pageSize') && this.getOption('page') == 0) {
                return false;
            } else if (typeof pageSize == 'number' && pageSize > 0) {
                this.setOption('page' , 0 );
                this.setOption('pageSize' , pageSize );
                return this.doQuery(outsideCallback);
            } else {
                throw "InvalidPageSize";
            }
        }
    });
    // Sets the query class that can extended to create new ones. 
    // The registered Base needs to have an extend method.
    Dashboards.setBaseQuery ( BaseQuery );


    var CpkEndpoints = BaseQuery.extend({
        name: "cpk",
        label: "CPK",
        defaults: {
            baseUrl:  Dashboards.getWebAppPath() + '/content',
            pluginId: '',
            endpoint: '',
            systemParams: {},
            ajaxOptions: {
                dataType:'json',
                type:'POST',
                async: true
            }
        },

        init: function (opts){
                if ( _.isString(opts.pluginId) && _.isString(opts.endpoint) ){
                    this.setOption('pluginId' , opts.pluginId);
                    this.setOption('endpoint' , opts.endpoint);
                    var urlArray = [ this.getOption('baseUrl') , this.getOption('pluginId') , this.getOption('endpoint') ],
                            url = urlArray.join('/');
                    this.setOption('url', url );
                }
        },

        buildQueryDefinition: function(overrides) {
            overrides = ( overrides instanceof Array) ? Dashboards.propertiesArrayToObject(overrides) : ( overrides || {} );
            var queryDefinition = this.getOption('systemParams');
            
            var cachedParams = this.getOption('params'),
                    params = $.extend( {}, cachedParams , overrides);

            _.each( params , function (value, name) {
                value = Dashboards.getParameterValue(value);
                if($.isArray(value) && value.length == 1 && ('' + value[0]).indexOf(';') >= 0){
                    //special case where single element will wrongly be treated as a parseable array by cda
                    value = doCsvQuoting(value[0],';');
                }
                //else will not be correctly handled for functions that return arrays
                if (typeof value == 'function') {
                    value = value();
                }
                queryDefinition['param' + name] = value;
            });

            return queryDefinition;
        }

        /*
         * Public interface
         */
    });
    // Registering a class will use that class directly when getting new queries.
    Dashboards.registerQuery( "cpk", CpkEndpoints );


    var cdaQueryOpts = {
        name: 'cda',
        label: 'CDA Query',
        defaults: {
            url: Dashboards.getWebAppPath() + "/content/cda/doQuery?",
            file: '',
            id: '',
            outputIdx: '1',
            sortBy: '',
            ajaxOptions: { },
            searchPattern: ''
        },

        init: function (opts){
            if (typeof opts.path != 'undefined' && typeof opts.dataAccessId != 'undefined'){
                // CDA-style cd object
                this.setOption('file' , opts.path );
                this.setOption( 'id' , opts.dataAccessId );
                if (typeof opts.sortBy == 'string' && opts.sortBy.match("^(?:[0-9]+[adAD]?,?)*$")) {
                    this.setOption('sortBy', opts.sortBy);
                }
                if(opts.pageSize != null){
                    this.setOption('pageSize' , opts.pageSize);
                }
                if(opts.outputIndexId != null){
                    this.setOption( 'outputIdx' , opts.outputIndexId );
                }     
                } else {
                    throw 'InvalidQuery';
                }
        },

        buildQueryDefinition: function(overrides) {
            overrides = ( overrides instanceof Array) ? Dashboards.propertiesArrayToObject(overrides) : ( overrides || {} );
            var queryDefinition = {};
            
            var cachedParams = this.getOption('params'),
                    params = $.extend( {}, cachedParams , overrides);

            _.each( params , function (value, name) {
                value = Dashboards.getParameterValue(value);
                if($.isArray(value) && value.length == 1 && ('' + value[0]).indexOf(';') >= 0){
                    //special case where single element will wrongly be treated as a parseable array by cda
                    value = doCsvQuoting(value[0],';');
                }
                //else will not be correctly handled for functions that return arrays
                if (typeof value == 'function') {
                    value = value();
                }
                queryDefinition['param' + name] = value;
            });
            queryDefinition.path = this.getOption('file');
            queryDefinition.dataAccessId = this.getOption('id');
            queryDefinition.outputIndexId = this.getOption('outputIdx');
            queryDefinition.pageSize = this.getOption('pageSize');
            queryDefinition.pageStart = this.getOption('page');
            queryDefinition.sortBy = this.getOption('sortBy');
            queryDefinition.paramsearchBox = this.getOption('searchPattern');
            return queryDefinition;
        },

        /*
         * Public interface
         */

        exportData: function(outputType, overrides, options) {
            if (!options) {
                options = {};
            }
            var queryDefinition = this.buildQueryDefinition(overrides);
            queryDefinition.outputType = outputType;
            if (outputType == 'csv' && options.separator) {
                queryDefinition.settingcsvSeparator = options.separator;
            }
            if (options.filename) {
                queryDefinition.settingattachmentName= options.filename ;
            }
            if (outputType == 'xls' && options.template) {
                queryDefinition.settingtemplateName= options.template ;
            }
            if( options.columnHeaders ){
                queryDefinition.settingcolumnHeaders = options.columnHeaders;
            }

            if(options.dtFilter != null){
                queryDefinition.settingdtFilter = options.dtFilter;
                if(options.dtSearchableColumns != null){
                    queryDefinition.settingdtSearchableColumns = options.dtSearchableColumns;
                }
            }
            queryDefinition.wrapItUp = 'wrapit';
            
            var successCallback = function(uuid) {
                var _exportIframe = $('<iframe style="display:none">');
                _exportIframe.detach();
                //_exportIframe[0].src = webAppPath + 'content/cda/unwrapQuery?' + $.param( {"path": queryDefinition.path, "uuid": uuid});
                _exportIframe[0].src = '/pentaho/content/cda/unwrapQuery?' + $.param( {"path": queryDefinition.path, "uuid": uuid});
                _exportIframe.appendTo($('body'));
            };
            $.ajax({
                type:'POST',
                async: false,
                data: queryDefinition,
                url: this.getOption('url'),
                success: successCallback
            });
        },

        /* Sorting
         *
         * CDA expects an array of terms consisting of a number and a letter
         * that's either 'A' or 'D'. Each term denotes, in order, a column
         * number and sort direction: 0A would then be sorting the first column
         * ascending, and 1D would sort the second column in descending order.
         * This function accepts either an array with the search terms, or
         * a comma-separated string with the terms:  "0A,1D" would then mean
         * the same as the array ["0A","1D"], which would sort the results
         * first by the first column (ascending), and then by the second
         * column (descending).
         */
        setSortBy: function(sortBy) {
            var newSort,
                    myself = this;
            if (sortBy === null || sortBy === undefined || sortBy === '') {
                newSort = '';
            }
            /* If we have a string as input, we need to split it into
             * an array of sort terms. Also, independently of the parameter
             * type, we need to convert everything to upper case, since want
             * to accept 'a' and 'd' even though CDA demands capitals.
             */
            else if (typeof sortBy == "string") {
                /* Valid sortBy Strings are column numbers, optionally
                 * succeeded by A or D (ascending or descending), and separated by commas
                 */
                if (!sortBy.match("^(?:[0-9]+[adAD]?,?)*$")) {
                    throw "InvalidSortExpression";
                }
                /* Break the string into its constituent terms, filter out empty terms, if any */
                newSort = sortBy.toUpperCase().split(',').filter(function(e){
                    return e !== "";
                });
            } else if (sortBy instanceof Array) {
                newSort = sortBy.map(function(d){
                    return d.toUpperCase();
                });
                /* We also need to validate that each individual term is valid */
                var invalidEntries = newSort.filter(function(e){
                    return !e.match("^[0-9]+[adAD]?,?$")
                });
                if ( invalidEntries.length > 0) {
                    throw "InvalidSortExpression";
                }
            }
                
            /* We check whether the parameter is the same as before,
             * and notify the caller on whether it changed
             */
            var same;
            if (newSort instanceof Array) {
                same = newSort.length != myself.getOption('sortBy').length;
                $.each(newSort,function(i,d){
                    same = (same && d == myself.getOption('sortBy')[i]);
                    if(!same) {
                        return false;
                    }
                });
            } else {
                same = (newSort === this.getOption('sortBy'));
            }
            this.setOption('sortBy' , newSort);
            return !same;
        },

        sortBy: function(sortBy,outsideCallback) {
            /* If the parameter is not the same, and we have a valid state,
             * we can fire the query.
             */
            var changed = this.setSortBy(sortBy);
            if (!changed) {
                return false;
            } else if ( this.getOption('successCallback') !== null) {
                return this.doQuery(outsideCallback);
            }
        }
    };
    // Registering an object will use it to create a class by extending Dashboards.BaseQuery, 
    // and use that class to generate new queries.
    Dashboards.registerQuery( "cda", cdaQueryOpts );




    function makeMetadataElement (idx, name, type){
        return { "colIndex" : idx || 0, "colType" : type || "String" , "colName" : name || "Name" }
    }

    var legacyOpts = {
        name: "legacy",
        label: "Legacy",
        defaults: {
            url: webAppPath + "/ViewAction?solution=system&path=pentaho-cdf/actions&action=jtable.xaction",
            queryDef:{}
        },
        interfaces:{
            lastResultSet:{
                reader: function (json){
                    json = eval("(" + json + ")");
                    var result = { metadata: [ makeMetadataElement(0)] , resultset:json.values || [] };
                    _.each( json.metadata , function (el, idx){
                        return result.metadata.push( makeMetadataElement(idx+1, el) );
                    });
                    return result
                }
            }
        },

        init: function (opts){
            this.setOption('queryDef', opts);
        },

        getSuccessHandler: function (callback){
            var myself = this;
            return function(json) {
                try{
                    myself.setOption('lastResultSet' , json );
                }catch(e){
                    if(this.async){
                        // async + legacy errors while parsing json response aren't caught
                        var msg = Dashboards.getErrorObj('COMPONENT_ERROR').msg + ":" + e.message;
                        Dashboards.error(msg);
                        json = {"metadata":[msg],"values":[]};
                    }else{
                        //exceptions while parsing json response are 
                        //already being caught+handled in updateLifecyle()  
                        throw e;
                    }  
                }
                var clone = $.extend(true,{}, myself.getOption('lastResultSet') );
                callback(clone);
            }
        },

        //TODO: is this enough?
        buildQueryDefinition: function(overrides) {
            return _.extend({}, this.getOption('queryDef'), overrides);
        }

    };
    Dashboards.registerQuery( "legacy", legacyOpts );
    
    // TODO: Temporary until CDE knows how to write queryTypes definitions, with all these old queries 
    // falling under the 'legacy' umbrella.
    Dashboards.registerQuery( "mdx", legacyOpts );
    Dashboards.registerQuery( "sql", legacyOpts );
})();

; /* ************************ new file ************************ */
/*
 Purpose: Provide extensible datasources via Dashboard Addins
 Author: Andy Grohe
 Contact: agrohe21@gmail.com
*/

(function() {

    SharedXmla = Base.extend({
        xmla: null,
        datasource: null, //cache the datasource as there should be only one xmla server
        catalogs: null,

        getDataSources: function(){
            var datasourceCache = [],
                rowset_ds = this.xmla.discoverDataSources();
            if (rowset_ds.hasMoreRows()) {
                datasourceCache = rowset_ds.fetchAllAsObject();
                this.datasource = datasourceCache[0];
                rowset_ds.close();
                return;
            }
        },
        getCatalogs: function(){
                var properties = {};
                this.catalogs = [], catalog = {};
                properties[Xmla.PROP_DATASOURCEINFO] = this.datasource[Xmla.PROP_DATASOURCEINFO];
                var rowset_cat = this.xmla.discoverDBCatalogs({
                        properties: properties
                });
                if (rowset_cat.hasMoreRows()) {
                        while (catalog = rowset_cat.fetchAsObject()){
                            this.catalogs[this.catalogs.length] = catalog;
                        }
                        rowset_cat.close();
                }
        },
        discover: function(param){
                var properties = {}, rows =[], restrictions={}, qry=param.query(); //user must pass in valid XMLA requestTypes
                properties[Xmla.PROP_DATASOURCEINFO] = this.datasource[Xmla.PROP_DATASOURCEINFO];
                if (param.catalog) {
                    properties[Xmla.PROP_CATALOG] = param.catalog;
                }
                var rowset_discover = this.xmla.discover({properties:properties, requestType:qry});
                return rowset_discover;
        },
        execute: function(param){
            //find the requested catalog in internal array of valid catalogs
            for (var i=0,j=_sharedXmla.catalogs.length;i<j;i++){
                if (_sharedXmla.catalogs[i]["CATALOG_NAME"] == param.catalog ){
                    var properties = {};
                    properties[Xmla.PROP_DATASOURCEINFO] = _sharedXmla.datasource[Xmla.PROP_DATASOURCEINFO];
                    properties[Xmla.PROP_CATALOG]        = param.catalog;
                    properties[Xmla.PROP_FORMAT]         = _sharedXmla.PROP_FORMAT_TABULAR;//Xmla.PROP_FORMAT_MULTIDIMENSIONAL;
                    var result = this.xmla.execute({
                            statement: param.query(),
                            properties: properties
                    });
                    return result;
                }
            }
            //should never make it here if param.catalog is on server
            throw new Error("Catalog: " + param.catalog + " was not found on Pentaho server.");
        }
    });

    
    var _sharedXmla = new SharedXmla();
    var _scriptName = 'Xmla.js';
    var _isScriptLoaded = false;
    var _scriptLocation = Dashboards.getWebAppPath() + '/content/pentaho-cdf/js/queries/';


    function loadXmlaScript (){
        if (!_isScriptLoaded){
            $.ajax({
                url: _scriptLocation + _scriptName,
                dataType: "script",
                success: function (){
                    _isScriptLoaded = true;
                },
                async: false
            });
        }
    }


    /*
        XMLA Query
        requires queryType="xmla" in chartDefintion of CDF object
    */
    var xmlaOpts = {
        name: "xmla",
        label: "XMLA",
        defaults: {
            url: Dashboards.getWebAppPath() + "/Xmla" //defaults to Pentaho's Mondrian servlet. can be overridden in options
        },
        init: function(){
            loadXmlaScript();
            if (_sharedXmla.xmla == null) {
                _sharedXmla.xmla = new Xmla({
                                async: false,
                                url: this.getOption('url')
                });
            }
            if (_sharedXmla.datasource == null) {
                _sharedXmla.getDataSources();
            }
            if (_sharedXmla.catalogs == null) {
                _sharedXmla.getCatalogs();
            }
        },
        transformXMLAresults: function(results){
            var rows = results.fetchAllAsArray(),
                cols = results.getFields(), col,
                res={resultset:[], metadata:[]};

            //build metadata object for each column
            for (var i=0,j=cols.length;i<j;i++){
                col = cols[i];
                res.metadata[i] = {
                    colIndex:col.index,
                    colName:col.label
                }
                switch (col.jsType){
                    case "string":
                        res.metadata[i].colType = "string";
                        break;
                    case "number":
                        res.metadata[i].colType = "numeric";
                        break;
                    //TODO addin DateTime boolean or anything else
                    default:
                        res.metadata[i].colType = "string";
                }
            }
            //build resultset object
            res.resultset = rows; //just use array of rows as it comes back from xmla.fetchAllAsArray
            results.close(); //clear up memory
            //TODO SafeClone?
            return res;
        },

        doQuery: function(outsideCallback){
            var url = this.getOption('url'),
                    callback = (outsideCallback ? outsideCallback : this.getOption('successCallback')),
                    errorCallback = this.getOption('errorCallback'),
                    params = this.getOption('params');

            try {      
                var result = _sharedXmla.execute(params);
            } catch (e) {
                Dashboards.log('unable to execute xmla addin query: ' +e+' :', 'error')
            }
            callback(this.transformXMLAresults(result));
        
        }

    };
    Dashboards.registerQuery("xmla", xmlaOpts );




    /*
        XMLA Metadata Query
        requires queryType="xmla_discover" in chartDefintion of CDF object
    */
 var xmlaDiscoverOpts = {
        name: "xmlaDiscover",
        label: "XMLA Discover",
        defaults: {
            url: Dashboards.getWebAppPath() + "/Xmla" //defaults to Pentaho's Mondrian servlet. can be overridden in options
        },
        init: function(){
            loadXmlaScript();
            if (_sharedXmla.xmla == null) { //lazily load object when needed only
                _sharedXmla.xmla = new Xmla({
                                async: false,
                                url: this.getOption('url')
                });
            }
            if (_sharedXmla.datasource == null){
                _sharedXmla.getDataSources(); //another lazy load
            }
        },
        transformDiscoverresults: function(results){ //format results into standard format with metadata and resultset.
            var 
                cols = results.getFields(), col,
                res={resultset:[], metadata:[]};

            //build metadata object for each column
            for (var i=0,j=cols.length;i<j;i++){
                col = cols[i];
                res.metadata[i] = {
                    colIndex:col.index,
                    colName:col.label
                }
                switch (col.jsType){
                    case "string":
                        res.metadata[i].colType = "string";
                        break;
                    case "number":
                        res.metadata[i].colType = "numeric";
                        break;
                    //TODO addin DateTime boolean or anything else
                    default:
                        res.metadata[i].colType = "string";
                }
            }
            //build resultset object
            res.resultset = results.fetchAllAsArray(); //just use array of rows as it comes back from xmla.fetchAllAsObject
            results.close(); //clear up memory
            //TODO SafeClone?
            return res;
        },
        doQuery: function(outsideCallback){
            var url = this.getOption('url'),
                    callback = (outsideCallback ? outsideCallback : this.getOption('successCallback')),
                    errorCallback = this.getOption('errorCallback'),
                    params = this.getOption('params');

            try {      
                var result = _sharedXmla.discover(params);
            } catch (e) {
                Dashboards.log('unable to execute xmla addin query: ' +e+' :', 'error')
            }
            callback(this.transformDiscoverresults(result));
        }
    };
    Dashboards.registerQuery("xmlaDiscover", xmlaDiscoverOpts);


})();
; /* ************************ new file ************************ */
/******************************************************************************************************/
/**************************************** OLAP UTILS**************************************************/
/******************************************************************************************************/


var OlapUtils= {};

var OlapUtils = {

    mdxGroups: {},
    evolutionType: "Week"
}
    
OlapUtils.initMdxQueryGroup = function(obj){

    var mdxQueryGroup = new OlapUtils.mdxQueryGroup(obj.name);

    for(m in obj.mdxQueries){

        mdxQueryGroup.addMdxQuery( 
            obj.mdxQueries[m].name,
            obj.mdxQueries[m].query,
            obj.mdxQueries[m].dimension,
            obj.mdxQueries[m].axis,   
            obj.mdxQueries[m].chart
        );
    }

    OlapUtils.mdxGroups[obj.name] = mdxQueryGroup;

    if(("#" + obj.htmlObject + "_evolutionType")  != undefined)
        $("#" + obj.htmlObject+ "_evolutionType").html(mdxQueryGroup.printEvolutionType(obj.htmlObject + "_evolutionType"));

    return mdxQueryGroup;
}


OlapUtils.updateMdxQueryGroup = function(obj){

    var mdxGroup = OlapUtils.mdxGroups[obj.name];
    if (mdxGroup == undefined){
        mdxGroup = OlapUtils.initMdxQueryGroup(obj);
    }

    $("#" + obj.htmlObject).html(mdxGroup.printConditions());

}

OlapUtils.buttonsDescription = {
    "Drill Down": 'Drill down to the selected value and add the condition to the other charts',
    "Drill Up": 'Drill up and add the condition to the other charts',
    'Focus': "Focus on this value, adding the conditions to the other charts", 
    'Exclude': "Exclude this value from the chart",
    "Expand":'Expand the depth of the chart, showing an extra sublevel',
    "Collapse":'Collapse all previous expansions to the top most level',
    "Reset All": 'Reset all filters and conditions from this chart group, returning to the original conditions',
    "Cancel": "Cancel" 
}


OlapUtils.fireMdxGroupAction = function(mdxQueryGroup,idx,param1, param2, param3){

    /**         http://jira.pentaho.com/browse/BISERVER-3542       *
     *                                 *
     * Prior to Pentaho 3.5, this function received only 3 parameters: *
     *(query,idx,PARAM).                           *
     * In Pentaho 3.5, the behavior of the x/y and TimeSeries Charts   *
     *changed, and this function passed to receive 5 parameters:
     *(query,idx,chartDefinition,PARAM,SERIES).            *
     * When chartType == AreaChart, the value used to drill through is *
     *SERIES, otherwise it's PARAM.                    */

    if(param2 != undefined && param3 != undefined){
      cType = Dashboards.ev(param1.chartType);

        if(cType == "AreaChart")
          value = encode_prepare(param3);
        else 
          value = encode_prepare(param2);
    }
    else
      value = encode_prepare(param1);


    var mdxQueryGroup = OlapUtils.mdxGroups[mdxQueryGroup];
    if (value == 'Others')
        return; // do nothing

    OlapUtils.lastClickedMdxQueryGroup = mdxQueryGroup;
    mdxQueryGroup.clickedIdx = idx;
    mdxQueryGroup.clickedValue = value;

    var clickedObj = mdxQueryGroup.mdxQueries[idx];

    var buttonsHash = { 
        "Drill Down": 'drilldown',
        "Drill Up": 'drillup',
        'Focus': "focus", 
        'Exclude': "filter",
        "Expand":'expand',
        "Collapse":'collapse',
        "Reset All": 'resetall',
        "Cancel": "cancel" 
    };
    
    if (clickedObj.mdxQuery.axisDepth == 0)
        delete buttonsHash.Collapse;

    //get rowLevels
    var rl = clickedObj.mdxQuery.query.rowLevels;
    var d = typeof rl == "function"?rl():rl;

    if (clickedObj.mdxQuery.axisPos + clickedObj.mdxQuery.axisDepth >= d.length - 1){
        delete buttonsHash["Drill Down"];
        delete buttonsHash.Expand;
    }
    else{
        delete buttonsHash.Focus;
    }
    
    if(clickedObj.mdxQuery.axisPos == 0)
        delete buttonsHash["Drill Up"];

    // Expanded ones can't drill || focus
    if (clickedObj.mdxQuery.axisDepth > 0){
        delete buttonsHash["Drill Down"];
        delete buttonsHash.Focus;
        delete buttonsHash.Exclude;
    }


    var msg = "Available conditions: <br/> <ul>" ;
    $.each(buttonsHash, function(key,value){msg+="<li>" + OlapUtils.buttonsDescription[key] + "</li>"});
    msg += "</ul>";
    $.prompt(msg
        ,{buttons: buttonsHash, callback: OlapUtils.mdxQueryGroupActionCallback }
    );

}

    
/******************************************************************************************************/
/***************************************** MDX QUERY ************************************************/
/******************************************************************************************************/


OlapUtils.mdxQuery = function(hash){
    this.query = {};
    this.originalHash = {};
    this.update(hash);
    this.axisPos = 0;
    this.axisDepth = 0;
};

OlapUtils.mdxQuery.prototype.reset = function(){
    this.update(this.originalHash); 
};

OlapUtils.mdxQuery.prototype.resetFilter = function(value){
    var rf = this.query["filters"]["rows"];
    var index = rf.indexOf(value);
    rf.splice(index,1);
    return index;
}

OlapUtils.mdxQuery.prototype.resetFilters = function(){
    this.query["filters"] = Dashboards.clone((this.originalHash["filters"] || {rows:[],columns: []}));
}

OlapUtils.mdxQuery.prototype.resetCondition = function(key){
    delete this.query["members"][key];
    delete this.query["sets"][key];
    if(this.query["conditions"][key+"InitialValue"] != undefined)
        this.query["where"][key] = this.query["conditions"][key+"InitialValue"];
    else
        delete this.query["where"][key];
}


OlapUtils.mdxQuery.prototype.update = function(hash){

    this.originalHash = Dashboards.clone(hash);
    this.query["members"] = hash["members"]||[];
    this.query["sets"] = hash["sets"] || [];
    this.query["rows"] = hash["rows"]||"";
    this.query["rowDrill"] = hash["rowDrill"]||false;
    this.query["rowLevels"] = hash["rowLevels"]||[];
    this.query["orderBy"] = hash["orderBy"] || "";
    this.query["from"] = hash["from"] || "";
    this.query["columns"] = hash["columns"];
    this.query["columnDrill"] = hash["columnDrill"]||false;
    this.query["columnLevels"] = hash["columnLevels"]||[];
    this.query["nonEmptyRows"] = hash["nonEmptyRows"] && true;
    this.query["nonEmptyColumns"] = hash["nonEmptyColumns"] && true;
    this.query["swapRowsAndColumns"] = hash["swapRowsAndColumns"] || false;
    this.query["filters"] = hash["filters"] || {rows:[],columns: []};
    this.query["where"] = hash["where"] || {};
    this.query["extra"] = hash["extra"] || {};
    this.query["conditions"] = [];
    this.query["drills"] = [];
};


OlapUtils.mdxQuery.prototype.clone = function() {
    var c = Dashboards.clone(this);
    return c;
};


OlapUtils.mdxQuery.prototype.generateAxisPart = function(axisDrill, axis, axisLevels, orderBy){
    if (axisDrill == false){
        return axis;
    }

    //var dim = axis.indexOf(".") == -1?axis:axis.substr(0,axis.indexOf("."));
    var dim = axis.indexOf("].") == -1?axis:axis.substr(0,axis.indexOf("].")+1);
    var axisLevel = this.axisPos + this.axisDepth;
    if (axisLevel > axisLevels.length - 1){
        axisLevel = axisLevels.length - 1
    }
    var q = "Descendants("  + axis + ", "+ dim + ".["  + axisLevels[axisLevel] + "],SELF)"
    if (orderBy == "")
        return q;

    return "Order(" + q + ", " + orderBy + " , BDESC)";

}


OlapUtils.mdxQuery.prototype.getQuery = function(){
    var query = "with ";
    // We need to evaluate the hash
    var _eh = [];
    for(p in this.query){
        var key = p;
        var value = typeof this.query[p]=='function'?this.query[p]():this.query[p];
        _eh[key] = value;
    } 

    if(typeof _eh["sets"] == 'object' || typeof _eh["members"] == 'object' ){
        for(s in _eh["sets"]){
            var value = typeof _eh["sets"][s]=='function'?_eh["sets"][s]():_eh["sets"][s];
            query += " set " + value + " \n";
        }
        for(m in _eh["members"]){
            var value = typeof _eh["members"][m]=='function'?_eh["members"][m]():_eh["members"][m];
            query += " member " + value + " \n";
        }
    }
    // Generate the col/row sets
    var columns = _eh["swapRowsAndColumns"]?_eh["rows"]:_eh["columns"];
    var columnLevels = _eh["swapRowsAndColumns"]?_eh["rowLevels"]:_eh["columnLevels"];
    var columnDrill = _eh["swapRowsAndColumns"]?_eh["rowDrill"]:_eh["columnDrill"];
    var rows = _eh["swapRowsAndColumns"]?_eh["columns"]:_eh["rows"];
    var rowLevels = _eh["swapRowsAndColumns"]?_eh["columnLevels"]:_eh["rowLevels"];
    var rowDrill = _eh["swapRowsAndColumns"]?_eh["columnDrill"]:_eh["rowDrill"] ;
    query += " set rowSet as {" + this.generateAxisPart(rowDrill,rows,rowLevels,_eh.orderBy) + "} \n";
    query += " set colSet as {" + this.generateAxisPart(columnDrill,columns,columnLevels,_eh.orderBy) + "} \n";

    var colFilter = [];
    var rowFilter = [];
    $.each(_eh["filters"]["rows"],function(j,k){
        rowFilter.push(_eh["rows"] + ".Dimension.currentMember.Name <> '" + k+"' ");
    });
    if (_eh["swapRowsAndColumns"]){
        query += " set rowFilter as " + (colFilter.length > 0?"Filter(rowSet,"+ colFilter.join(" and ") + " )":"rowSet") + "\n";
        query += " set colFilter as " + (rowFilter.length > 0?"Filter(colSet,"+ rowFilter.join(" and ") + " )":"colSet") + "\n";
    }
    else{
        query += " set rowFilter as " + (rowFilter.length > 0?"Filter(rowSet,"+ rowFilter.join(" and ") + " )":"rowSet") + "\n";
        query += " set colFilter as " + (colFilter.length > 0?"Filter(colSet,"+ colFilter.join(" and ") + " )":"colSet") + "\n";
    }


    query += "select " + (_eh["nonEmptyRows"]?" NON EMPTY ":"") + " rowFilter on rows,\n ";
    query += " " + (_eh["nonEmptyColumns"]?" NON EMPTY ":"") + " colFilter on columns\n ";
    query += " from " + _eh["from"] + "\n";

    var whereArray = [];
    $.each(_eh["where"],function(key,obj){
            var el = typeof obj == 'function'?obj():obj
            if(el.length>0) whereArray.push(el);
        });
    if (whereArray.length>0){
        query += " where ( " + whereArray.join(' , ') + " )";
    }
    //alert(query);
    return query;

}

OlapUtils.mdxQuery.prototype.exclude = function(value){
    this.query["filters"]["rows"].push(value);
}

OlapUtils.mdxQuery.prototype.drillDown = function(value){
    
    //Clear previous excludes
    this.resetFilters();
    
    this.query["drills"].push(this.query.rows);
    this.query.rows = value;
    this.axisPos++;
}

OlapUtils.mdxQuery.prototype.drillUp = function(){
    this.axisPos--;
    return (this.query.rows = this.query["drills"].pop());
}

OlapUtils.mdxQuery.prototype.addCondition = function(key,value){
    return this.addConditionAux(key,value,'focus');
}

OlapUtils.mdxQuery.prototype.addInitialCondition = function(key,value){
    this.addConditionAux(key,value);
}

OlapUtils.mdxQuery.prototype.removeFilter = function(key,value){
    this.removeCondition(key,value,'exclude');
    
    //Re add previous foucs that was removed by exclude.
    var lastExclude = true
    for(v in this.query["conditions"][key]){lastExclude = false; break;}
    if(lastExclude && this.query["conditions"][key+"previousDrillValue"]  != undefined){
        this.addCondition(key,this.query["conditions"][key+"previousDrillValue"]);
        delete this.query["conditions"][key+"previousDrillValue"];
    }
}

OlapUtils.mdxQuery.prototype.removeCondition = function(key,value,op){
    
    if(this.query["conditions"][key]!= undefined){
        if(this.query["conditions"][key][value]!= undefined)
            delete this.query["conditions"][key][value];
        else {//Focus not present because exclusion condition set after focus => Remove all.
            delete this.query["conditions"][key];
            this.resetCondition(key);
            return true;
        }
    }
    
    var condition = value.substr(0,value.indexOf("]")+1) + ".[Filter]"; 
    this.setCondition(key,condition,op);
    return false;
}

OlapUtils.mdxQuery.prototype.removeConditions = function(key){
    this.query["conditions"][key] = [];
    this.resetCondition(key);
}

/**** NEXT FUNCTIONS ARE FOR INTERNAL USE ONLY *******/
OlapUtils.mdxQuery.prototype.replaceConditionsByDrill = function(key,value){

    //Clear previous focus and excludes
    if(this.query["conditions"][key] != undefined)
        this.query["conditions"][key] = [];
    
    return this.addConditionAux(key,value,'drill');
}

OlapUtils.mdxQuery.prototype.replaceConditionByExclude = function(key,value){
    return this.addConditionAux(key,value,'exclude');
}

OlapUtils.mdxQuery.prototype.addConditionAux = function(key,value,op){

    if(op == undefined){
        this.query["where"][key] = value;
        return;
    }
    
    var condition = value.substr(0,value.indexOf("]")+1) + ".[Filter]"; 
    
    //Store initial where cause for this key
    if(this.query["conditions"][key] == undefined){
        this.query["conditions"][key] = [];
        if(this.query["where"][key] != undefined)
            this.query["conditions"][key+"InitialValue"] = this.query["where"][key];
    }
    
    if(this.query["members"][key] == undefined){
        if (op == 'exclude'){
            //this.addMember(key,condition + " as (( "+value+".parent) - ("+value+"))");
        }
        else
            this.addMember(key,condition + " as Aggregate(" + key + "Filter)");
    
    }
        
    this.query["conditions"][key][value] = op
    
    if(op != 'exclude')
        delete this.query["conditions"][key+"previousDrillValue"];
    
    //Remove previous focus and drills for this value
    if(op != 'drill'){
        var aux = [];
        for(v in this.query["conditions"][key]){
            //Store previous focus for first exclude
            if(op == 'exclude' && this.query["conditions"][key+"previousDrillValue"] == undefined && this.query["conditions"][key][v] == 'drill'){
                this.query["conditions"][key+"previousDrillValue"] = v;
            }
            if(this.query["conditions"][key][v] == op) aux[v] = op;
        }
        this.query["conditions"][key] = aux;
    }
    
    return this.setCondition(key,condition,op);
}


OlapUtils.mdxQuery.prototype.setCondition = function(key,condition,op)
{   
    var set = [];
    for(v in this.query["conditions"][key])
        set.push(v);
        
    if(set.length > 0){
        if(op == "focus" || op == "drill")
            this.addSet(key,key + "Filter as {" + set.join(",") + "}");
        else{
            this.addMember(key,condition + " as ( ( "+ set[0] +".parent) - ("+ set.join(") - (") +"))");
        }
        if(condition != undefined)
            this.query["where"][key] = condition;
    }
    else
        this.resetCondition(key);

    return set;
}

OlapUtils.mdxQuery.prototype.addSet = function(key, set){

    this.query["sets"][key] = set;
}

OlapUtils.mdxQuery.prototype.addMember = function(key, member){

    this.query["members"][key] = member;
}

/******************************************************************************************************/
/************************************ MDX QUERYGROUP ***********************************************/
/******************************************************************************************************/

OlapUtils.lastClickedMdxQueryGroup;

OlapUtils.mdxQueryGroup = function(name){
    this.name = name;
    this.mdxQueries = {};
    this.clickedIdx = -1;
    this.clickedValue = "";
    this.activeFilters = {};
    this.activeConditions = {};
};

OlapUtils.mdxQueryGroup.prototype.addMdxQuery = function(idx,mdxQuery,filterDimension, filterAxis, chartObject){
    this.mdxQueries[idx] = {mdxQuery: mdxQuery, filterDimension: filterDimension, filterAxis: filterAxis,chartObject:chartObject};
};

OlapUtils.mdxQueryGroup.prototype.removeMdxQuery = function(idx){
    delete this.mdxQueries.idx;
};


OlapUtils.mdxQueryGroup.prototype.printConditions = function(){

    var out = "";
    var filters = 0;
    var conds = 0;

    for (i in this.activeFilters){
        var a = this.activeFilters[i];
        if (a.length > 0 && ++filters == 1)
            out += "<i>Exclusions: </i>";
        var mdxGroupName = this.name;
        var o = [];
        $.each(a,function(j,k){
            o.push(k[1] + " <a class=\"resetFilterButton\" href='javascript:OlapUtils.mdxGroups[\"" + mdxGroupName + "\"].removeFilter(\"" + i + "\",\"" + k[0] + "\")'>X</a>");
            ++filters;
        });
        
        if(o.length > 0)
            out+= o.join(" , ") + " ;";

    }
    for (i in this.activeConditions){
        var a = this.activeConditions[i];
        if (a.length > 0 &&  ++conds == 1)
            out += " <i>Focus: </i>";
        var mdxGroupName = this.name;
        var o = [];
        $.each(a,function(j,k){
            o.push(k + " <a class=\"resetFilterButton\" href='javascript:OlapUtils.mdxGroups[\"" + mdxGroupName + "\"].removeCondition(\"" + i + "\",\"" + k + "\")'>X</a>");
            ++conds;
        });
        if(o.length > 0)
            out+= o.join(" , ") + "; ";
    }

    if ((conds + filters)>2)
        out += " <a  style=\"padding-left:15px;\" href='javascript:OlapUtils.mdxGroups[\"" + this.name + "\"].resetAll()'>Reset All</a>";

    return out;
}

OlapUtils.mdxQueryGroup.prototype.printEvolutionType = function(object){
    var out = "";
    var myArray = [["Week","Week"],["Month","Month"],["Year","Year"]];

    for(var i= 0, len  = myArray.length; i < len; i++){
        out += "<input onclick='OlapUtils.changeEvolutionType(\"" + object + "radio\")'";
        if(i==0){
            out += " CHECKED ";
        }       
        out += "type='radio' id='" + object + "radio' name='" + object + "radio' value=" + myArray[i][1] + " /> " + myArray[i][1] + (object.separator == undefined?"":object.separator);
    } 

    return out;
}

OlapUtils.mdxQueryGroup.prototype.drillDown = function(key,value){

    Dashboards.incrementRunningCalls();
    var conditions = [];
    
    //CLean previous conditions,drill, and exclude messages for this id
    if(this.activeFilters != undefined) delete this.activeFilters[key];
    if(this.activeConditions != undefined) delete this.activeConditions[key];
            
    for (i in this.mdxQueries){
        var obj = this.mdxQueries[i];
        
        if (i == key){
            obj.mdxQuery.drillDown(value);
        }
        else
            conditions = obj.mdxQuery.replaceConditionsByDrill(key,value);
                
        Dashboards.update(obj.chartObject);
    }
    if(conditions.length > 0)
        this.activeConditions[key] = conditions;
        
    Dashboards.update(Dashboards.getComponent(this.name));
    Dashboards.decrementRunningCalls();
}

OlapUtils.mdxQueryGroup.prototype.drillUp = function(key){

    Dashboards.incrementRunningCalls();
    var conditions = [];
    
    //CLean previous conditions,drill, and exclude messages for this id
    if(this.activeFilters != undefined) delete this.activeFilters[key];
    if(this.activeConditions != undefined) delete this.activeConditions[key];
    
    var keyObj = this.mdxQueries[key];  
    var value =  keyObj.mdxQuery.drillUp();
    for (i in this.mdxQueries){
        var obj = this.mdxQueries[i];
        
        if (i != key){
            if(keyObj.mdxQuery.axisPos > 0)
                conditions = obj.mdxQuery.replaceConditionsByDrill(key,value);
            else
                obj.mdxQuery.removeCondition(key,value,'drill');
        }
                
        Dashboards.update(obj.chartObject);
    }
    if(conditions.length > 0)
        this.activeConditions[key] = conditions;

        
    Dashboards.update(Dashboards.getComponent(this.name));
    Dashboards.decrementRunningCalls();
}

OlapUtils.mdxQueryGroup.prototype.replaceFocus = function(key,values){
    
    for (i in this.mdxQueries)
        if(i != key)
            this.mdxQueries[i].mdxQuery.removeConditions(key);      
    
    this.focus(key,values);
}

OlapUtils.mdxQueryGroup.prototype.focus = function(key,values){
    
    var conditions = [];
    
    Dashboards.incrementRunningCalls();
    
    //CLean previous conditions,drill, and exclude messages for this id
    if(this.activeFilters != undefined) delete this.activeFilters[key];
    if(this.activeConditions != undefined) delete this.activeConditions[key];
            
    for (i in this.mdxQueries){
        if(i != key){
            var obj = this.mdxQueries[i];
            
            for(i = 0; i < values.length; i++){
                conditions = obj.mdxQuery.addCondition(key,values[i]);
            }
                
            Dashboards.update(obj.chartObject);
            
        }
    }
    if(conditions.length > 0)
        this.activeConditions[key] = conditions;
        
    Dashboards.update(Dashboards.getComponent(this.name));
    Dashboards.decrementRunningCalls();
}

OlapUtils.mdxQueryGroup.prototype.exclude = function(key,value){

        Dashboards.incrementRunningCalls();
        var members = value.split("].[");
        var memberValue = members[members.length-1].replace("]","");
        this.mdxQueries[key].mdxQuery.exclude(memberValue)
        Dashboards.update(this.mdxQueries[key].chartObject);
        
        var a = this.activeFilters[key] || [];
        a.push([memberValue,value]);
        this.activeFilters[key] = a;
        
        //Replace focus from active conditions by exclude
        for (i in this.mdxQueries){
            var query = this.mdxQueries[i];
            if (i != key){
                query.mdxQuery.replaceConditionByExclude(key,value);
                Dashboards.update(query.chartObject);
            }
        }
        
        //Remove previous focus message
        if(this.activeConditions[key] != undefined)
            var indexCondition = this.activeConditions[key].indexOf(value);
            if(indexCondition >= 0)
                this.activeConditions[key].splice(indexCondition,1);
        
        Dashboards.decrementRunningCalls();
        
}

OlapUtils.mdxQueryGroup.prototype.expand = function(key){
    this.mdxQueries[key].mdxQuery.axisDepth++;
    Dashboards.update(this.mdxQueries[key].chartObject);
}

OlapUtils.mdxQueryGroup.prototype.collapse = function(key){
    this.mdxQueries[key].mdxQuery.axisDepth--;
    Dashboards.update(this.mdxQueries[key].chartObject);
}

OlapUtils.mdxQueryGroup.prototype.resetAll = function(){

    Dashboards.incrementRunningCalls();
    for (i in this.mdxQueries){
        var obj = this.mdxQueries[i];
        obj.mdxQuery.reset();
        obj.mdxQuery.axisPos = 0;
        obj.mdxQuery.axisDepth = 0;
        Dashboards.update(obj.chartObject);
    }
    this.activeFilters = {};
    this.activeConditions = {};
    Dashboards.update(Dashboards.getComponent(this.name));
    Dashboards.decrementRunningCalls();

}

OlapUtils.mdxQueryGroup.prototype.removeCondition = function(key,value){
    
    Dashboards.incrementRunningCalls();
    
    for (i in this.mdxQueries){
        var obj = this.mdxQueries[i];
        //Remove Conditions and related filters(because filters are added after drill down)
        if(i != key){
            if(obj.mdxQuery.removeCondition(key,value,'focus') && this.activeFilters[key] != undefined )
                delete this.activeFilters[key];
        }
        else {
            obj.mdxQuery.query.rows = typeof obj.mdxQuery.originalHash.rows == 'function'? obj.mdxQuery.originalHash.rows(): obj.mdxQuery.originalHash.rows;
            obj.mdxQuery.axisPos = 0;   
            obj.mdxQuery.resetFilters();
        }
        
        Dashboards.update(obj.chartObject);
    }

    this.activeConditions[key].splice(this.activeConditions[key].indexOf(value),1);
        
    Dashboards.update(Dashboards.getComponent(this.name));
    Dashboards.decrementRunningCalls();
}

OlapUtils.mdxQueryGroup.prototype.removeFilter = function(key,value){
    
    Dashboards.incrementRunningCalls();
    var index = this.mdxQueries[key].mdxQuery.resetFilter(value);
    for (i in this.mdxQueries){
        var obj = this.mdxQueries[i];
        if(i != key)
            obj.mdxQuery.removeFilter(key,this.activeFilters[key][index][1]);
        Dashboards.update(obj.chartObject);
    }
    this.activeFilters[key].splice(index,1);
    if(this.activeFilters[key].length ==0)
        delete this.activeFilters[key];
        
    Dashboards.update(Dashboards.getComponent(this.name));
    Dashboards.decrementRunningCalls();
}

OlapUtils.mdxQueryGroupActionCallback = function(value,m){

    if (value == "cancel")
        return;  // do nothing.

    Dashboards.incrementRunningCalls();
    
    var mqg = OlapUtils.lastClickedMdxQueryGroup;
    var clickedObj = mqg.mdxQueries[mqg.clickedIdx];
    var axis = typeof clickedObj.mdxQuery.query.rows == 'function'?clickedObj.mdxQuery.query.rows():clickedObj.mdxQuery.query.rows;

    if (value == "drilldown"){
        mqg.drillDown(mqg.clickedIdx,axis + ".[" + mqg.clickedValue + "]");
    }
    else if (value == "drillup"){
        mqg.drillUp(mqg.clickedIdx,axis + ".[" + mqg.clickedValue + "]");
    }
    else if (value == "focus"){
        mqg.focus(mqg.clickedIdx,[axis + ".[" + mqg.clickedValue + "]"]);
    }
    else if( value == "filter" ){
        mqg.exclude(mqg.clickedIdx,axis + ".[" + mqg.clickedValue + "]");
    }
    else if (value == "expand"){
        mqg.expand(mqg.clickedIdx);
    }
    else if (value == "collapse"){
        mqg.collapse(mqg.clickedIdx);
    }
    else if (value == "resetall"){
        mqg.resetAll();
    }
    
    Dashboards.update(Dashboards.getComponent(mqg.name));
    Dashboards.decrementRunningCalls();
}

OlapUtils.getAxisPathString = function(axis,axisPath){
    var a = [];
    $.each(axisPath, function(i,v){ a.push("["+ v +"]"); });
    return axis + "." + a.join(".");
}

OlapUtils.changeEvolutionType = function(object){


    var value = "";
    var selector = document.getElementsByName(object);
    for(var i= 0, len  = selector.length; i < len; i++){
        if(selector[i].checked){
            value = selector[i].value;
            continue;
        };
    } 

    this.fireChange("OlapUtils.evolutionType",value);
}

/******************************************************************************************************/
/************************************ GENERIC QUERIES **********************************************/
/******************************************************************************************************/


OlapUtils.GenericMdxQuery = Base.extend({

        mdxQuery : undefined,

        options : {},
        tableDefaults: {},
        chartDefaults: {},

        genericDefaults : {
            dateDim: '[Date]',
            dateLevel: '[Date]',
            dateLevelMonth: '[Month]',
            from: '[CubeName]',
            nonEmptyRows: true,
            rowDrill: true,
            measuresDim: '[Measures]',
            orderBy: undefined,
            debug: false
        },

        constructor: function(options){
        },
        
        getQuery: function(){

            /*for(o in this.options)
                this.options[o] = OlapUtils.ev(this.options[o]);*/
                
            this.query = this.mdxQuery.getQuery();
                
            if(this.options.debug == true){
                alert(this.query);
            }
            
            
            
            return this.query;
        },

        getDataTableOptions: function(options){
            $.extend(this.tableDefaults,options);
            return TableComponent.getDataTableOptions(this.tableDefaults);
        },

        getChartOptions: function(options){
            $.extend(this.chartDefaults,options);
            return this.chartDefaults;
        }


    }); 
    

OlapUtils.EvolutionQuery = OlapUtils.GenericMdxQuery.extend({

        mdxQuery : undefined,
        thisMonth :"",
        lastMonth :"",
        lastYearMonth :"",
        
        specificDefaults : {
            baseDate: '2008-10-01',
            rows: '[Locale Codes]',
            rowLevels: ['Code'],
            measure: '[Total Month Requests]',
            debug: false
        },
        
        tableDefaults : {
            colHeaders: ["Dimension",'Total', '% m/m', '% m/m-12', 'Last 12 months'],
            colTypes: ['string', 'numeric', 'numeric', 'numeric', 'sparkline'],
            colFormats: [null, '%.0f', '%.2f', '%.2f', null],
            colWidths: ['100px', '50px', '50px' , '50px', '80px'],
            displayLength: 10,
            sparklineType: "line",
            sortBy: [[1,'desc']]
        },
        
        
        constructor: function(options,object){

            this.options = jQuery.extend({}, this.genericDefaults, this.specificDefaults, options);
            var options = this.options;
            //options.baseDate = OlapUtils.ev(options.baseDate);
            var thisPeriod = options.dateDim+".[This Period]";
            var lastPeriod = options.dateDim+".[Previous Period]";
            var lastYearPeriod = options.dateDim+".[Last Year Period]";
            var nonEmptyMeasure = ".[Not Null Measure]";        
            
            this.queryBase = {
                from: options.from,
                rows: options.rows,
                rowLevels: options.rowLevels,
                rowDrill: options.rowDrill,
                nonEmptyRows: options.nonEmptyRows,
                columns:  ""+options.measuresDim+nonEmptyMeasure+","+options.measuresDim+".[% m/m],"+options.measuresDim+".[% m/m-12],"+options.measuresDim+".[sparkdatamonths]",
                swapRowsAndColumns: false,
                orderBy: options.orderBy,
                sets: {
                    "now": function(){return "now as [Date].[Date].[" + Dashboards.ev(options.baseDate) + "].Lag(30.0)" + ":" + " [Date].[Date].[" + Dashboards.ev(options.baseDate) + "]" },
                    "oneMonthAgo": function(){return "oneMonthAgo as [Date].[Date].[" + Dashboards.ev(options.baseDate) + "].Lag(60.0)" + ":" + " [Date].[Date].[" + Dashboards.ev(options.baseDate) + "].Lag(30.0)" },
                    "oneYearAgo": function(){return "oneYearAgo as [Date].[Date].[" + Dashboards.ev(options.baseDate) + "].Lag(395.0)" + ":" + " [Date].[Date].[" + Dashboards.ev(options.baseDate) + "].Lag(365.0)" },
                    "last12Months": function(){return "last12Months as LastPeriods(12.0, Ancestor("+options.dateDim+"."+options.dateLevel+".["+  Dashboards.ev(options.baseDate) + "],"+options.dateDim+"."+options.dateLevelMonth+")) "}
                },
                members: {
                    todaysMonth: function(){return "[Date].[TodaysMonth] as Aggregate( now )"},
                    notNullMeasure: function(){return ""+options.measuresDim+nonEmptyMeasure + " as Iif(isEmpty(" + options.measuresDim+"."+options.measure + "), 0 , "+options.measuresDim+"."+options.measure+") "},
                    thisPeriodMeasure: function(){return ""+options.measuresDim+".[This Period] as Aggregate(now*"+options.measuresDim+nonEmptyMeasure+") "},
                    previousPeriodMeasure:function(){return ""+options.measuresDim+".[Previous Period] as Aggregate(oneMonthAgo*"+options.measuresDim+nonEmptyMeasure+") "},
                    lastYearPeriodMeasure:function(){return ""+options.measuresDim+".[Last Year Period] as Aggregate(oneYearAgo*"+options.measuresDim+nonEmptyMeasure+") "},
                    mmMeasure:function(){return ""+options.measuresDim+".[% m/m] as 100.0*("+options.measuresDim+nonEmptyMeasure+" / "+options.measuresDim+".[Previous Period] - 1.0)  "},
                    mm12Measure:function(){return ""+options.measuresDim+".[% m/m-12] as 100.0*("+options.measuresDim+nonEmptyMeasure+" / "+options.measuresDim+".[Last Year Period] - 1.0)  "},
                    sparkdatamonths:function(){return ""+options.measuresDim+".[sparkdatamonths] as Generate([last12Months], Cast(("+options.measuresDim+nonEmptyMeasure+") + 0.0 as String), \" , \") "}
                },
                where:{
                    dateBase: ""+options.dateDim+".[TodaysMonth]"
                }

            };
            // Init this querybase
            this.mdxQuery = new OlapUtils.mdxQuery(this.queryBase);

        },

        queryBase : {}
        

    });



OlapUtils.DimensionAnalysisQuery = OlapUtils.GenericMdxQuery.extend({

        chartTypesTranslation: {},
        translationHash: {},
        mdxQuery : undefined,
        thisMonth :"",
        lastMonth :"",
        lastYearMonth :"",
        
        specificDefaults : {
            startDate: '2008-10-01',
            endDate: '2008-11-01',
            rows: '[Product Operating Systems]',
            rowLevels: ["Platform","Version"],
            measure: '[Total Requests]',
            defaultChartType: "bar",
            debug: false,
            where: {}
        },
        
        tableDefaults : {
            colHeaders: ['Name','Value'],
            colTypes: ['string','numeric'],
            colFormats: [null, '%.0f'],
            sortBy:[[1,'desc']],
            lengthChange: false
        },

        chartDefaults : {
                domainLabelRotationDir: "up",
                domainLabelRotation: "0",
                orientation: "horizontal",
                title: "",
                isStacked: "true",
                is3d: false,
                foregroundAlpha: 0.8,
                showValues: true,
                chartType: function(){ return this.parent.queryBase.extra.translationHash.chartType;},
                datasetType: function(){return this.parent.queryBase.extra.translationHash.datasetType;},
                includeLegend: function(){return this.parent.queryBase.extra.translationHash.includeLegend;},
                topCountAxis: function(){return this.parent.queryBase.extra.translationHash.axis[1];}

            },
        
        constructor: function(options,object){

            this.options = jQuery.extend({}, this.genericDefaults, this.specificDefaults, options);
            var options = this.options;

            this.chartTypesTranslation= {
                "pie": {
                    type: "jFreeChartComponent",
                    chartType: "PieChart", 
                    datasetType: "CategoryDataset", 
                    axis:["columns","rows"], 
                    member: "("+options.dateDim+".[Date Range], "+options.measuresDim+".[Avg])", 
                    includeLegend: false
                },
                "bar": {
                    type: "jFreeChartComponent",
                    chartType: "BarChart", 
                    datasetType: "CategoryDataset", 
                    axis:["columns","rows"], 
                    member: "("+options.dateDim+".[Date Range], "+options.measuresDim+".[Avg])", 
                    includeLegend: false
                },
                "table": {
                    type: "tableComponent",
                    chartType: "PieChart", 
                    datasetType: "CategoryDataset", 
                    axis:["columns","rows"], 
                    member: "("+options.dateDim+".[Date Range], "+options.measuresDim+".[Avg])", 
                    includeLegend: false
                },
                "trend": {
                    type: "jFreeChartComponent",
                    chartType: "AreaChart",
                    datasetType: "TimeSeriesCollection",
                    axis:["rows","columns"], 
                    member: "a",
                    includeLegend: true
                }
            };

            this.queryBase= {
                from: options.from,
                rows: options.rows,
                rowLevels: options.rowLevels,
                rowDrill: options.rowDrill,
                nonEmptyRows: options.nonEmptyRows,
                columns:  function(){return this.extra.translationHash["member"]} ,
                swapRowsAndColumns: function(){return this.extra.translationHash["axis"][0]=="rows" },
                orderBy: "Avg(a,"+options.measuresDim+"."+options.measure+")",

                sets: {
                    "a":
                    function(){return "a as '("+options.dateDim+"."+options.dateLevel+".[" + Dashboards.ev(options.startDate) + "]:"+options.dateDim+"."+options.dateLevel+".["+ Dashboards.ev(options.endDate) + "])'"}
                },
                members: {
                    daterange: ""+options.dateDim+".[Date Range] as Aggregate(a)",
                    average: ""+options.measuresDim+".[Avg] as 'Avg(a,"+options.measuresDim+"."+options.measure+")'"
                },
                where: options.where,               
                extra: {}
            };

            // pass the properties of this to the chartDefaults
            var _chart = Dashboards.clone(this);
            delete _chart.chartDefaults;
            this.chartDefaults.parent = _chart;
            
            this.setChartType(options.defaultChartType);

            // Init this querybase
            this.mdxQuery = new OlapUtils.mdxQuery(this.queryBase);

        },

        setChartType: function(chartType){
            this.queryBase.extra.translationHash = this.chartTypesTranslation[chartType];
            this.chartDefaults.parent.queryBase.extra.translationHash = this.chartTypesTranslation[chartType];
        },

        getComponentType: function(){
            return this.chartDefaults.parent.queryBase.extra.translationHash.type;
        },

        queryBase : {}
        

    });
